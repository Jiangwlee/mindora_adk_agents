import {
  __async,
  __commonJS,
  __export,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-4MWRP73S.js";

// node_modules/json-source-map/index.js
var require_json_source_map = __commonJS({
  "node_modules/json-source-map/index.js"(exports2) {
    "use strict";
    var escapedChars = {
      "b": "\b",
      "f": "\f",
      "n": "\n",
      "r": "\r",
      "t": "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var A_CODE = "a".charCodeAt();
    exports2.parse = function(source, _, options) {
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var bigint = options && options.bigint && typeof BigInt != "undefined";
      return {
        data: _parse("", true),
        pointers
      };
      function _parse(ptr, topLevel) {
        whitespace();
        var data;
        map2(ptr, "value");
        var char = getChar();
        switch (char) {
          case "t":
            read("rue");
            data = true;
            break;
          case "f":
            read("alse");
            data = false;
            break;
          case "n":
            read("ull");
            data = null;
            break;
          case '"':
            data = parseString();
            break;
          case "[":
            data = parseArray(ptr);
            break;
          case "{":
            data = parseObject(ptr);
            break;
          default:
            backChar();
            if ("-0123456789".indexOf(char) >= 0) data = parseNumber();
            else unexpectedToken();
        }
        map2(ptr, "valueEnd");
        whitespace();
        if (topLevel && pos < source.length) unexpectedToken();
        return data;
      }
      function whitespace() {
        loop: while (pos < source.length) {
          switch (source[pos]) {
            case " ":
              column++;
              break;
            case "	":
              column += 4;
              break;
            case "\r":
              column = 0;
              break;
            case "\n":
              column = 0;
              line++;
              break;
            default:
              break loop;
          }
          pos++;
        }
      }
      function parseString() {
        var str = "";
        var char;
        while (true) {
          char = getChar();
          if (char == '"') {
            break;
          } else if (char == "\\") {
            char = getChar();
            if (char in escapedChars) str += escapedChars[char];
            else if (char == "u") str += getCharCode();
            else wasUnexpectedToken();
          } else {
            str += char;
          }
        }
        return str;
      }
      function parseNumber() {
        var numStr = "";
        var integer = true;
        if (source[pos] == "-") numStr += getChar();
        numStr += source[pos] == "0" ? getChar() : getDigits();
        if (source[pos] == ".") {
          numStr += getChar() + getDigits();
          integer = false;
        }
        if (source[pos] == "e" || source[pos] == "E") {
          numStr += getChar();
          if (source[pos] == "+" || source[pos] == "-") numStr += getChar();
          numStr += getDigits();
          integer = false;
        }
        var result2 = +numStr;
        return bigint && integer && (result2 > Number.MAX_SAFE_INTEGER || result2 < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result2;
      }
      function parseArray(ptr) {
        whitespace();
        var arr = [];
        var i2 = 0;
        if (getChar() == "]") return arr;
        backChar();
        while (true) {
          var itemPtr = ptr + "/" + i2;
          arr.push(_parse(itemPtr));
          whitespace();
          var char = getChar();
          if (char == "]") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
          i2++;
        }
        return arr;
      }
      function parseObject(ptr) {
        whitespace();
        var obj = {};
        if (getChar() == "}") return obj;
        backChar();
        while (true) {
          var loc = getLoc();
          if (getChar() != '"') wasUnexpectedToken();
          var key = parseString();
          var propPtr = ptr + "/" + escapeJsonPointer(key);
          mapLoc(propPtr, "key", loc);
          map2(propPtr, "keyEnd");
          whitespace();
          if (getChar() != ":") wasUnexpectedToken();
          whitespace();
          obj[key] = _parse(propPtr);
          whitespace();
          var char = getChar();
          if (char == "}") break;
          if (char != ",") wasUnexpectedToken();
          whitespace();
        }
        return obj;
      }
      function read(str) {
        for (var i2 = 0; i2 < str.length; i2++) if (getChar() !== str[i2]) wasUnexpectedToken();
      }
      function getChar() {
        checkUnexpectedEnd();
        var char = source[pos];
        pos++;
        column++;
        return char;
      }
      function backChar() {
        pos--;
        column--;
      }
      function getCharCode() {
        var count = 4;
        var code = 0;
        while (count--) {
          code <<= 4;
          var char = getChar().toLowerCase();
          if (char >= "a" && char <= "f") code += char.charCodeAt() - A_CODE + 10;
          else if (char >= "0" && char <= "9") code += +char;
          else wasUnexpectedToken();
        }
        return String.fromCharCode(code);
      }
      function getDigits() {
        var digits = "";
        while (source[pos] >= "0" && source[pos] <= "9") digits += getChar();
        if (digits.length) return digits;
        checkUnexpectedEnd();
        unexpectedToken();
      }
      function map2(ptr, prop) {
        mapLoc(ptr, prop, getLoc());
      }
      function mapLoc(ptr, prop, loc) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = loc;
      }
      function getLoc() {
        return {
          line,
          column,
          pos
        };
      }
      function unexpectedToken() {
        throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
      }
      function wasUnexpectedToken() {
        backChar();
        unexpectedToken();
      }
      function checkUnexpectedEnd() {
        if (pos >= source.length) throw new SyntaxError("Unexpected end of JSON input");
      }
    };
    exports2.stringify = function(data, _, options) {
      if (!validType(data)) return;
      var wsLine = 0;
      var wsPos, wsColumn;
      var whitespace = typeof options == "object" ? options.space : options;
      switch (typeof whitespace) {
        case "number":
          var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
          whitespace = len && repeat2(len, " ");
          wsPos = len;
          wsColumn = len;
          break;
        case "string":
          whitespace = whitespace.slice(0, 10);
          wsPos = 0;
          wsColumn = 0;
          for (var j = 0; j < whitespace.length; j++) {
            var char = whitespace[j];
            switch (char) {
              case " ":
                wsColumn++;
                break;
              case "	":
                wsColumn += 4;
                break;
              case "\r":
                wsColumn = 0;
                break;
              case "\n":
                wsColumn = 0;
                wsLine++;
                break;
              default:
                throw new Error("whitespace characters not allowed in JSON");
            }
            wsPos++;
          }
          break;
        default:
          whitespace = void 0;
      }
      var json2 = "";
      var pointers = {};
      var line = 0;
      var column = 0;
      var pos = 0;
      var es6 = options && options.es6 && typeof Map == "function";
      _stringify(data, 0, "");
      return {
        json: json2,
        pointers
      };
      function _stringify(_data, lvl, ptr) {
        map2(ptr, "value");
        switch (typeof _data) {
          case "number":
          case "bigint":
          case "boolean":
            out("" + _data);
            break;
          case "string":
            out(quoted(_data));
            break;
          case "object":
            if (_data === null) {
              out("null");
            } else if (typeof _data.toJSON == "function") {
              out(quoted(_data.toJSON()));
            } else if (Array.isArray(_data)) {
              stringifyArray();
            } else if (es6) {
              if (_data.constructor.BYTES_PER_ELEMENT) stringifyArray();
              else if (_data instanceof Map) stringifyMapSet();
              else if (_data instanceof Set) stringifyMapSet(true);
              else stringifyObject();
            } else {
              stringifyObject();
            }
        }
        map2(ptr, "valueEnd");
        function stringifyArray() {
          if (_data.length) {
            out("[");
            var itemLvl = lvl + 1;
            for (var i2 = 0; i2 < _data.length; i2++) {
              if (i2) out(",");
              indent(itemLvl);
              var item = validType(_data[i2]) ? _data[i2] : null;
              var itemPtr = ptr + "/" + i2;
              _stringify(item, itemLvl, itemPtr);
            }
            indent(lvl);
            out("]");
          } else {
            out("[]");
          }
        }
        function stringifyObject() {
          var keys3 = Object.keys(_data);
          if (keys3.length) {
            out("{");
            var propLvl = lvl + 1;
            for (var i2 = 0; i2 < keys3.length; i2++) {
              var key = keys3[i2];
              var value = _data[key];
              if (validType(value)) {
                if (i2) out(",");
                var propPtr = ptr + "/" + escapeJsonPointer(key);
                indent(propLvl);
                map2(propPtr, "key");
                out(quoted(key));
                map2(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
            }
            indent(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
        function stringifyMapSet(isSet2) {
          if (_data.size) {
            out("{");
            var propLvl = lvl + 1;
            var first = true;
            var entries = _data.entries();
            var entry = entries.next();
            while (!entry.done) {
              var item = entry.value;
              var key = item[0];
              var value = isSet2 ? true : item[1];
              if (validType(value)) {
                if (!first) out(",");
                first = false;
                var propPtr = ptr + "/" + escapeJsonPointer(key);
                indent(propLvl);
                map2(propPtr, "key");
                out(quoted(key));
                map2(propPtr, "keyEnd");
                out(":");
                if (whitespace) out(" ");
                _stringify(value, propLvl, propPtr);
              }
              entry = entries.next();
            }
            indent(lvl);
            out("}");
          } else {
            out("{}");
          }
        }
      }
      function out(str) {
        column += str.length;
        pos += str.length;
        json2 += str;
      }
      function indent(lvl) {
        if (whitespace) {
          json2 += "\n" + repeat2(lvl, whitespace);
          line++;
          column = 0;
          while (lvl--) {
            if (wsLine) {
              line += wsLine;
              column = wsColumn;
            } else {
              column += wsColumn;
            }
            pos += wsPos;
          }
          pos += 1;
        }
      }
      function map2(ptr, prop) {
        pointers[ptr] = pointers[ptr] || {};
        pointers[ptr][prop] = {
          line,
          column,
          pos
        };
      }
      function repeat2(n2, str) {
        return Array(n2 + 1).join(str);
      }
    };
    var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
    function validType(data) {
      return VALID_TYPES.indexOf(typeof data) >= 0;
    }
    var ESC_QUOTE = /"|\\/g;
    var ESC_B = /[\b]/g;
    var ESC_F = /\f/g;
    var ESC_N = /\n/g;
    var ESC_R = /\r/g;
    var ESC_T = /\t/g;
    function quoted(str) {
      str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
      return '"' + str + '"';
    }
    var ESC_0 = /~/g;
    var ESC_1 = /\//g;
    function escapeJsonPointer(str) {
      return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
    }
  }
});

// node_modules/natural-compare-lite/index.js
var require_natural_compare_lite = __commonJS({
  "node_modules/natural-compare-lite/index.js"(exports2, module2) {
    var naturalCompare = function(a2, b) {
      var i2, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
      function getCode(str, pos, code) {
        if (code) {
          for (i2 = pos; code = getCode(str, i2), code < 76 && code > 65; ) ++i2;
          return +str.slice(pos - 1, i2);
        }
        code = alphabet && alphabet.indexOf(str.charAt(pos));
        return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
      }
      if ((a2 += "") != (b += "")) for (; codeB; ) {
        codeA = getCode(a2, posA++);
        codeB = getCode(b, posB++);
        if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
          codeA = getCode(a2, posA, posA);
          codeB = getCode(b, posB, posA = i2);
          posB = i2;
        }
        if (codeA != codeB) return codeA < codeB ? -1 : 1;
      }
      return 0;
    };
    try {
      module2.exports = naturalCompare;
    } catch (e2) {
      String.naturalCompare = naturalCompare;
    }
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s2) {
        super();
        if (!exports2.IDENTIFIER.test(s2)) throw new Error("CodeGen: name must be a valid identifier");
        this.str = s2;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return {
          [this.str]: 1
        };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a3;
        return (_a3 = this._str) !== null && _a3 !== void 0 ? _a3 : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
      }
      get names() {
        var _a3;
        return (_a3 = this._names) !== null && _a3 !== void 0 ? _a3 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i2 = 0;
      while (i2 < args.length) {
        addCodeArg(code, args[i2]);
        code.push(strs[++i2]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i2 = 0;
      while (i2 < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i2]);
        expr.push(plus, safeStringify(strs[++i2]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code) code.push(...arg._items);
      else if (arg instanceof Name) code.push(arg);
      else code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i2 = 1;
      while (i2 < expr.length - 1) {
        if (expr[i2] === plus) {
          const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
          if (res !== void 0) {
            expr.splice(i2 - 1, 3, res);
            continue;
          }
          expr[i2++] = "+";
        }
        i2++;
      }
    }
    function mergeExprItems(a2, b) {
      if (b === '""') return a2;
      if (a2 === '""') return b;
      if (typeof a2 == "string") {
        if (b instanceof Name || a2[a2.length - 1] !== '"') return;
        if (typeof b != "string") return `${a2.slice(0, -1)}${b}"`;
        if (b[0] === '"') return a2.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a2 instanceof Name)) return `"${a2}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name2) {
        super(`CodeGen: "code" for ${name2} not defined`);
        this.value = name2.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({
        prefixes,
        parent: parent2
      } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent2;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng2 = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng2.index++}`;
      }
      _nameGroup(prefix) {
        var _a3, _b;
        if (((_b = (_a3 = this._parent) === null || _a3 === void 0 ? void 0 : _a3._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = {
          prefix,
          index: 0
        };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, {
        property: property2,
        itemIndex
      }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property2)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = __spreadProps(__spreadValues({}, opts), {
          _n: opts.lines ? line : code_1.nil
        });
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a3;
        if (value.ref === void 0) throw new Error("CodeGen: ref must be passed in value");
        const name2 = this.toName(nameOrPrefix);
        const {
          prefix
        } = name2;
        const valueKey = (_a3 = value.key) !== null && _a3 !== void 0 ? _a3 : value.ref;
        let vs2 = this._values[prefix];
        if (vs2) {
          const _name = vs2.get(valueKey);
          if (_name) return _name;
        } else {
          vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs2.set(valueKey, name2);
        const s2 = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s2.length;
        s2[itemIndex] = value.ref;
        name2.setValue(value, {
          property: prefix,
          itemIndex
        });
        return name2;
      }
      getValue(prefix, keyOrRef) {
        const vs2 = this._values[prefix];
        if (!vs2) return;
        return vs2.get(keyOrRef);
      }
      scopeRefs(scopeName, values2 = this._values) {
        return this._reduceValues(values2, (name2) => {
          if (name2.scopePath === void 0) throw new Error(`CodeGen: name "${name2}" has no value`);
          return (0, code_1._)`${scopeName}${name2.scopePath}`;
        });
      }
      scopeCode(values2 = this._values, usedValues, getCode) {
        return this._reduceValues(values2, (name2) => {
          if (name2.value === void 0) throw new Error(`CodeGen: name "${name2}" has no value`);
          return name2.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values2, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values2) {
          const vs2 = values2[prefix];
          if (!vs2) continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs2.forEach((name2) => {
            if (nameSet.has(name2)) return;
            nameSet.set(name2, UsedValueState.Started);
            let c = valueCode(name2);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name2} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name2)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name2);
            }
            nameSet.set(name2, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function() {
        return code_2._;
      }
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function() {
        return code_2.str;
      }
    });
    Object.defineProperty(exports2, "strConcat", {
      enumerable: true,
      get: function() {
        return code_2.strConcat;
      }
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function() {
        return code_2.nil;
      }
    });
    Object.defineProperty(exports2, "getProperty", {
      enumerable: true,
      get: function() {
        return code_2.getProperty;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return code_2.stringify;
      }
    });
    Object.defineProperty(exports2, "regexpCode", {
      enumerable: true,
      get: function() {
        return code_2.regexpCode;
      }
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function() {
        return code_2.Name;
      }
    });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return scope_2.Scope;
      }
    });
    Object.defineProperty(exports2, "ValueScope", {
      enumerable: true,
      get: function() {
        return scope_2.ValueScope;
      }
    });
    Object.defineProperty(exports2, "ValueScopeName", {
      enumerable: true,
      get: function() {
        return scope_2.ValueScopeName;
      }
    });
    Object.defineProperty(exports2, "varKinds", {
      enumerable: true,
      get: function() {
        return scope_2.varKinds;
      }
    });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      constructor(varKind, name2, rhs) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.rhs = rhs;
      }
      render({
        es5,
        _n
      }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str]) return;
        if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({
        _n
      }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op2, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op2;
      }
      render({
        _n
      }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({
        _n
      }) {
        return `${this.label}:` + _n;
      }
    };
    var Break2 = class extends Node2 {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({
        _n
      }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node2 {
      constructor(error) {
        super();
        this.error = error;
      }
      render({
        _n
      }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      constructor(code) {
        super();
        this.code = code;
      }
      render({
        _n
      }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const {
          nodes
        } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2].optimizeNodes();
          if (Array.isArray(n2)) nodes.splice(i2, 1, ...n2);
          else if (n2) nodes[i2] = n2;
          else nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const {
          nodes
        } = this;
        let i2 = nodes.length;
        while (i2--) {
          const n2 = nodes[i2];
          if (n2.optimizeNames(names, constants)) continue;
          subtractNames(names, n2.names);
          nodes.splice(i2, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If2 = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else) code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond2 = this.condition;
        if (cond2 === true) return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns2 = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
        }
        if (e2) {
          if (cond2 === false) return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length) return this;
          return new _If(not(cond2), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond2 === false || !this.nodes.length) return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a3;
        this.else = (_a3 = this.else) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else)) return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else) addNames(names, this.else.names);
        return names;
      }
    };
    If2.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name2, from, to2) {
        super();
        this.varKind = varKind;
        this.name = name2;
        this.from = from;
        this.to = to2;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const {
          name: name2,
          from,
          to: to2
        } = this;
        return `for(${varKind} ${name2}=${from}; ${name2}<${to2}; ${name2}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name2, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name2;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants)) return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name2, args, async) {
        super();
        this.name = name2;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch) code += this.catch.render(opts);
        if (this.finally) code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a3, _b;
        super.optimizeNodes();
        (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a3, _b;
        super.optimizeNames(names, constants);
        (_a3 = this.catch) === null || _a3 === void 0 ? void 0 : _a3.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch) addNames(names, this.catch.names);
        if (this.finally) addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = __spreadProps(__spreadValues({}, opts), {
          _n: opts.lines ? "\n" : ""
        });
        this._extScope = extScope;
        this._scope = new scope_1.Scope({
          parent: extScope
        });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name2 = this._extScope.value(prefixOrName, value);
        const vs2 = this._values[name2.prefix] || (this._values[name2.prefix] = /* @__PURE__ */ new Set());
        vs2.add(name2);
        return name2;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant2) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant2) this._constants[name2.str] = rhs;
        this._leafNode(new Def(varKind, name2, rhs));
        return name2;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function") c();
        else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1) code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If2(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If2(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If2, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody) this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name2, from, to2), () => forBody(name2));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name2 = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i2) => {
            this.var(name2, (0, code_1._)`${arr}[${i2}]`);
            forBody(name2);
          });
        }
        return this._for(new ForIter("of", varKind, name2, iterable), () => forBody(name2));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name2 = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name2, obj), () => forBody(name2));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break2(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1) throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode) throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body) this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0) throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name2, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name2, args, async));
        if (funcBody) this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If2)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns2 = this._nodes;
        return ns2[ns2.length - 1];
      }
      set _currNode(node) {
        const ns2 = this._nodes;
        ns2[ns2.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from) names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name) return replaceName(expr);
      if (!canOptimize(expr)) return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name) c = replaceName(c);
        if (c instanceof code_1._Code) items.push(...c._items);
        else items.push(c);
        return items;
      }, []));
      function replaceName(n2) {
        const c = constants[n2.str];
        if (c === void 0 || names[n2.str] !== 1) return n2;
        delete names[n2.str];
        return c;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from) names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or2(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or2;
    function mappend(op2) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op2} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr) hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it3, schema) {
      if (typeof schema == "boolean") return schema;
      if (Object.keys(schema).length === 0) return true;
      checkUnknownRules(it3, schema);
      return !schemaHasRules(schema, it3.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it3, schema = it3.schema) {
      const {
        opts,
        self: self2
      } = it3;
      if (!opts.strictSchema) return;
      if (typeof schema === "boolean") return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key]) checkStrictMode(it3, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (rules[key]) return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (key !== "$ref" && RULES.all[key]) return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({
      topSchemaRef,
      schemaPath
    }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean") return schema;
        if (typeof schema == "string") return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword2)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number") return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs2, f) {
      if (Array.isArray(xs2)) {
        for (const x of xs2) f(x);
      } else {
        f(xs2);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({
      mergeNames,
      mergeToName,
      mergeValues,
      resultToName
    }) {
      return (gen, from, to2, toName) => {
        const res = to2 === void 0 ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues(from, to2);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
        }),
        mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
          if (from === true) {
            gen.assign(to2, true);
          } else {
            gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
            setEvaluated(gen, to2, from);
          }
        }),
        mergeValues: (from, to2) => from === true ? true : __spreadValues(__spreadValues({}, from), to2),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
        mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
        mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps2) {
      if (ps2 === true) return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps2 !== void 0) setEvaluated(gen, props, ps2);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps2) {
      Object.keys(ps2).forEach((p2) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p2)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it3, msg, mode = it3.opts.strictSchema) {
      if (!mode) return;
      msg = `strict mode: ${msg}`;
      if (mode === true) throw new Error(msg);
      it3.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({
        keyword: keyword2
      }) => (0, codegen_1.str)`must pass "${keyword2}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({
        keyword: keyword2,
        schemaType
      }) => schemaType ? (0, codegen_1.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword2}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const {
        it: it3
      } = cxt;
      const {
        gen,
        compositeRule,
        allErrors
      } = it3;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it3, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const {
        it: it3
      } = cxt;
      const {
        gen,
        compositeRule,
        allErrors
      } = it3;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it3, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({
      gen,
      keyword: keyword2,
      schemaValue,
      data,
      errsCount,
      it: it3
    }) {
      if (errsCount === void 0) throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i2) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i2}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it3.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it3.errSchemaPath}/${keyword2}`);
        if (it3.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it3, errs) {
      const {
        gen,
        validateName,
        schemaEnv
      } = it3;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it3.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const {
        createErrors
      } = cxt.it;
      if (createErrors === false) return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const {
        gen,
        it: it3
      } = cxt;
      const keyValues = [errorInstancePath(it3, errorPaths), errorSchemaPath(cxt, errorPaths)];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({
      errorPath
    }, {
      instancePath
    }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({
      keyword: keyword2,
      it: {
        errSchemaPath
      }
    }, {
      schemaPath,
      parentSchema
    }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword2}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, {
      params,
      message
    }, keyValues) {
      const {
        keyword: keyword2,
        data,
        schemaValue,
        it: it3
      } = cxt;
      const {
        opts,
        propertyName: propertyName2,
        topSchemaRef,
        schemaPath
      } = it3;
      keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName2) keyValues.push([E.propertyName, propertyName2]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it3) {
      const {
        gen,
        schema,
        validateName
      } = it3;
      if (schema === false) {
        falseSchemaError(it3, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it3, valid) {
      const {
        gen,
        schema
      } = it3;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it3);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it3, overrideAllErrors) {
      const {
        gen,
        data
      } = it3;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it3
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: {
          type: "number",
          rules: []
        },
        string: {
          type: "string",
          rules: []
        },
        array: {
          type: "array",
          rules: []
        },
        object: {
          type: "object",
          rules: []
        }
      };
      return {
        types: __spreadProps(__spreadValues({}, groups), {
          integer: true,
          boolean: true,
          null: true
        }),
        rules: [{
          rules: []
        }, groups.number, groups.string, groups.array, groups.object],
        post: {
          rules: []
        },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({
      schema,
      self: self2
    }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a3;
      return schema[rule.keyword] !== void 0 || ((_a3 = rule.definition.implements) === null || _a3 === void 0 ? void 0 : _a3.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false) throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true) types2.push("null");
      }
      return types2;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts2) {
      const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
      if (types2.every(rules_1.isJSONType)) return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it3, types2) {
      const {
        gen,
        data,
        opts
      } = it3;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it3, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length) coerceData(it3, types2, coerceTo);
          else reportTypeError(it3);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t3) => COERCIBLE.has(t3) || coerceTypes === "array" && t3 === "array") : [];
    }
    function coerceData(it3, types2, coerceTo) {
      const {
        gen,
        data,
        opts
      } = it3;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t3 of coerceTo) {
        if (COERCIBLE.has(t3) || t3 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t3);
        }
      }
      gen.else();
      reportTypeError(it3);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it3, coerced);
      });
      function coerceSpecificType(t3) {
        switch (t3) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({
      gen,
      parentData,
      parentDataProperty
    }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond2;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond2 = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond2 = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond2 = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond2 = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond2 : (0, codegen_1.not)(cond2);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond2;
      const types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond2 = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond2 = codegen_1.nil;
      }
      if (types2.number) delete types2.integer;
      for (const t3 in types2) cond2 = (0, codegen_1.and)(cond2, checkDataType(t3, data, strictNums, correct));
      return cond2;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({
        schema
      }) => `must be ${schema}`,
      params: ({
        schema,
        schemaValue
      }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it3) {
      const cxt = getTypeErrorContext(it3);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it3) {
      const {
        gen,
        data,
        schema
      } = it3;
      const schemaCode = (0, util_1.schemaRefOrVal)(it3, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it3
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it3, ty) {
      const {
        properties,
        items
      } = it3.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it3, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i2) => assignDefault(it3, i2, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it3, prop, defaultValue) {
      const {
        gen,
        compositeRule,
        data,
        opts
      } = it3;
      if (defaultValue === void 0) return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it3, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const {
        gen,
        data,
        it: it3
      } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it3.opts.ownProperties), () => {
        cxt.setParams({
          missingProperty: (0, codegen_1._)`${prop}`
        }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({
      gen,
      data,
      it: {
        opts
      }
    }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({
        missingProperty: missing
      }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property2) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property2})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property2, ownProperties) {
      const cond2 = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond2} && ${isOwnProperty(gen, data, property2)}` : cond2;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property2, ownProperties) {
      const cond2 = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond2, (0, codegen_1.not)(isOwnProperty(gen, data, property2))) : cond2;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it3, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1.alwaysValidSchema)(it3, schemaMap[p2]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({
      schemaCode,
      data,
      it: {
        gen,
        topSchemaRef,
        schemaPath,
        errorPath
      },
      it: it3
    }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it3.parentData], [names_1.default.parentDataProperty, it3.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];
      if (it3.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({
      gen,
      it: {
        opts
      }
    }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const {
        regExp
      } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const {
        gen,
        data,
        keyword: keyword2,
        it: it3
      } = cxt;
      const valid = gen.name("valid");
      if (it3.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i2) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i2,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const {
        gen,
        schema,
        keyword: keyword2,
        it: it3
      } = cxt;
      if (!Array.isArray(schema)) throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it3, sch));
      if (alwaysValid && !it3.opts.unevaluated) return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i2) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged) gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const {
        gen,
        keyword: keyword2,
        schema,
        parentSchema,
        it: it3
      } = cxt;
      const macroSchema = def.macro.call(it3.self, schema, parentSchema, it3);
      const schemaRef = useKeyword(gen, keyword2, macroSchema);
      if (it3.opts.validateSchema !== false) it3.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it3.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a3;
      const {
        gen,
        keyword: keyword2,
        schema,
        parentSchema,
        $data,
        it: it3
      } = cxt;
      checkAsyncKeyword(it3, def);
      const validate = !$data && def.compile ? def.compile.call(it3.self, schema, parentSchema, it3) : def.validate;
      const validateRef = useKeyword(gen, keyword2, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying) modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it3.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it3.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a4;
        gen.if((0, codegen_1.not)((_a4 = def.valid) !== null && _a4 !== void 0 ? _a4 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const {
        gen,
        data,
        it: it3
      } = cxt;
      gen.if(it3.parentData, () => gen.assign(data, (0, codegen_1._)`${it3.parentData}[${it3.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const {
        gen
      } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({
      schemaEnv
    }, def) {
      if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword2, result2) {
      if (result2 === void 0) throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen.scopeValue("keyword", typeof result2 == "function" ? {
        ref: result2
      } : {
        ref: result2,
        code: (0, codegen_1.stringify)(result2)
      });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st3) => st3 === "array" ? Array.isArray(schema) : st3 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st3 || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({
      schema,
      opts,
      self: self2,
      errSchemaPath
    }, def, keyword2) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword2) : def.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log") self2.logger.error(msg);
          else throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it3, {
      keyword: keyword2,
      schemaProp,
      schema,
      schemaPath,
      errSchemaPath,
      topSchemaRef
    }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it3.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it3.schemaPath}${(0, codegen_1.getProperty)(keyword2)}`,
          errSchemaPath: `${it3.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it3.schemaPath}${(0, codegen_1.getProperty)(keyword2)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it3.errSchemaPath}/${keyword2}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it3, {
      dataProp,
      dataPropType: dpType,
      data,
      dataTypes,
      propertyName: propertyName2
    }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const {
        gen
      } = it3;
      if (dataProp !== void 0) {
        const {
          errorPath,
          dataPathArr,
          opts
        } = it3;
        const nextData = gen.let("data", (0, codegen_1._)`${it3.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName2 !== void 0) subschema.propertyName = propertyName2;
      }
      if (dataTypes) subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it3.dataLevel + 1;
        subschema.dataTypes = [];
        it3.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it3.data;
        subschema.dataNames = [...it3.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, {
      jtdDiscriminator,
      jtdMetadata,
      compositeRule,
      createErrors,
      allErrors
    }) {
      if (compositeRule !== void 0) subschema.compositeRule = compositeRule;
      if (createErrors !== void 0) subschema.createErrors = createErrors;
      if (allErrors !== void 0) subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length, i2, keys3;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; ) if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
        keys3 = Object.keys(a2);
        length = keys3.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys3[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys3[i2];
          if (!equal(a2[key], b[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i2 = 0; i2 < sch.length; i2++) _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean") return true;
      if (limit === true) return !hasRef(schema);
      if (!limit) return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key)) return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef)) return true;
        if (typeof sch == "object" && hasRef(sch)) return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref") return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key)) continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity) return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false) id2 = normalizeId(id2);
      const p2 = resolver.parse(id2);
      return _getFullPath(resolver, p2);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p2) {
      const serialized = resolver.serialize(p2);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean") return {};
      const {
        schemaId,
        uriResolver
      } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = {
        "": schId
      };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, {
        allKeys: true
      }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0) return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref)) throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2)) throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it3) {
      if (isSchemaObj(it3)) {
        checkKeywords(it3);
        if (schemaCxtHasRules(it3)) {
          topSchemaObjCode(it3);
          return;
        }
      }
      validateFunction(it3, () => (0, boolSchema_1.topBoolOrEmptySchema)(it3));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({
      gen,
      validateName,
      schema,
      schemaEnv,
      opts
    }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it3) {
      const {
        schema,
        opts,
        gen
      } = it3;
      validateFunction(it3, () => {
        if (opts.$comment && schema.$comment) commentKeyword(it3);
        checkNoDefault(it3);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated) resetEvaluated(it3);
        typeAndKeywords(it3);
        returnResults(it3);
      });
      return;
    }
    function resetEvaluated(it3) {
      const {
        gen,
        validateName
      } = it3;
      it3.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it3.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it3.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it3.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it3.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it3, valid) {
      if (isSchemaObj(it3)) {
        checkKeywords(it3);
        if (schemaCxtHasRules(it3)) {
          subSchemaObjCode(it3, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it3, valid);
    }
    function schemaCxtHasRules({
      schema,
      self: self2
    }) {
      if (typeof schema == "boolean") return !schema;
      for (const key in schema) if (self2.RULES.all[key]) return true;
      return false;
    }
    function isSchemaObj(it3) {
      return typeof it3.schema != "boolean";
    }
    function subSchemaObjCode(it3, valid) {
      const {
        schema,
        gen,
        opts
      } = it3;
      if (opts.$comment && schema.$comment) commentKeyword(it3);
      updateContext(it3);
      checkAsyncSchema(it3);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it3, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it3) {
      (0, util_1.checkUnknownRules)(it3);
      checkRefsAndKeywords(it3);
    }
    function typeAndKeywords(it3, errsCount) {
      if (it3.opts.jtd) return schemaKeywords(it3, [], false, errsCount);
      const types2 = (0, dataType_1.getSchemaTypes)(it3.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it3, types2);
      schemaKeywords(it3, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it3) {
      const {
        schema,
        errSchemaPath,
        opts,
        self: self2
      } = it3;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it3) {
      const {
        schema,
        opts
      } = it3;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it3, "default is ignored in the schema root");
      }
    }
    function updateContext(it3) {
      const schId = it3.schema[it3.opts.schemaId];
      if (schId) it3.baseId = (0, resolve_1.resolveUrl)(it3.opts.uriResolver, it3.baseId, schId);
    }
    function checkAsyncSchema(it3) {
      if (it3.schema.$async && !it3.schemaEnv.$async) throw new Error("async schema in sync schema");
    }
    function commentKeyword({
      gen,
      schemaEnv,
      schema,
      errSchemaPath,
      opts
    }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", {
          ref: schemaEnv.root
        });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it3) {
      const {
        gen,
        schemaEnv,
        validateName,
        ValidationError,
        opts
      } = it3;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated) assignEvaluated(it3);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({
      gen,
      evaluated,
      props,
      items
    }) {
      if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it3, types2, typeErrors, errsCount) {
      const {
        gen,
        schema,
        data,
        allErrors,
        opts,
        self: self2
      } = it3;
      const {
        RULES
      } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it3, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd) checkStrictTypes(it3, types2);
      gen.block(() => {
        for (const group of RULES.rules) groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it3, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it3);
          }
          gen.endIf();
        } else {
          iterateKeywords(it3, group);
        }
        if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it3, group) {
      const {
        gen,
        schema,
        opts: {
          useDefaults
        }
      } = it3;
      if (useDefaults) (0, defaults_1.assignDefaults)(it3, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it3, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it3, types2) {
      if (it3.schemaEnv.meta || !it3.opts.strictTypes) return;
      checkContextTypes(it3, types2);
      if (!it3.opts.allowUnionTypes) checkMultipleTypes(it3, types2);
      checkKeywordTypes(it3, it3.dataTypes);
    }
    function checkContextTypes(it3, types2) {
      if (!types2.length) return;
      if (!it3.dataTypes.length) {
        it3.dataTypes = types2;
        return;
      }
      types2.forEach((t3) => {
        if (!includesType(it3.dataTypes, t3)) {
          strictTypesError(it3, `type "${t3}" not allowed by context "${it3.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it3, types2);
    }
    function checkMultipleTypes(it3, ts2) {
      if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
        strictTypesError(it3, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it3, ts2) {
      const rules = it3.self.RULES.all;
      for (const keyword2 in rules) {
        const rule = rules[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it3.schema, rule)) {
          const {
            type
          } = rule.definition;
          if (type.length && !type.some((t3) => hasApplicableType(ts2, t3))) {
            strictTypesError(it3, `missing type "${type.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts2, t3) {
      return ts2.includes(t3) || t3 === "integer" && ts2.includes("number");
    }
    function narrowSchemaTypes(it3, withTypes) {
      const ts2 = [];
      for (const t3 of it3.dataTypes) {
        if (includesType(withTypes, t3)) ts2.push(t3);
        else if (withTypes.includes("integer") && t3 === "number") ts2.push("integer");
      }
      it3.dataTypes = ts2;
    }
    function strictTypesError(it3, msg) {
      const schemaPath = it3.schemaEnv.baseId + it3.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it3, msg, it3.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it3, def, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it3, def, keyword2);
        this.gen = it3.gen;
        this.allErrors = it3.allErrors;
        this.keyword = keyword2;
        this.data = it3.data;
        this.schema = it3.schema[keyword2];
        this.$data = def.$data && it3.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it3, this.schema, keyword2, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it3.schema;
        this.params = {};
        this.it = it3;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it3.gen.const("vSchema", getData2(this.$data, it3));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it3.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction) failAction();
        else this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors) this.gen.endIf();
        } else {
          if (this.allErrors) this.gen.endIf();
          else this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors) this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors) this.gen.endIf();
        else this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data) return this.fail(condition);
        const {
          schemaCode
        } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0) throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond2) {
        if (!this.allErrors) this.gen.if(cond2);
      }
      setParams(obj, assign2) {
        if (assign2) Object.assign(this.params, obj);
        else this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data) return;
        const {
          gen,
          schemaCode,
          schemaType,
          def
        } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil) gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil) gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const {
          gen,
          schemaCode,
          schemaType,
          def,
          it: it3
        } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
            const st3 = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st3, schemaCode, it3.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", {
              ref: def.validateSchema
            });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), {
          items: void 0,
          props: void 0
        });
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const {
          it: it3,
          gen
        } = this;
        if (!it3.opts.unevaluated) return;
        if (it3.props !== true && schemaCxt.props !== void 0) {
          it3.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it3.props, toName);
        }
        if (it3.items !== true && schemaCxt.items !== void 0) {
          it3.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it3.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const {
          it: it3,
          gen
        } = this;
        if (it3.opts.unevaluated && (it3.props !== true || it3.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it3, keyword2, def, ruleType) {
      const cxt = new KeywordCxt(it3, def, keyword2);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData2($data, {
      dataLevel,
      dataNames,
      dataPathArr
    }) {
      let jsonPointer;
      let data;
      if ($data === "") return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches2 = RELATIVE_JSON_POINTER.exec($data);
        if (!matches2) throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up2 = +matches2[1];
        jsonPointer = matches2[2];
        if (jsonPointer === "#") {
          if (up2 >= dataLevel) throw new Error(errorMsg("property/index", up2));
          return dataPathArr[dataLevel - up2];
        }
        if (up2 > dataLevel) throw new Error(errorMsg("data", up2));
        data = dataNames[dataLevel - up2];
        if (!jsonPointer) return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up2) {
        return `Cannot access ${pointerType} ${up2} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData2;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a3;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object") schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a3 = env.baseId) !== null && _a3 !== void 0 ? _a3 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch) return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const {
        es5,
        lines
      } = this.opts.code;
      const {
        ownProperties
      } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, {
        es5,
        lines,
        ownProperties
      });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? {
          ref: sch.schema,
          code: (0, codegen_1.stringify)(sch.schema)
        } : {
          ref: sch.schema
        }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, {
          ref: validate
        });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async) validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = {
            validateName,
            validateCode,
            scopeValues: gen._values
          };
        }
        if (this.opts.unevaluated) {
          const {
            props,
            items
          } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root2, baseId, ref) {
      var _a3;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root2.refs[ref];
      if (schOrFunc) return schOrFunc;
      let _sch = resolve.call(this, root2, ref);
      if (_sch === void 0) {
        const schema = (_a3 = root2.localRefs) === null || _a3 === void 0 ? void 0 : _a3[ref];
        const {
          schemaId
        } = this.opts;
        if (schema) _sch = new SchemaEnv({
          schema,
          schemaId,
          root: root2,
          baseId
        });
      }
      if (_sch === void 0) return;
      return root2.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv)) return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root2, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string") ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root2, ref);
    }
    function resolveSchema(root2, ref) {
      const p2 = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root2.baseId, void 0);
      if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p2, root2);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root2, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object") return;
        return getJsonPointer.call(this, p2, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object") return;
      if (!schOrRef.validate) compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref)) {
        const {
          schema
        } = schOrRef;
        const {
          schemaId
        } = this.opts;
        const schId = schema[schemaId];
        if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({
          schema,
          schemaId,
          root: root2,
          baseId
        });
      }
      return getJsonPointer.call(this, p2, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, {
      baseId,
      schema,
      root: root2
    }) {
      var _a3;
      if (((_a3 = parsedRef.fragment) === null || _a3 === void 0 ? void 0 : _a3[0]) !== "/") return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean") return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0) return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root2, $ref);
      }
      const {
        schemaId
      } = this.opts;
      env = env || new SchemaEnv({
        schema,
        schemaId,
        root: root2,
        baseId
      });
      if (env.schema !== env.root.schema) return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var {
      HEX
    } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return {
          host,
          isIPV4: false
        };
      }
      const matches2 = host.match(IPV4_REG) || [];
      const [address] = matches2;
      if (address) {
        return {
          host: stripLeadingZeros(address, "."),
          isIPV4: true
        };
      } else {
        return {
          host,
          isIPV4: false
        };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = {
        error: false,
        address: "",
        zone: ""
      };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i2 = 0; i2 < input.length; i2++) {
        const cursor = input[i2];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i2 - 1 >= 0 && input[i2 - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return {
          host,
          isIPV6: false
        };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return {
          host: newHost,
          escapedHost,
          isIPV6: true
        };
      } else {
        return {
          host,
          isIPV6: false
        };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i2 = 0; i2 < l; i2++) {
        const c = str[i2];
        if (c === "0" && skip) {
          if (i2 + 1 <= l && str[i2 + 1] === token || i2 + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i2 = 0; i2 < str.length; i2++) {
        if (str[i2] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im2 = input.match(RDS5);
          if (im2) {
            const s2 = im2[0];
            input = input.slice(s2.length);
            output.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches2 = urnComponents.path.match(URN_REG);
      if (matches2) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches2[1].toLowerCase();
        urnComponents.nss = matches2[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws2 = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws2.domainHost,
      parse: ws2.parse,
      serialize: ws2.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws: ws2,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var {
      normalizeIPv6,
      normalizeIPv4,
      removeDotSegments,
      recomposeAuthority,
      normalizeComponentEncoding
    } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({
        scheme: "null"
      }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, __spreadProps(__spreadValues({}, schemelessOptions), {
        skipEscape: true
      }));
    }
    function resolveComponents(base2, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), __spreadProps(__spreadValues({}, options), {
          skipEscape: true
        }));
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), __spreadProps(__spreadValues({}, options), {
          skipEscape: true
        }));
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), __spreadProps(__spreadValues({}, options), {
          skipEscape: true
        }));
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), __spreadProps(__spreadValues({}, options), {
          skipEscape: true
        }));
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({
      length: 127
    }, (_v2, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i2 = 0, len = value.length; i2 < len; ++i2) {
        code = value.charCodeAt(i2);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches2 = uri.match(URI_PARSE);
      if (matches2) {
        parsed.scheme = matches2[1];
        parsed.userinfo = matches2[3];
        parsed.host = matches2[4];
        parsed.port = parseInt(matches2[5], 10);
        parsed.path = matches2[6] || "";
        parsed.query = matches2[7];
        parsed.fragment = matches2[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches2[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function() {
        return validate_1.KeywordCxt;
      }
    });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function() {
        return codegen_1._;
      }
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function() {
        return codegen_1.str;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return codegen_1.stringify;
      }
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function() {
        return codegen_1.nil;
      }
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function() {
        return codegen_1.Name;
      }
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function() {
        return codegen_1.CodeGen;
      }
    });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o2) {
      var _a3, _b, _c2, _d2, _e, _f2, _g2, _h2, _j, _k, _l2, _m2, _o2, _p2, _q, _r2, _s2, _t2, _u2, _v2, _w, _x, _y, _z, _0;
      const s2 = o2.strict;
      const _optz = (_a3 = o2.code) === null || _a3 === void 0 ? void 0 : _a3.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d2 = o2.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
      return {
        strictSchema: (_f2 = (_e = o2.strictSchema) !== null && _e !== void 0 ? _e : s2) !== null && _f2 !== void 0 ? _f2 : true,
        strictNumbers: (_h2 = (_g2 = o2.strictNumbers) !== null && _g2 !== void 0 ? _g2 : s2) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s2) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m2 = (_l2 = o2.strictTuples) !== null && _l2 !== void 0 ? _l2 : s2) !== null && _m2 !== void 0 ? _m2 : "log",
        strictRequired: (_p2 = (_o2 = o2.strictRequired) !== null && _o2 !== void 0 ? _o2 : s2) !== null && _p2 !== void 0 ? _p2 : false,
        code: o2.code ? __spreadProps(__spreadValues({}, o2.code), {
          optimize,
          regExp
        }) : {
          optimize,
          regExp
        },
        loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o2.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s2 = o2.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t2 = o2.messages) !== null && _t2 !== void 0 ? _t2 : true,
        inlineRefs: (_u2 = o2.inlineRefs) !== null && _u2 !== void 0 ? _u2 : true,
        schemaId: (_v2 = o2.schemaId) !== null && _v2 !== void 0 ? _v2 : "$id",
        addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
        const {
          es5,
          lines
        } = this.opts.code;
        this.scope = new codegen_2.ValueScope({
          scope: {},
          prefixes: EXT_SCOPE_NAMES,
          es5,
          lines
        });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats) addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const {
          $data,
          meta: meta2,
          schemaId
        } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = __spreadValues({}, $dataRefSchema);
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const {
          meta: meta2,
          schemaId
        } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v)) this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const {
          loadSchema
        } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        function runCompileAsync(_schema, _meta) {
          return __async(this, null, function* () {
            yield loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          });
        }
        function loadMetaSchema($ref) {
          return __async(this, null, function* () {
            if ($ref && !this.getSchema($ref)) {
              yield runCompileAsync.call(this, {
                $ref
              }, true);
            }
          });
        }
        function _compileAsync(sch) {
          return __async(this, null, function* () {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e2) {
              if (!(e2 instanceof ref_error_1.default)) throw e2;
              checkLoaded.call(this, e2);
              yield loadMissingSchema.call(this, e2.missingSchema);
              return _compileAsync.call(this, sch);
            }
          });
        }
        function checkLoaded({
          missingSchema: ref,
          missingRef
        }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        function loadMissingSchema(ref) {
          return __async(this, null, function* () {
            const _schema = yield _loadSchema.call(this, ref);
            if (!this.refs[ref]) yield loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref]) this.addSchema(_schema, ref, meta2);
          });
        }
        function _loadSchema(ref) {
          return __async(this, null, function* () {
            const p2 = this._loading[ref];
            if (p2) return p2;
            try {
              return yield this._loading[ref] = loadSchema(ref);
            } finally {
              delete this._loading[ref];
            }
          });
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema) this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const {
            schemaId
          } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean") return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(message);
          else throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string") keyRef = sch;
        if (sch === void 0) {
          const {
            schemaId
          } = this.opts;
          const root2 = new compile_1.SchemaEnv({
            schema: {},
            schemaId
          });
          sch = compile_1.resolveSchema.call(this, root2, keyRef);
          if (!sch) return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object") this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions) this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword2 = def.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def);
        if (!def) {
          (0, util_1.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = __spreadProps(__spreadValues({}, def), {
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        });
        (0, util_1.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t3) => addRule.call(this, k, definition, t3)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword2) {
        const {
          RULES
        } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i2 >= 0) group.rules.splice(i2, 1);
        }
        return this;
      }
      // Add format
      addFormat(name2, format) {
        if (typeof format == "string") format = new RegExp(format);
        this.formats[name2] = format;
        return this;
      }
      errorsText(errors = this.errors, {
        separator = ", ",
        dataVar = "data"
      } = {}) {
        if (!errors || errors.length === 0) return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments) keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object") continue;
            const {
              $data
            } = rule.definition;
            const schema = keywords[key];
            if ($data && schema) keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const {
          schemaId
        } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd) throw new Error("schema must be object");
          else if (typeof schema != "boolean") throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0) return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({
          schema,
          schemaId,
          meta: meta2,
          baseId,
          localRefs
        });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId) this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema) this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta) this._compileMetaSchema(sch);
        else compile_1.compileSchema.call(this, sch);
        if (!sch.validate) throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
      else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name2 in this.opts.formats) {
        const format = this.opts.formats[name2];
        if (format) this.addFormat(name2, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def = defs[keyword2];
        if (!def.keyword) def.keyword = keyword2;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = __spreadValues({}, this.opts);
      for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = {
      log() {
      },
      warn() {
      },
      error() {
      }
    };
    function getLogger(logger) {
      if (logger === false) return noLogs;
      if (logger === void 0) return console;
      if (logger.log && logger.warn && logger.error) return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def) {
      const {
        RULES
      } = this;
      (0, util_1.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def) return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType) {
      var _a3;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post) throw new Error('keyword with "post" flag cannot have "type"');
      const {
        RULES
      } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({
        type: t3
      }) => t3 === dataType);
      if (!ruleGroup) {
        ruleGroup = {
          type: dataType,
          rules: []
        };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition) return;
      const rule = {
        keyword: keyword2,
        definition: __spreadProps(__spreadValues({}, definition), {
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        })
      };
      if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a3 = definition.implements) === null || _a3 === void 0 ? void 0 : _a3.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before2) {
      const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before2);
      if (i2 >= 0) {
        ruleGroup.rules.splice(i2, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before2} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let {
        metaSchema
      } = def;
      if (metaSchema === void 0) return;
      if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return {
        anyOf: [schema, $dataRef]
      };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const {
          gen,
          schema: $ref,
          it: it3
        } = cxt;
        const {
          baseId,
          schemaEnv: env,
          validateName,
          opts,
          self: self2
        } = it3;
        const {
          root: root2
        } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root2.baseId) return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
        if (schOrEnv === void 0) throw new ref_error_1.default(it3.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root2) return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", {
            ref: root2
          });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root2, root2.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? {
            ref: sch,
            code: (0, codegen_1.stringify)(sch)
          } : {
            ref: sch
          });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const {
        gen
      } = cxt;
      return sch.validate ? gen.scopeValue("validate", {
        ref: sch.validate
      }) : (0, codegen_1._)`${gen.scopeValue("wrapper", {
        ref: sch
      })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const {
        gen,
        it: it3
      } = cxt;
      const {
        allErrors,
        schemaEnv: env,
        opts
      } = it3;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async) callAsyncRef();
      else callSyncRef();
      function callAsyncRef() {
        if (!env.$async) throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors) gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it3.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors) gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a3;
        if (!it3.opts.unevaluated) return;
        const schEvaluated = (_a3 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a3 === void 0 ? void 0 : _a3.evaluated;
        if (it3.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it3.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it3.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it3.props = util_1.mergeEvaluated.props(gen, props, it3.props, codegen_1.Name);
          }
        }
        if (it3.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it3.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it3.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it3.items = util_1.mergeEvaluated.items(gen, items, it3.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = ["$schema", "$id", "$defs", "$vocabulary", {
      keyword: "$comment"
    }, "definitions", id_1.default, ref_1.default];
    exports2.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: {
        okStr: "<=",
        ok: ops.LTE,
        fail: ops.GT
      },
      minimum: {
        okStr: ">=",
        ok: ops.GTE,
        fail: ops.LT
      },
      exclusiveMaximum: {
        okStr: "<",
        ok: ops.LT,
        fail: ops.GTE
      },
      exclusiveMinimum: {
        okStr: ">",
        ok: ops.GT,
        fail: ops.LTE
      }
    };
    var error = {
      message: ({
        keyword: keyword2,
        schemaCode
      }) => (0, codegen_1.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
      params: ({
        keyword: keyword2,
        schemaCode
      }) => (0, codegen_1._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const {
          keyword: keyword2,
          data,
          schemaCode
        } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var error = {
      message: ({
        schemaCode
      }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const {
          gen,
          data,
          schemaCode,
          it: it3
        } = cxt;
        const prec2 = it3.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec2 ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec2}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320) pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({
        keyword: keyword2,
        schemaCode
      }) {
        const comp = keyword2 === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const {
          keyword: keyword2,
          data,
          schemaCode,
          it: it3
        } = cxt;
        const op2 = keyword2 === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it3.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({
        schemaCode
      }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const {
          data,
          $data,
          schema,
          schemaCode,
          it: it3
        } = cxt;
        const u = it3.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var error = {
      message({
        keyword: keyword2,
        schemaCode
      }) {
        const comp = keyword2 === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const {
          keyword: keyword2,
          data,
          schemaCode
        } = cxt;
        const op2 = keyword2 === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({
        params: {
          missingProperty
        }
      }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({
        params: {
          missingProperty
        }
      }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const {
          gen,
          schema,
          schemaCode,
          data,
          $data,
          it: it3
        } = cxt;
        const {
          opts
        } = it3;
        if (!$data && schema.length === 0) return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it3.allErrors) allErrorsMode();
        else exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const {
            definedProperties
          } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it3.schemaEnv.baseId + it3.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it3, msg, it3.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({
              missingProperty: prop
            });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({
            missingProperty: missing
          });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var error = {
      message({
        keyword: keyword2,
        schemaCode
      }) {
        const comp = keyword2 === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const {
          keyword: keyword2,
          data,
          schemaCode
        } = cxt;
        const op2 = keyword2 === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({
        params: {
          i: i2,
          j
        }
      }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
      params: ({
        params: {
          i: i2,
          j
        }
      }) => (0, codegen_1._)`{i: ${i2}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const {
          gen,
          data,
          $data,
          schema,
          parentSchema,
          schemaCode,
          it: it3
        } = cxt;
        if (!$data && !schema) return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i2 = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({
            i: i2,
            j
          });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t3) => t3 === "object" || t3 === "array");
        }
        function loopN(i2, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it3.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i2}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i2}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i2}`);
          });
        }
        function loopN2(i2, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i2}--;`, () => gen.for((0, codegen_1._)`${j} = ${i2}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const {
          gen,
          data,
          $data,
          schemaCode,
          schema
        } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const {
          gen,
          data,
          $data,
          schema,
          schemaCode,
          it: it3
        } = cxt;
        if (!$data && schema.length === 0) throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it3.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema)) throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i2) => equalCode(vSchema, i2)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i2) {
          const sch = schema[i2];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i2}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      {
        keyword: "type",
        schemaType: ["string", "array"]
      },
      {
        keyword: "nullable",
        schemaType: "boolean"
      },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({
        params: {
          len
        }
      }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({
        params: {
          len
        }
      }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const {
          parentSchema,
          it: it3
        } = cxt;
        const {
          items
        } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it3, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const {
        gen,
        schema,
        data,
        keyword: keyword2,
        it: it3
      } = cxt;
      it3.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({
          len: items.length
        });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it3, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i2) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i2,
            dataPropType: util_1.Type.Num
          }, valid);
          if (!it3.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const {
          schema,
          it: it3
        } = cxt;
        if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
        it3.items = true;
        if ((0, util_1.alwaysValidSchema)(it3, schema)) return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const {
        gen,
        parentSchema,
        data,
        keyword: keyword2,
        it: it3
      } = cxt;
      checkStrictTuple(parentSchema);
      if (it3.opts.unevaluated && schArr.length && it3.items !== true) {
        it3.items = util_1.mergeEvaluated.items(gen, schArr.length, it3.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i2) => {
        if ((0, util_1.alwaysValidSchema)(it3, sch)) return;
        gen.if((0, codegen_1._)`${len} > ${i2}`, () => cxt.subschema({
          keyword: keyword2,
          schemaProp: i2,
          dataProp: i2
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const {
          opts,
          errSchemaPath
        } = it3;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it3, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({
        params: {
          len
        }
      }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({
        params: {
          len
        }
      }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const {
          schema,
          parentSchema,
          it: it3
        } = cxt;
        const {
          prefixItems
        } = parentSchema;
        it3.items = true;
        if ((0, util_1.alwaysValidSchema)(it3, schema)) return;
        if (prefixItems) (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({
        params: {
          min: min2,
          max: max2
        }
      }) => max2 === void 0 ? (0, codegen_1.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
      params: ({
        params: {
          min: min2,
          max: max2
        }
      }) => max2 === void 0 ? (0, codegen_1._)`{minContains: ${min2}}` : (0, codegen_1._)`{minContains: ${min2}, maxContains: ${max2}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const {
          gen,
          schema,
          parentSchema,
          data,
          it: it3
        } = cxt;
        let min2;
        let max2;
        const {
          minContains,
          maxContains
        } = parentSchema;
        if (it3.opts.next) {
          min2 = minContains === void 0 ? 1 : minContains;
          max2 = maxContains;
        } else {
          min2 = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({
          min: min2,
          max: max2
        });
        if (max2 === void 0 && min2 === 0) {
          (0, util_1.checkStrictMode)(it3, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max2 !== void 0 && min2 > max2) {
          (0, util_1.checkStrictMode)(it3, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it3, schema)) {
          let cond2 = (0, codegen_1._)`${len} >= ${min2}`;
          if (max2 !== void 0) cond2 = (0, codegen_1._)`${cond2} && ${len} <= ${max2}`;
          cxt.pass(cond2);
          return;
        }
        it3.items = true;
        const valid = gen.name("valid");
        if (max2 === void 0 && min2 === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min2 === 0) {
          gen.let(valid, true);
          if (max2 !== void 0) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i2) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i2,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max2 === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min2}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max2}`, () => gen.assign(valid, false).break());
            if (min2 === 1) gen.assign(valid, true);
            else gen.if((0, codegen_1._)`${count} >= ${min2}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({
        params: {
          property: property2,
          depsCount,
          deps
        }
      }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property2} is present`;
      },
      params: ({
        params: {
          property: property2,
          depsCount,
          deps,
          missingProperty
        }
      }) => (0, codegen_1._)`{property: ${property2},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({
      schema
    }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__") continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const {
        gen,
        data,
        it: it3
      } = cxt;
      if (Object.keys(propertyDeps).length === 0) return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0) continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it3.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it3.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const {
        gen,
        data,
        keyword: keyword2,
        it: it3
      } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it3, schemaDeps[prop])) continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it3.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({
              keyword: keyword2,
              schemaProp: prop
            }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({
        params
      }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const {
          gen,
          schema,
          data,
          it: it3
        } = cxt;
        if ((0, util_1.alwaysValidSchema)(it3, schema)) return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({
            propertyName: key
          });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it3.allErrors) gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({
        params
      }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const {
          gen,
          schema,
          parentSchema,
          data,
          errsCount,
          it: it3
        } = cxt;
        if (!errsCount) throw new Error("ajv implementation error");
        const {
          allErrors,
          opts
        } = it3;
        it3.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it3, schema)) return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length) additionalPropertyCode(key);
            else gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it3, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p2) => (0, codegen_1._)`${key} === ${p2}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p2) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p2)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({
              additionalProperty: key
            });
            cxt.error();
            if (!allErrors) gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it3, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const {
          gen,
          schema,
          parentSchema,
          data,
          it: it3
        } = cxt;
        if (it3.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it3, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it3.definedProperties.add(prop);
        }
        if (it3.opts.unevaluated && allProps.length && it3.props !== true) {
          it3.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it3.props);
        }
        const properties = allProps.filter((p2) => !(0, util_1.alwaysValidSchema)(it3, schema[p2]));
        if (properties.length === 0) return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it3.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it3.allErrors) gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it3.opts.useDefaults && !it3.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const {
          gen,
          schema,
          data,
          parentSchema,
          it: it3
        } = cxt;
        const {
          opts
        } = it3;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p2) => (0, util_1.alwaysValidSchema)(it3, schema[p2]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it3.opts.unevaluated || it3.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it3.props !== true && !(it3.props instanceof codegen_1.Name)) {
          it3.props = (0, util_2.evaluatedPropsToName)(gen, it3.props);
        }
        const {
          props
        } = it3;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties) checkMatchingProperties(pat);
            if (it3.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it3, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it3.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it3.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const {
          gen,
          schema,
          it: it3
        } = cxt;
        if ((0, util_1.alwaysValidSchema)(it3, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: {
        message: "must NOT be valid"
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: {
        message: "must match a schema in anyOf"
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({
        params
      }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const {
          gen,
          schema,
          parentSchema,
          it: it3
        } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        if (it3.opts.discriminator && parentSchema.discriminator) return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({
          passing
        });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i2) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it3, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i2,
                compositeRule: true
              }, schValid);
            }
            if (i2 > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i2}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i2);
              if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const {
          gen,
          schema,
          it: it3
        } = cxt;
        if (!Array.isArray(schema)) throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i2) => {
          if ((0, util_1.alwaysValidSchema)(it3, sch)) return;
          const schCxt = cxt.subschema({
            keyword: "allOf",
            schemaProp: i2
          }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({
        params
      }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({
        params
      }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const {
          gen,
          parentSchema,
          it: it3
        } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it3, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it3, "then");
        const hasElse = hasSchema(it3, "else");
        if (!hasThen && !hasElse) return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({
            ifClause
          });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword2, ifClause) {
          return () => {
            const schCxt = cxt.subschema({
              keyword: keyword2
            }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword2}`);
            else cxt.setParams({
              ifClause: keyword2
            });
          };
        }
      }
    };
    function hasSchema(it3, keyword2) {
      const schema = it3.schema[keyword2];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it3, schema);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({
        keyword: keyword2,
        parentSchema,
        it: it3
      }) {
        if (parentSchema.if === void 0) (0, util_1.checkStrictMode)(it3, `"${keyword2}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
      else applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var error = {
      message: ({
        schemaCode
      }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({
        schemaCode
      }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const {
          gen,
          data,
          $data,
          schema,
          schemaCode,
          it: it3
        } = cxt;
        const {
          opts,
          errSchemaPath,
          schemaEnv,
          self: self2
        } = it3;
        if (!opts.validateFormats) return;
        if ($data) validate$DataFormat();
        else validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false) return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true) return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType) cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", {
              key: schema,
              ref: fmtDef,
              code
            });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async) throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
    exports2.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [core_1.default, validation_1.default, (0, applicator_1.default)(), format_1.default, metadata_1.metadataVocabulary, metadata_1.contentVocabulary];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({
        params: {
          discrError,
          tagName
        }
      }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({
        params: {
          discrError,
          tag,
          tagName
        }
      }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const {
          gen,
          data,
          schema,
          parentSchema,
          it: it3
        } = cxt;
        const {
          oneOf
        } = parentSchema;
        if (!it3.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string") throw new Error("discriminator: requires propertyName");
        if (schema.mapping) throw new Error("discriminator: mapping is not supported");
        if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, {
          discrError: types_1.DiscrError.Tag,
          tag,
          tagName
        }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, {
            discrError: types_1.DiscrError.Mapping,
            tag,
            tagName
          });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp
          }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a3;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i2 = 0; i2 < oneOf.length; i2++) {
            let sch = oneOf[i2];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it3.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it3.self, it3.schemaEnv.root, it3.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
              if (sch === void 0) throw new ref_error_1.default(it3.opts.uriResolver, it3.baseId, ref);
            }
            const propSch = (_a3 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a3 === void 0 ? void 0 : _a3[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i2);
          }
          if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({
            required
          }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i2) {
            if (sch.const) {
              addMapping(sch.const, i2);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i2);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i2) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i2;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta) return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", {
      enumerable: true,
      get: function() {
        return validate_1.KeywordCxt;
      }
    });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", {
      enumerable: true,
      get: function() {
        return codegen_1._;
      }
    });
    Object.defineProperty(exports2, "str", {
      enumerable: true,
      get: function() {
        return codegen_1.str;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return codegen_1.stringify;
      }
    });
    Object.defineProperty(exports2, "nil", {
      enumerable: true,
      get: function() {
        return codegen_1.nil;
      }
    });
    Object.defineProperty(exports2, "Name", {
      enumerable: true,
      get: function() {
        return codegen_1.Name;
      }
    });
    Object.defineProperty(exports2, "CodeGen", {
      enumerable: true,
      get: function() {
        return codegen_1.CodeGen;
      }
    });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function() {
        return validation_error_1.default;
      }
    });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", {
      enumerable: true,
      get: function() {
        return ref_error_1.default;
      }
    });
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports2) {
    (function(exports3) {
      "use strict";
      function isArray2(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      function isObject2(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray2(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i2 = 0; i2 < first.length; i2++) {
            if (strictDeepEqual(first[i2], second[i2]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject2(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray2(obj) && obj.length === 0) {
          return true;
        } else if (isObject2(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys3 = Object.keys(obj);
        var values2 = [];
        for (var i2 = 0; i2 < keys3.length; i2++) {
          values2.push(obj[keys3[i2]]);
        }
        return values2;
      }
      function merge2(a2, b) {
        var merged = {};
        for (var key in a2) {
          merged[key] = a2[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: "number",
        1: "any",
        2: "string",
        3: "array",
        4: "object",
        5: "boolean",
        6: "expression",
        7: "null",
        8: "Array<number>",
        9: "Array<string>"
      };
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch2) {
        return ch2 >= "a" && ch2 <= "z" || ch2 >= "A" && ch2 <= "Z" || ch2 === "_";
      }
      function isNum(ch2) {
        return ch2 >= "0" && ch2 <= "9" || ch2 === "-";
      }
      function isAlphaNum(ch2) {
        return ch2 >= "a" && ch2 <= "z" || ch2 >= "A" && ch2 <= "Z" || ch2 >= "0" && ch2 <= "9" || ch2 === "_";
      }
      function Lexer() {
      }
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal2 = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal2,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({
                  type: TOK_AND,
                  value: "&&",
                  start
                });
              } else {
                tokens.push({
                  type: TOK_EXPREF,
                  value: "&",
                  start
                });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({
                  type: TOK_OR,
                  value: "||",
                  start
                });
              } else {
                tokens.push({
                  type: TOK_PIPE,
                  value: "|",
                  start
                });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal2 = stream.slice(start + 1, this._current - 1);
          return literal2.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {
            type: TOK_NUMBER,
            value,
            start
          };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return {
              type: TOK_FILTER,
              value: "[?",
              start
            };
          } else if (stream[this._current] === "]") {
            this._current++;
            return {
              type: TOK_FLATTEN,
              value: "[]",
              start
            };
          } else {
            return {
              type: TOK_LBRACKET,
              value: "[",
              start
            };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_NE,
                value: "!=",
                start
              };
            } else {
              return {
                type: TOK_NOT,
                value: "!",
                start
              };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_LTE,
                value: "<=",
                start
              };
            } else {
              return {
                type: TOK_LT,
                value: "<",
                start
              };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_GTE,
                value: ">=",
                start
              };
            } else {
              return {
                type: TOK_GT,
                value: ">",
                start
              };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return {
                type: TOK_EQ,
                value: "==",
                start
              };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal2;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal2 = JSON.parse(literalString);
          } else {
            literal2 = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal2;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser2() {
      }
      Parser2.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t3 = this._lookaheadToken(0);
            var error = new Error("Unexpected token type: " + t3.type + ", value: " + t3.value);
            error.name = "ParserError";
            throw error;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({
            type: TOK_EOF,
            value: "",
            start: expression.length
          });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number2) {
          return this.tokens[this.index + number2].type;
        },
        _lookaheadToken: function(number2) {
          return this.tokens[this.index + number2];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return {
                type: "Literal",
                value: token.value
              };
            case TOK_UNQUOTEDIDENTIFIER:
              return {
                type: "Field",
                name: token.value
              };
            case TOK_QUOTEDIDENTIFIER:
              var node = {
                type: "Field",
                name: token.value
              };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return {
                type: "NotExpression",
                children: [right]
              };
            case TOK_STAR:
              left = {
                type: "Identity"
              };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = {
                  type: "Identity"
                };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return {
                type: "ValueProjection",
                children: [left, right]
              };
            case TOK_FILTER:
              return this.led(token.type, {
                type: "Identity"
              });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = {
                type: TOK_FLATTEN,
                children: [{
                  type: "Identity"
                }]
              };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return {
                type: "Projection",
                children: [left, right]
              };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({
                  type: "Identity"
                }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{
                    type: "Identity"
                  }, right]
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return {
                type: TOK_CURRENT
              };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return {
                type: "ExpressionReference",
                children: [expression]
              };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = {
                    type: TOK_CURRENT
                  };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {
                  type: "Subexpression",
                  children: [left, right]
                };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return {
                type: "ValueProjection",
                children: [left, right]
              };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return {
                type: TOK_PIPE,
                children: [left, right]
              };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return {
                type: "OrExpression",
                children: [left, right]
              };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return {
                type: "AndExpression",
                children: [left, right]
              };
            case TOK_LPAREN:
              var name2 = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = {
                    type: TOK_CURRENT
                  };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = {
                type: "Function",
                name: name2,
                children: args
              };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = {
                  type: "Identity"
                };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return {
                type: "FilterProjection",
                children: [left, right, condition]
              };
            case TOK_FLATTEN:
              var leftNode = {
                type: TOK_FLATTEN,
                children: [left]
              };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return {
                type: "Projection",
                children: [leftNode, rightNode]
              };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return {
                type: "Projection",
                children: [left, right]
              };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t3 = this._lookaheadToken(0);
            var error = new Error("Expected " + tokenType + ", got: " + t3.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function(token) {
          var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = {
            type: "IndexExpression",
            children: [left, right]
          };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index2 = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index2 < 3) {
            if (currentToken === TOK_COLON) {
              index2++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index2] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t3 = this._lookahead(0);
              var error = new Error("Syntax error, unexpected token: " + t3.value + "(" + t3.type + ")");
              error.name = "Parsererror";
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return {
            type: "Comparator",
            name: comparator,
            children: [left, right]
          };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = {
              type: "Identity"
            };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t3 = this._lookaheadToken(0);
            var error = new Error("Sytanx error, unexpected token: " + t3.value + "(" + t3.type + ")");
            error.name = "ParserError";
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return {
            type: "MultiSelectList",
            children: expressions
          };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName2, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName2 = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = {
              type: "KeyValuePair",
              name: keyName2,
              value
            };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return {
            type: "MultiSelectHash",
            children: pairs
          };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result2, first, second, field, left, right, collected, i2;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject2(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case "Subexpression":
              result2 = this.visit(node.children[0], value);
              for (i2 = 1; i2 < node.children.length; i2++) {
                result2 = this.visit(node.children[1], result2);
                if (result2 === null) {
                  return null;
                }
              }
              return result2;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray2(value)) {
                return null;
              }
              var index2 = node.value;
              if (index2 < 0) {
                index2 = value.length + index2;
              }
              result2 = value[index2];
              if (result2 === void 0) {
                result2 = null;
              }
              return result2;
            case "Slice":
              if (!isArray2(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result2 = [];
              if (step > 0) {
                for (i2 = start; i2 < stop; i2 += step) {
                  result2.push(value[i2]);
                }
              } else {
                for (i2 = start; i2 > stop; i2 += step) {
                  result2.push(value[i2]);
                }
              }
              return result2;
            case "Projection":
              var base2 = this.visit(node.children[0], value);
              if (!isArray2(base2)) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < base2.length; i2++) {
                current = this.visit(node.children[1], base2[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base2 = this.visit(node.children[0], value);
              if (!isObject2(base2)) {
                return null;
              }
              collected = [];
              var values2 = objValues(base2);
              for (i2 = 0; i2 < values2.length; i2++) {
                current = this.visit(node.children[1], values2[i2]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base2 = this.visit(node.children[0], value);
              if (!isArray2(base2)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i2 = 0; i2 < base2.length; i2++) {
                matched = this.visit(node.children[2], base2[i2]);
                if (!isFalse(matched)) {
                  filtered.push(base2[i2]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result2 = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result2 = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result2 = first > second;
                  break;
                case TOK_GTE:
                  result2 = first >= second;
                  break;
                case TOK_LT:
                  result2 = first < second;
                  break;
                case TOK_LTE:
                  result2 = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result2;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray2(original)) {
                return null;
              }
              var merged = [];
              for (i2 = 0; i2 < original.length; i2++) {
                current = original[i2];
                if (isArray2(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                collected.push(this.visit(node.children[i2], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i2 = 0; i2 < node.children.length; i2++) {
                child = node.children[i2];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i2 = 0; i2 < node.children.length; i2++) {
                resolvedArgs.push(this.visit(node.children[i2], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          // name: [function, <signature>]
          // The <signature> can be:
          //
          // {
          //   args: [[type1, type2], [type1, type2]],
          //   variadic: true|false
          // }
          //
          // Each arg in the arg list is a list of valid types
          // (if the function is overloaded and supports multiple
          // types.  If the type is "any" then no type checking
          // occurs on the argument.  Variadic is optional
          // and if not provided is assumed to be false.
          abs: {
            _func: this._functionAbs,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          avg: {
            _func: this._functionAvg,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER]
            }]
          },
          ceil: {
            _func: this._functionCeil,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          contains: {
            _func: this._functionContains,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY]
            }, {
              types: [TYPE_ANY]
            }]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_STRING]
            }]
          },
          floor: {
            _func: this._functionFloor,
            _signature: [{
              types: [TYPE_NUMBER]
            }]
          },
          length: {
            _func: this._functionLength,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]
            }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{
              types: [TYPE_EXPREF]
            }, {
              types: [TYPE_ARRAY]
            }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]
            }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{
              types: [TYPE_OBJECT],
              variadic: true
            }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          sum: {
            _func: this._functionSum,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER]
            }]
          },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_STRING]
            }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{
              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]
            }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          type: {
            _func: this._functionType,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          keys: {
            _func: this._functionKeys,
            _signature: [{
              types: [TYPE_OBJECT]
            }]
          },
          values: {
            _func: this._functionValues,
            _signature: [{
              types: [TYPE_OBJECT]
            }]
          },
          sort: {
            _func: this._functionSort,
            _signature: [{
              types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]
            }]
          },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{
              types: [TYPE_ARRAY]
            }, {
              types: [TYPE_EXPREF]
            }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [{
              types: [TYPE_STRING]
            }, {
              types: [TYPE_ARRAY_STRING]
            }]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{
              types: [TYPE_STRING, TYPE_ARRAY]
            }]
          },
          "to_array": {
            _func: this._functionToArray,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "to_string": {
            _func: this._functionToString,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "to_number": {
            _func: this._functionToNumber,
            _signature: [{
              types: [TYPE_ANY]
            }]
          },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{
              types: [TYPE_ANY],
              variadic: true
            }]
          }
        };
      }
      Runtime.prototype = {
        callFunction: function(name2, resolvedArgs) {
          var functionEntry = this.functionTable[name2];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name2 + "()");
          }
          this._validateArgs(name2, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name2, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name2 + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name2 + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i2 = 0; i2 < signature.length; i2++) {
            typeMatched = false;
            currentSpec = signature[i2].types;
            actualType = this._getTypeName(args[i2]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i2])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec.map(function(typeIdentifier) {
                return TYPE_NAME_TABLE[typeIdentifier];
              }).join(",");
              throw new Error("TypeError: " + name2 + "() expected argument " + (i2 + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i2 = 0; i2 < argValue.length; i2++) {
                if (!this._typeMatches(this._getTypeName(argValue[i2]), subtype, argValue[i2])) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName2 = this._getTypeName(resolvedArgs[0]);
          if (typeName2 === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i2 = originalStr.length - 1; i2 >= 0; i2--) {
              reversedStr += originalStr[i2];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum2 = 0;
          var inputArray = resolvedArgs[0];
          for (var i2 = 0; i2 < inputArray.length; i2++) {
            sum2 += inputArray[i2];
          }
          return sum2 / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject2(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i2 = 0; i2 < elements.length; i2++) {
            mapped.push(interpreter.visit(exprefNode, elements[i2]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            var current = resolvedArgs[i2];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName2 = this._getTypeName(resolvedArgs[0][0]);
            if (typeName2 === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (maxElement.localeCompare(elements[i2]) < 0) {
                  maxElement = elements[i2];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName2 = this._getTypeName(resolvedArgs[0][0]);
            if (typeName2 === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i2 = 1; i2 < elements.length; i2++) {
                if (elements[i2].localeCompare(minElement) < 0) {
                  minElement = elements[i2];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum2 = 0;
          var listToSum = resolvedArgs[0];
          for (var i2 = 0; i2 < listToSum.length; i2++) {
            sum2 += listToSum[i2];
          }
          return sum2;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys3 = Object.keys(obj);
          var values2 = [];
          for (var i2 = 0; i2 < keys3.length; i2++) {
            values2.push(obj[keys3[i2]]);
          }
          return values2;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName2 = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName2 === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName2 === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i2 = 0; i2 < resolvedArgs.length; i2++) {
            if (this._getTypeName(resolvedArgs[i2]) !== TYPE_NULL) {
              return resolvedArgs[i2];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i2 = 0; i2 < sortedArray.length; i2++) {
            decorated.push([i2, sortedArray[i2]]);
          }
          decorated.sort(function(a2, b) {
            var exprA = interpreter.visit(exprefNode, a2[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA));
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error("TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB));
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a2[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i2];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i2 = 0; i2 < resolvedArray.length; i2++) {
            current = keyFunction(resolvedArray[i2]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i2];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function(x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser2 = new Parser2();
        var ast = parser2.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search2(data, expression) {
        var parser2 = new Parser2();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser2.parse(expression);
        return interpreter.search(node, data);
      }
      exports3.tokenize = tokenize;
      exports3.compile = compile;
      exports3.search = search2;
      exports3.strictDeepEqual = strictDeepEqual;
    })(typeof exports2 === "undefined" ? exports2.jmespath = {} : exports2);
  }
});

// node_modules/immutable-json-patch/lib/esm/typeguards.js
function isJSONArray(value) {
  return Array.isArray(value);
}
function isJSONObject(value) {
  return value !== null && typeof value === "object" && (value.constructor === void 0 || // for example Object.create(null)
  value.constructor.name === "Object");
}
function isJSONPatchAdd(value) {
  return value && typeof value === "object" ? value.op === "add" : false;
}
function isJSONPatchRemove(value) {
  return value && typeof value === "object" ? value.op === "remove" : false;
}
function isJSONPatchReplace(value) {
  return value && typeof value === "object" ? value.op === "replace" : false;
}
function isJSONPatchCopy(value) {
  return value && typeof value === "object" ? value.op === "copy" : false;
}
function isJSONPatchMove(value) {
  return value && typeof value === "object" ? value.op === "move" : false;
}

// node_modules/immutable-json-patch/lib/esm/utils.js
function isEqual(a2, b) {
  return JSON.stringify(a2) === JSON.stringify(b);
}
function strictEqual(a2, b) {
  return a2 === b;
}
function initial(array) {
  return array.slice(0, array.length - 1);
}
function last(array) {
  return array[array.length - 1];
}
function startsWith(array1, array2) {
  let isEqual4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : strictEqual;
  if (array1.length < array2.length) {
    return false;
  }
  for (let i2 = 0; i2 < array2.length; i2++) {
    if (!isEqual4(array1[i2], array2[i2])) {
      return false;
    }
  }
  return true;
}
function isObjectOrArray(value) {
  return typeof value === "object" && value !== null;
}

// node_modules/immutable-json-patch/lib/esm/immutabilityHelpers.js
function shallowClone(value) {
  if (isJSONArray(value)) {
    const copy2 = value.slice();
    Object.getOwnPropertySymbols(value).forEach((symbol) => {
      copy2[symbol] = value[symbol];
    });
    return copy2;
  }
  if (isJSONObject(value)) {
    const copy2 = __spreadValues({}, value);
    Object.getOwnPropertySymbols(value).forEach((symbol) => {
      copy2[symbol] = value[symbol];
    });
    return copy2;
  }
  return value;
}
function applyProp(object, key, value) {
  if (object[key] === value) {
    return object;
  }
  const updatedObject = shallowClone(object);
  updatedObject[key] = value;
  return updatedObject;
}
function getIn(object, path) {
  let value = object;
  let i2 = 0;
  while (i2 < path.length) {
    if (isJSONObject(value)) {
      value = value[path[i2]];
    } else if (isJSONArray(value)) {
      value = value[Number.parseInt(path[i2])];
    } else {
      value = void 0;
    }
    i2++;
  }
  return value;
}
function setIn(object, path, value) {
  let createPath = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (path.length === 0) {
    return value;
  }
  const key = path[0];
  const updatedValue = setIn(object ? object[key] : void 0, path.slice(1), value, createPath);
  if (isJSONObject(object) || isJSONArray(object)) {
    return applyProp(object, key, updatedValue);
  }
  if (createPath) {
    const newObject = IS_INTEGER_REGEX.test(key) ? [] : {};
    newObject[key] = updatedValue;
    return newObject;
  }
  throw new Error("Path does not exist");
}
var IS_INTEGER_REGEX = /^\d+$/;
function updateIn(object, path, transform3) {
  if (path.length === 0) {
    return transform3(object);
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path doesn't exist");
  }
  const key = path[0];
  const updatedValue = updateIn(object[key], path.slice(1), transform3);
  return applyProp(object, key, updatedValue);
}
function deleteIn(object, path) {
  if (path.length === 0) {
    return object;
  }
  if (!isObjectOrArray(object)) {
    throw new Error("Path does not exist");
  }
  if (path.length === 1) {
    const key2 = path[0];
    if (!(key2 in object)) {
      return object;
    }
    const updatedObject = shallowClone(object);
    if (isJSONArray(updatedObject)) {
      updatedObject.splice(Number.parseInt(key2), 1);
    }
    if (isJSONObject(updatedObject)) {
      delete updatedObject[key2];
    }
    return updatedObject;
  }
  const key = path[0];
  const updatedValue = deleteIn(object[key], path.slice(1));
  return applyProp(object, key, updatedValue);
}
function insertAt(document2, path, value) {
  const parentPath = path.slice(0, path.length - 1);
  const index2 = path[path.length - 1];
  return updateIn(document2, parentPath, (items) => {
    if (!Array.isArray(items)) {
      throw new TypeError(`Array expected at path ${JSON.stringify(parentPath)}`);
    }
    const updatedItems = shallowClone(items);
    updatedItems.splice(Number.parseInt(index2), 0, value);
    return updatedItems;
  });
}
function existsIn(document2, path) {
  if (document2 === void 0) {
    return false;
  }
  if (path.length === 0) {
    return true;
  }
  if (document2 === null) {
    return false;
  }
  return existsIn(document2[path[0]], path.slice(1));
}

// node_modules/immutable-json-patch/lib/esm/jsonPointer.js
function parseJSONPointer(pointer) {
  const path = pointer.split("/");
  path.shift();
  return path.map((p2) => p2.replace(/~1/g, "/").replace(/~0/g, "~"));
}
function compileJSONPointer(path) {
  return path.map(compileJSONPointerProp).join("");
}
function compileJSONPointerProp(pathProp) {
  return `/${String(pathProp).replace(/~/g, "~0").replace(/\//g, "~1")}`;
}
function appendToJSONPointer(pointer, pathProp) {
  return pointer + compileJSONPointerProp(pathProp);
}

// node_modules/immutable-json-patch/lib/esm/immutableJSONPatch.js
function immutableJSONPatch(document2, operations, options) {
  let updatedDocument = document2;
  for (let i2 = 0; i2 < operations.length; i2++) {
    validateJSONPatchOperation(operations[i2]);
    let operation = operations[i2];
    if (options?.before) {
      const result2 = options.before(updatedDocument, operation);
      if (result2 !== void 0) {
        if (result2.document !== void 0) {
          updatedDocument = result2.document;
        }
        if (result2.json !== void 0) {
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
        if (result2.operation !== void 0) {
          operation = result2.operation;
        }
      }
    }
    const previousDocument = updatedDocument;
    const path = parsePath(updatedDocument, operation.path);
    if (operation.op === "add") {
      updatedDocument = add(updatedDocument, path, operation.value);
    } else if (operation.op === "remove") {
      updatedDocument = remove(updatedDocument, path);
    } else if (operation.op === "replace") {
      updatedDocument = replace(updatedDocument, path, operation.value);
    } else if (operation.op === "copy") {
      updatedDocument = copy(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "move") {
      updatedDocument = move(updatedDocument, path, parseFrom(operation.from));
    } else if (operation.op === "test") {
      test(updatedDocument, path, operation.value);
    } else {
      throw new Error(`Unknown JSONPatch operation ${JSON.stringify(operation)}`);
    }
    if (options?.after) {
      const result2 = options.after(updatedDocument, operation, previousDocument);
      if (result2 !== void 0) {
        updatedDocument = result2;
      }
    }
  }
  return updatedDocument;
}
function replace(document2, path, value) {
  return existsIn(document2, path) ? setIn(document2, path, value) : document2;
}
function remove(document2, path) {
  return deleteIn(document2, path);
}
function add(document2, path, value) {
  if (isArrayItem(document2, path)) {
    return insertAt(document2, path, value);
  }
  return setIn(document2, path, value);
}
function copy(document2, path, from) {
  const value = getIn(document2, from);
  if (isArrayItem(document2, path)) {
    return insertAt(document2, path, value);
  }
  return setIn(document2, path, value);
}
function move(document2, path, from) {
  const value = getIn(document2, from);
  const removedJson = deleteIn(document2, from);
  return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
}
function test(document2, path, value) {
  if (value === void 0) {
    throw new Error(`Test failed: no value provided (path: "${compileJSONPointer(path)}")`);
  }
  if (!existsIn(document2, path)) {
    throw new Error(`Test failed: path not found (path: "${compileJSONPointer(path)}")`);
  }
  const actualValue = getIn(document2, path);
  if (!isEqual(actualValue, value)) {
    throw new Error(`Test failed, value differs (path: "${compileJSONPointer(path)}")`);
  }
}
function isArrayItem(document2, path) {
  if (path.length === 0) {
    return false;
  }
  const parent2 = getIn(document2, initial(path));
  return Array.isArray(parent2);
}
function resolvePathIndex(document2, path) {
  if (last(path) !== "-") {
    return path;
  }
  const parentPath = initial(path);
  const parent2 = getIn(document2, parentPath);
  return parentPath.concat(parent2.length);
}
function validateJSONPatchOperation(operation) {
  const ops = ["add", "remove", "replace", "copy", "move", "test"];
  if (!ops.includes(operation.op)) {
    throw new Error(`Unknown JSONPatch op ${JSON.stringify(operation.op)}`);
  }
  if (typeof operation.path !== "string") {
    throw new Error(`Required property "path" missing or not a string in operation ${JSON.stringify(operation)}`);
  }
  if (operation.op === "copy" || operation.op === "move") {
    if (typeof operation.from !== "string") {
      throw new Error(`Required property "from" missing or not a string in operation ${JSON.stringify(operation)}`);
    }
  }
}
function parsePath(document2, pointer) {
  return resolvePathIndex(document2, parseJSONPointer(pointer));
}
function parseFrom(fromPointer) {
  return parseJSONPointer(fromPointer);
}

// node_modules/immutable-json-patch/lib/esm/revertJSONPatch.js
function revertJSONPatch(document2, operations, options) {
  let allRevertOperations = [];
  const before2 = (document3, operation) => {
    let revertOperations;
    const path = parsePath(document3, operation.path);
    if (operation.op === "add") {
      revertOperations = revertAdd(document3, path);
    } else if (operation.op === "remove") {
      revertOperations = revertRemove(document3, path);
    } else if (operation.op === "replace") {
      revertOperations = revertReplace(document3, path);
    } else if (operation.op === "copy") {
      revertOperations = revertCopy(document3, path);
    } else if (operation.op === "move") {
      revertOperations = revertMove(document3, path, parseFrom(operation.from));
    } else if (operation.op === "test") {
      revertOperations = [];
    } else {
      throw new Error(`Unknown JSONPatch operation ${JSON.stringify(operation)}`);
    }
    let updatedJson;
    if (options?.before) {
      const res = options.before(document3, operation, revertOperations);
      if (res?.revertOperations) {
        revertOperations = res.revertOperations;
      }
      if (res?.document) {
        updatedJson = res.document;
      }
      if (res?.json) {
        throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
      }
    }
    allRevertOperations = revertOperations.concat(allRevertOperations);
    if (updatedJson !== void 0) {
      return {
        document: updatedJson
      };
    }
  };
  immutableJSONPatch(document2, operations, {
    before: before2
  });
  return allRevertOperations;
}
function revertReplace(document2, path) {
  return existsIn(document2, path) ? [{
    op: "replace",
    path: compileJSONPointer(path),
    value: getIn(document2, path)
  }] : [];
}
function revertRemove(document2, path) {
  return [{
    op: "add",
    path: compileJSONPointer(path),
    value: getIn(document2, path)
  }];
}
function revertAdd(document2, path) {
  if (isArrayItem(document2, path) || !existsIn(document2, path)) {
    return [{
      op: "remove",
      path: compileJSONPointer(path)
    }];
  }
  return revertReplace(document2, path);
}
function revertCopy(document2, path) {
  return revertAdd(document2, path);
}
function revertMove(document2, path, from) {
  if (path.length < from.length && startsWith(from, path)) {
    return [{
      op: "replace",
      path: compileJSONPointer(path),
      value: document2
    }];
  }
  const move2 = {
    op: "move",
    from: compileJSONPointer(path),
    path: compileJSONPointer(from)
  };
  if (!isArrayItem(document2, path) && existsIn(document2, path)) {
    return [move2, ...revertRemove(document2, path)];
  }
  return [move2];
}

// node_modules/vanilla-jsoneditor/index.js
var import_json_source_map = __toESM(require_json_source_map());

// node_modules/jsonrepair/lib/esm/utils/JSONRepairError.js
var JSONRepairError = class extends Error {
  constructor(message, position) {
    super(`${message} at position ${position}`);
    this.position = position;
  }
};

// node_modules/jsonrepair/lib/esm/utils/stringUtils.js
var codeSpace = 32;
var codeNewline = 10;
var codeTab = 9;
var codeReturn = 13;
var codeNonBreakingSpace = 160;
var codeEnQuad = 8192;
var codeHairSpace = 8202;
var codeNarrowNoBreakSpace = 8239;
var codeMediumMathematicalSpace = 8287;
var codeIdeographicSpace = 12288;
function isHex(char) {
  return /^[0-9A-Fa-f]$/.test(char);
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function isValidStringCharacter(char) {
  return char >= " ";
}
function isDelimiter(char) {
  return ",:[]/{}()\n+".includes(char);
}
function isFunctionNameCharStart(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
}
function isFunctionNameChar(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$" || char >= "0" && char <= "9";
}
var regexUrlStart = /^(http|https|ftp|mailto|file|data|irc):\/\/$/;
var regexUrlChar = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;
function isUnquotedStringDelimiter(char) {
  return ",[]/{}\n+".includes(char);
}
function isStartOfValue(char) {
  return isQuote(char) || regexStartOfValue.test(char);
}
var regexStartOfValue = /^[[{\w-]$/;
function isControlCharacter(char) {
  return char === "\n" || char === "\r" || char === "	" || char === "\b" || char === "\f";
}
function isWhitespace(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;
}
function isWhitespaceExceptNewline(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeSpace || code === codeTab || code === codeReturn;
}
function isSpecialWhitespace(text, index2) {
  const code = text.charCodeAt(index2);
  return code === codeNonBreakingSpace || code >= codeEnQuad && code <= codeHairSpace || code === codeNarrowNoBreakSpace || code === codeMediumMathematicalSpace || code === codeIdeographicSpace;
}
function isQuote(char) {
  return isDoubleQuoteLike(char) || isSingleQuoteLike(char);
}
function isDoubleQuoteLike(char) {
  return char === '"' || char === "" || char === "";
}
function isDoubleQuote(char) {
  return char === '"';
}
function isSingleQuoteLike(char) {
  return char === "'" || char === "" || char === "" || char === "`" || char === "";
}
function isSingleQuote(char) {
  return char === "'";
}
function stripLastOccurrence(text, textToStrip) {
  let stripRemainingText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const index2 = text.lastIndexOf(textToStrip);
  return index2 !== -1 ? text.substring(0, index2) + (stripRemainingText ? "" : text.substring(index2 + 1)) : text;
}
function insertBeforeLastWhitespace(text, textToInsert) {
  let index2 = text.length;
  if (!isWhitespace(text, index2 - 1)) {
    return text + textToInsert;
  }
  while (isWhitespace(text, index2 - 1)) {
    index2--;
  }
  return text.substring(0, index2) + textToInsert + text.substring(index2);
}
function removeAtIndex(text, start, count) {
  return text.substring(0, start) + text.substring(start + count);
}
function endsWithCommaOrNewline(text) {
  return /[,\n][ \t\r]*$/.test(text);
}

// node_modules/jsonrepair/lib/esm/regular/jsonrepair.js
var controlCharacters = {
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var escapeCharacters = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
  // note that \u is handled separately in parseString()
};
function jsonrepair(text) {
  let i2 = 0;
  let output = "";
  parseMarkdownCodeBlock(["```", "[```", "{```"]);
  const processed = parseValue();
  if (!processed) {
    throwUnexpectedEnd();
  }
  parseMarkdownCodeBlock(["```", "```]", "```}"]);
  const processedComma = parseCharacter(",");
  if (processedComma) {
    parseWhitespaceAndSkipComments();
  }
  if (isStartOfValue(text[i2]) && endsWithCommaOrNewline(output)) {
    if (!processedComma) {
      output = insertBeforeLastWhitespace(output, ",");
    }
    parseNewlineDelimitedJSON();
  } else if (processedComma) {
    output = stripLastOccurrence(output, ",");
  }
  while (text[i2] === "}" || text[i2] === "]") {
    i2++;
    parseWhitespaceAndSkipComments();
  }
  if (i2 >= text.length) {
    return output;
  }
  throwUnexpectedCharacter();
  function parseValue() {
    parseWhitespaceAndSkipComments();
    const processed2 = parseObject() || parseArray() || parseString() || parseNumber() || parseKeywords() || parseUnquotedString(false) || parseRegex();
    parseWhitespaceAndSkipComments();
    return processed2;
  }
  function parseWhitespaceAndSkipComments() {
    let skipNewline = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    const start = i2;
    let changed = parseWhitespace(skipNewline);
    do {
      changed = parseComment();
      if (changed) {
        changed = parseWhitespace(skipNewline);
      }
    } while (changed);
    return i2 > start;
  }
  function parseWhitespace(skipNewline) {
    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline;
    let whitespace = "";
    while (true) {
      if (_isWhiteSpace(text, i2)) {
        whitespace += text[i2];
        i2++;
      } else if (isSpecialWhitespace(text, i2)) {
        whitespace += " ";
        i2++;
      } else {
        break;
      }
    }
    if (whitespace.length > 0) {
      output += whitespace;
      return true;
    }
    return false;
  }
  function parseComment() {
    if (text[i2] === "/" && text[i2 + 1] === "*") {
      while (i2 < text.length && !atEndOfBlockComment(text, i2)) {
        i2++;
      }
      i2 += 2;
      return true;
    }
    if (text[i2] === "/" && text[i2 + 1] === "/") {
      while (i2 < text.length && text[i2] !== "\n") {
        i2++;
      }
      return true;
    }
    return false;
  }
  function parseMarkdownCodeBlock(blocks) {
    if (skipMarkdownCodeBlock(blocks)) {
      if (isFunctionNameCharStart(text[i2])) {
        while (i2 < text.length && isFunctionNameChar(text[i2])) {
          i2++;
        }
      }
      parseWhitespaceAndSkipComments();
      return true;
    }
    return false;
  }
  function skipMarkdownCodeBlock(blocks) {
    for (const block of blocks) {
      const end = i2 + block.length;
      if (text.slice(i2, end) === block) {
        i2 = end;
        return true;
      }
    }
    return false;
  }
  function parseCharacter(char) {
    if (text[i2] === char) {
      output += text[i2];
      i2++;
      return true;
    }
    return false;
  }
  function skipCharacter(char) {
    if (text[i2] === char) {
      i2++;
      return true;
    }
    return false;
  }
  function skipEscapeCharacter() {
    return skipCharacter("\\");
  }
  function skipEllipsis() {
    parseWhitespaceAndSkipComments();
    if (text[i2] === "." && text[i2 + 1] === "." && text[i2 + 2] === ".") {
      i2 += 3;
      parseWhitespaceAndSkipComments();
      skipCharacter(",");
      return true;
    }
    return false;
  }
  function parseObject() {
    if (text[i2] === "{") {
      output += "{";
      i2++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(",")) {
        parseWhitespaceAndSkipComments();
      }
      let initial3 = true;
      while (i2 < text.length && text[i2] !== "}") {
        let processedComma2;
        if (!initial3) {
          processedComma2 = parseCharacter(",");
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
          parseWhitespaceAndSkipComments();
        } else {
          processedComma2 = true;
          initial3 = false;
        }
        skipEllipsis();
        const processedKey = parseString() || parseUnquotedString(true);
        if (!processedKey) {
          if (text[i2] === "}" || text[i2] === "{" || text[i2] === "]" || text[i2] === "[" || text[i2] === void 0) {
            output = stripLastOccurrence(output, ",");
          } else {
            throwObjectKeyExpected();
          }
          break;
        }
        parseWhitespaceAndSkipComments();
        const processedColon = parseCharacter(":");
        const truncatedText = i2 >= text.length;
        if (!processedColon) {
          if (isStartOfValue(text[i2]) || truncatedText) {
            output = insertBeforeLastWhitespace(output, ":");
          } else {
            throwColonExpected();
          }
        }
        const processedValue = parseValue();
        if (!processedValue) {
          if (processedColon || truncatedText) {
            output += "null";
          } else {
            throwColonExpected();
          }
        }
      }
      if (text[i2] === "}") {
        output += "}";
        i2++;
      } else {
        output = insertBeforeLastWhitespace(output, "}");
      }
      return true;
    }
    return false;
  }
  function parseArray() {
    if (text[i2] === "[") {
      output += "[";
      i2++;
      parseWhitespaceAndSkipComments();
      if (skipCharacter(",")) {
        parseWhitespaceAndSkipComments();
      }
      let initial3 = true;
      while (i2 < text.length && text[i2] !== "]") {
        if (!initial3) {
          const processedComma2 = parseCharacter(",");
          if (!processedComma2) {
            output = insertBeforeLastWhitespace(output, ",");
          }
        } else {
          initial3 = false;
        }
        skipEllipsis();
        const processedValue = parseValue();
        if (!processedValue) {
          output = stripLastOccurrence(output, ",");
          break;
        }
      }
      if (text[i2] === "]") {
        output += "]";
        i2++;
      } else {
        output = insertBeforeLastWhitespace(output, "]");
      }
      return true;
    }
    return false;
  }
  function parseNewlineDelimitedJSON() {
    let initial3 = true;
    let processedValue = true;
    while (processedValue) {
      if (!initial3) {
        const processedComma2 = parseCharacter(",");
        if (!processedComma2) {
          output = insertBeforeLastWhitespace(output, ",");
        }
      } else {
        initial3 = false;
      }
      processedValue = parseValue();
    }
    if (!processedValue) {
      output = stripLastOccurrence(output, ",");
    }
    output = `[
${output}
]`;
  }
  function parseString() {
    let stopAtDelimiter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let stopAtIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let skipEscapeChars = text[i2] === "\\";
    if (skipEscapeChars) {
      i2++;
      skipEscapeChars = true;
    }
    if (isQuote(text[i2])) {
      const isEndQuote = isDoubleQuote(text[i2]) ? isDoubleQuote : isSingleQuote(text[i2]) ? isSingleQuote : isSingleQuoteLike(text[i2]) ? isSingleQuoteLike : isDoubleQuoteLike;
      const iBefore = i2;
      const oBefore = output.length;
      let str = '"';
      i2++;
      while (true) {
        if (i2 >= text.length) {
          const iPrev = prevNonWhitespaceIndex(i2 - 1);
          if (!stopAtDelimiter && isDelimiter(text.charAt(iPrev))) {
            i2 = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          str = insertBeforeLastWhitespace(str, '"');
          output += str;
          return true;
        }
        if (i2 === stopAtIndex) {
          str = insertBeforeLastWhitespace(str, '"');
          output += str;
          return true;
        }
        if (isEndQuote(text[i2])) {
          const iQuote = i2;
          const oQuote = str.length;
          str += '"';
          i2++;
          output += str;
          parseWhitespaceAndSkipComments(false);
          if (stopAtDelimiter || i2 >= text.length || isDelimiter(text[i2]) || isQuote(text[i2]) || isDigit(text[i2])) {
            parseConcatenatedString();
            return true;
          }
          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1);
          const prevChar2 = text.charAt(iPrevChar);
          if (prevChar2 === ",") {
            i2 = iBefore;
            output = output.substring(0, oBefore);
            return parseString(false, iPrevChar);
          }
          if (isDelimiter(prevChar2)) {
            i2 = iBefore;
            output = output.substring(0, oBefore);
            return parseString(true);
          }
          output = output.substring(0, oBefore);
          i2 = iQuote + 1;
          str = `${str.substring(0, oQuote)}\\${str.substring(oQuote)}`;
        } else if (stopAtDelimiter && isUnquotedStringDelimiter(text[i2])) {
          if (text[i2 - 1] === ":" && regexUrlStart.test(text.substring(iBefore + 1, i2 + 2))) {
            while (i2 < text.length && regexUrlChar.test(text[i2])) {
              str += text[i2];
              i2++;
            }
          }
          str = insertBeforeLastWhitespace(str, '"');
          output += str;
          parseConcatenatedString();
          return true;
        } else if (text[i2] === "\\") {
          const char = text.charAt(i2 + 1);
          const escapeChar = escapeCharacters[char];
          if (escapeChar !== void 0) {
            str += text.slice(i2, i2 + 2);
            i2 += 2;
          } else if (char === "u") {
            let j = 2;
            while (j < 6 && isHex(text[i2 + j])) {
              j++;
            }
            if (j === 6) {
              str += text.slice(i2, i2 + 6);
              i2 += 6;
            } else if (i2 + j >= text.length) {
              i2 = text.length;
            } else {
              throwInvalidUnicodeCharacter();
            }
          } else {
            str += char;
            i2 += 2;
          }
        } else {
          const char = text.charAt(i2);
          if (char === '"' && text[i2 - 1] !== "\\") {
            str += `\\${char}`;
            i2++;
          } else if (isControlCharacter(char)) {
            str += controlCharacters[char];
            i2++;
          } else {
            if (!isValidStringCharacter(char)) {
              throwInvalidCharacter(char);
            }
            str += char;
            i2++;
          }
        }
        if (skipEscapeChars) {
          skipEscapeCharacter();
        }
      }
    }
    return false;
  }
  function parseConcatenatedString() {
    let processed2 = false;
    parseWhitespaceAndSkipComments();
    while (text[i2] === "+") {
      processed2 = true;
      i2++;
      parseWhitespaceAndSkipComments();
      output = stripLastOccurrence(output, '"', true);
      const start = output.length;
      const parsedStr = parseString();
      if (parsedStr) {
        output = removeAtIndex(output, start, 1);
      } else {
        output = insertBeforeLastWhitespace(output, '"');
      }
    }
    return processed2;
  }
  function parseNumber() {
    const start = i2;
    if (text[i2] === "-") {
      i2++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i2])) {
        i2 = start;
        return false;
      }
    }
    while (isDigit(text[i2])) {
      i2++;
    }
    if (text[i2] === ".") {
      i2++;
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i2])) {
        i2 = start;
        return false;
      }
      while (isDigit(text[i2])) {
        i2++;
      }
    }
    if (text[i2] === "e" || text[i2] === "E") {
      i2++;
      if (text[i2] === "-" || text[i2] === "+") {
        i2++;
      }
      if (atEndOfNumber()) {
        repairNumberEndingWithNumericSymbol(start);
        return true;
      }
      if (!isDigit(text[i2])) {
        i2 = start;
        return false;
      }
      while (isDigit(text[i2])) {
        i2++;
      }
    }
    if (!atEndOfNumber()) {
      i2 = start;
      return false;
    }
    if (i2 > start) {
      const num = text.slice(start, i2);
      const hasInvalidLeadingZero = /^0\d/.test(num);
      output += hasInvalidLeadingZero ? `"${num}"` : num;
      return true;
    }
    return false;
  }
  function parseKeywords() {
    return parseKeyword("true", "true") || parseKeyword("false", "false") || parseKeyword("null", "null") || // repair Python keywords True, False, None
    parseKeyword("True", "true") || parseKeyword("False", "false") || parseKeyword("None", "null");
  }
  function parseKeyword(name2, value) {
    if (text.slice(i2, i2 + name2.length) === name2) {
      output += value;
      i2 += name2.length;
      return true;
    }
    return false;
  }
  function parseUnquotedString(isKey2) {
    const start = i2;
    if (isFunctionNameCharStart(text[i2])) {
      while (i2 < text.length && isFunctionNameChar(text[i2])) {
        i2++;
      }
      let j = i2;
      while (isWhitespace(text, j)) {
        j++;
      }
      if (text[j] === "(") {
        i2 = j + 1;
        parseValue();
        if (text[i2] === ")") {
          i2++;
          if (text[i2] === ";") {
            i2++;
          }
        }
        return true;
      }
    }
    while (i2 < text.length && !isUnquotedStringDelimiter(text[i2]) && !isQuote(text[i2]) && (!isKey2 || text[i2] !== ":")) {
      i2++;
    }
    if (text[i2 - 1] === ":" && regexUrlStart.test(text.substring(start, i2 + 2))) {
      while (i2 < text.length && regexUrlChar.test(text[i2])) {
        i2++;
      }
    }
    if (i2 > start) {
      while (isWhitespace(text, i2 - 1) && i2 > 0) {
        i2--;
      }
      const symbol = text.slice(start, i2);
      output += symbol === "undefined" ? "null" : JSON.stringify(symbol);
      if (text[i2] === '"') {
        i2++;
      }
      return true;
    }
  }
  function parseRegex() {
    if (text[i2] === "/") {
      const start = i2;
      i2++;
      while (i2 < text.length && (text[i2] !== "/" || text[i2 - 1] === "\\")) {
        i2++;
      }
      i2++;
      output += `"${text.substring(start, i2)}"`;
      return true;
    }
  }
  function prevNonWhitespaceIndex(start) {
    let prev = start;
    while (prev > 0 && isWhitespace(text, prev)) {
      prev--;
    }
    return prev;
  }
  function atEndOfNumber() {
    return i2 >= text.length || isDelimiter(text[i2]) || isWhitespace(text, i2);
  }
  function repairNumberEndingWithNumericSymbol(start) {
    output += `${text.slice(start, i2)}0`;
  }
  function throwInvalidCharacter(char) {
    throw new JSONRepairError(`Invalid character ${JSON.stringify(char)}`, i2);
  }
  function throwUnexpectedCharacter() {
    throw new JSONRepairError(`Unexpected character ${JSON.stringify(text[i2])}`, i2);
  }
  function throwUnexpectedEnd() {
    throw new JSONRepairError("Unexpected end of json string", text.length);
  }
  function throwObjectKeyExpected() {
    throw new JSONRepairError("Object key expected", i2);
  }
  function throwColonExpected() {
    throw new JSONRepairError("Colon expected", i2);
  }
  function throwInvalidUnicodeCharacter() {
    const chars = text.slice(i2, i2 + 6);
    throw new JSONRepairError(`Invalid unicode character "${chars}"`, i2);
  }
}
function atEndOfBlockComment(text, i2) {
  return text[i2] === "*" && text[i2 + 1] === "/";
}

// node_modules/lodash-es/lodash.js
var lodash_exports = {};
__export(lodash_exports, {
  add: () => add_default,
  after: () => after_default,
  ary: () => ary_default,
  assign: () => assign_default,
  assignIn: () => assignIn_default,
  assignInWith: () => assignInWith_default,
  assignWith: () => assignWith_default,
  at: () => at_default,
  attempt: () => attempt_default,
  before: () => before_default,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  bindKey: () => bindKey_default,
  camelCase: () => camelCase_default,
  capitalize: () => capitalize_default,
  castArray: () => castArray_default,
  ceil: () => ceil_default,
  chain: () => chain_default,
  chunk: () => chunk_default,
  clamp: () => clamp_default,
  clone: () => clone_default,
  cloneDeep: () => cloneDeep_default,
  cloneDeepWith: () => cloneDeepWith_default,
  cloneWith: () => cloneWith_default,
  commit: () => commit_default,
  compact: () => compact_default,
  concat: () => concat_default,
  cond: () => cond_default,
  conforms: () => conforms_default,
  conformsTo: () => conformsTo_default,
  constant: () => constant_default,
  countBy: () => countBy_default,
  create: () => create_default,
  curry: () => curry_default,
  curryRight: () => curryRight_default,
  debounce: () => debounce_default,
  deburr: () => deburr_default,
  default: () => lodash_default_default,
  defaultTo: () => defaultTo_default,
  defaults: () => defaults_default,
  defaultsDeep: () => defaultsDeep_default,
  defer: () => defer_default,
  delay: () => delay_default,
  difference: () => difference_default,
  differenceBy: () => differenceBy_default,
  differenceWith: () => differenceWith_default,
  divide: () => divide_default,
  drop: () => drop_default,
  dropRight: () => dropRight_default,
  dropRightWhile: () => dropRightWhile_default,
  dropWhile: () => dropWhile_default,
  each: () => forEach_default,
  eachRight: () => forEachRight_default,
  endsWith: () => endsWith_default,
  entries: () => toPairs_default,
  entriesIn: () => toPairsIn_default,
  eq: () => eq_default,
  escape: () => escape_default,
  escapeRegExp: () => escapeRegExp_default,
  every: () => every_default,
  extend: () => assignIn_default,
  extendWith: () => assignInWith_default,
  fill: () => fill_default,
  filter: () => filter_default,
  find: () => find_default,
  findIndex: () => findIndex_default,
  findKey: () => findKey_default,
  findLast: () => findLast_default,
  findLastIndex: () => findLastIndex_default,
  findLastKey: () => findLastKey_default,
  first: () => head_default,
  flatMap: () => flatMap_default,
  flatMapDeep: () => flatMapDeep_default,
  flatMapDepth: () => flatMapDepth_default,
  flatten: () => flatten_default,
  flattenDeep: () => flattenDeep_default,
  flattenDepth: () => flattenDepth_default,
  flip: () => flip_default,
  floor: () => floor_default,
  flow: () => flow_default,
  flowRight: () => flowRight_default,
  forEach: () => forEach_default,
  forEachRight: () => forEachRight_default,
  forIn: () => forIn_default,
  forInRight: () => forInRight_default,
  forOwn: () => forOwn_default,
  forOwnRight: () => forOwnRight_default,
  fromPairs: () => fromPairs_default,
  functions: () => functions_default,
  functionsIn: () => functionsIn_default,
  get: () => get_default,
  groupBy: () => groupBy_default,
  gt: () => gt_default,
  gte: () => gte_default,
  has: () => has_default,
  hasIn: () => hasIn_default,
  head: () => head_default,
  identity: () => identity_default,
  inRange: () => inRange_default,
  includes: () => includes_default,
  indexOf: () => indexOf_default,
  initial: () => initial_default,
  intersection: () => intersection_default,
  intersectionBy: () => intersectionBy_default,
  intersectionWith: () => intersectionWith_default,
  invert: () => invert_default,
  invertBy: () => invertBy_default,
  invoke: () => invoke_default,
  invokeMap: () => invokeMap_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isArrayLike: () => isArrayLike_default,
  isArrayLikeObject: () => isArrayLikeObject_default,
  isBoolean: () => isBoolean_default,
  isBuffer: () => isBuffer_default,
  isDate: () => isDate_default,
  isElement: () => isElement_default,
  isEmpty: () => isEmpty_default,
  isEqual: () => isEqual_default,
  isEqualWith: () => isEqualWith_default,
  isError: () => isError_default,
  isFinite: () => isFinite_default,
  isFunction: () => isFunction_default,
  isInteger: () => isInteger_default,
  isLength: () => isLength_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch_default,
  isMatchWith: () => isMatchWith_default,
  isNaN: () => isNaN_default,
  isNative: () => isNative_default,
  isNil: () => isNil_default,
  isNull: () => isNull_default,
  isNumber: () => isNumber_default,
  isObject: () => isObject_default,
  isObjectLike: () => isObjectLike_default,
  isPlainObject: () => isPlainObject_default,
  isRegExp: () => isRegExp_default,
  isSafeInteger: () => isSafeInteger_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined_default,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee_default,
  join: () => join_default,
  kebabCase: () => kebabCase_default,
  keyBy: () => keyBy_default,
  keys: () => keys_default,
  keysIn: () => keysIn_default,
  last: () => last_default,
  lastIndexOf: () => lastIndexOf_default,
  lodash: () => wrapperLodash_default,
  lowerCase: () => lowerCase_default,
  lowerFirst: () => lowerFirst_default,
  lt: () => lt_default,
  lte: () => lte_default,
  map: () => map_default,
  mapKeys: () => mapKeys_default,
  mapValues: () => mapValues_default,
  matches: () => matches_default,
  matchesProperty: () => matchesProperty_default,
  max: () => max_default,
  maxBy: () => maxBy_default,
  mean: () => mean_default,
  meanBy: () => meanBy_default,
  memoize: () => memoize_default,
  merge: () => merge_default,
  mergeWith: () => mergeWith_default,
  method: () => method_default,
  methodOf: () => methodOf_default,
  min: () => min_default,
  minBy: () => minBy_default,
  mixin: () => mixin_default,
  multiply: () => multiply_default,
  negate: () => negate_default,
  next: () => next_default,
  noop: () => noop_default,
  now: () => now_default,
  nth: () => nth_default,
  nthArg: () => nthArg_default,
  omit: () => omit_default,
  omitBy: () => omitBy_default,
  once: () => once_default,
  orderBy: () => orderBy_default,
  over: () => over_default,
  overArgs: () => overArgs_default,
  overEvery: () => overEvery_default,
  overSome: () => overSome_default,
  pad: () => pad_default,
  padEnd: () => padEnd_default,
  padStart: () => padStart_default,
  parseInt: () => parseInt_default,
  partial: () => partial_default,
  partialRight: () => partialRight_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pickBy: () => pickBy_default,
  plant: () => plant_default,
  property: () => property_default,
  propertyOf: () => propertyOf_default,
  pull: () => pull_default,
  pullAll: () => pullAll_default,
  pullAllBy: () => pullAllBy_default,
  pullAllWith: () => pullAllWith_default,
  pullAt: () => pullAt_default,
  random: () => random_default,
  range: () => range_default,
  rangeRight: () => rangeRight_default,
  rearg: () => rearg_default,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject_default,
  remove: () => remove_default,
  repeat: () => repeat_default,
  replace: () => replace_default,
  rest: () => rest_default,
  result: () => result_default,
  reverse: () => reverse_default,
  round: () => round_default,
  sample: () => sample_default,
  sampleSize: () => sampleSize_default,
  set: () => set_default,
  setWith: () => setWith_default,
  shuffle: () => shuffle_default,
  size: () => size_default,
  slice: () => slice_default,
  snakeCase: () => snakeCase_default,
  some: () => some_default,
  sortBy: () => sortBy_default,
  sortedIndex: () => sortedIndex_default,
  sortedIndexBy: () => sortedIndexBy_default,
  sortedIndexOf: () => sortedIndexOf_default,
  sortedLastIndex: () => sortedLastIndex_default,
  sortedLastIndexBy: () => sortedLastIndexBy_default,
  sortedLastIndexOf: () => sortedLastIndexOf_default,
  sortedUniq: () => sortedUniq_default,
  sortedUniqBy: () => sortedUniqBy_default,
  split: () => split_default,
  spread: () => spread_default,
  startCase: () => startCase_default,
  startsWith: () => startsWith_default,
  stubArray: () => stubArray_default,
  stubFalse: () => stubFalse_default,
  stubObject: () => stubObject_default,
  stubString: () => stubString_default,
  stubTrue: () => stubTrue_default,
  subtract: () => subtract_default,
  sum: () => sum_default,
  sumBy: () => sumBy_default,
  tail: () => tail_default,
  take: () => take_default,
  takeRight: () => takeRight_default,
  takeRightWhile: () => takeRightWhile_default,
  takeWhile: () => takeWhile_default,
  tap: () => tap_default,
  template: () => template_default,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle_default,
  thru: () => thru_default,
  times: () => times_default,
  toArray: () => toArray_default,
  toFinite: () => toFinite_default,
  toInteger: () => toInteger_default,
  toIterator: () => toIterator_default,
  toJSON: () => wrapperValue_default,
  toLength: () => toLength_default,
  toLower: () => toLower_default,
  toNumber: () => toNumber_default,
  toPairs: () => toPairs_default,
  toPairsIn: () => toPairsIn_default,
  toPath: () => toPath_default,
  toPlainObject: () => toPlainObject_default,
  toSafeInteger: () => toSafeInteger_default,
  toString: () => toString_default,
  toUpper: () => toUpper_default,
  transform: () => transform_default,
  trim: () => trim_default,
  trimEnd: () => trimEnd_default,
  trimStart: () => trimStart_default,
  truncate: () => truncate_default,
  unary: () => unary_default,
  unescape: () => unescape_default,
  union: () => union_default,
  unionBy: () => unionBy_default,
  unionWith: () => unionWith_default,
  uniq: () => uniq_default,
  uniqBy: () => uniqBy_default,
  uniqWith: () => uniqWith_default,
  uniqueId: () => uniqueId_default,
  unset: () => unset_default,
  unzip: () => unzip_default,
  unzipWith: () => unzipWith_default,
  update: () => update_default,
  updateWith: () => updateWith_default,
  upperCase: () => upperCase_default,
  upperFirst: () => upperFirst_default,
  value: () => wrapperValue_default,
  valueOf: () => wrapperValue_default,
  values: () => values_default,
  valuesIn: () => valuesIn_default,
  without: () => without_default,
  words: () => words_default,
  wrap: () => wrap_default,
  wrapperAt: () => wrapperAt_default,
  wrapperChain: () => wrapperChain_default,
  wrapperCommit: () => commit_default,
  wrapperLodash: () => wrapperLodash_default,
  wrapperNext: () => next_default,
  wrapperPlant: () => plant_default,
  wrapperReverse: () => wrapperReverse_default,
  wrapperToIterator: () => toIterator_default,
  wrapperValue: () => wrapperValue_default,
  xor: () => xor_default,
  xorBy: () => xorBy_default,
  xorWith: () => xorWith_default,
  zip: () => zip_default,
  zipObject: () => zipObject_default,
  zipObjectDeep: () => zipObjectDeep_default,
  zipWith: () => zipWith_default
});

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty2 = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result2 = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee2) {
  var index2 = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index2 < length) {
    result2[index2] = iteratee2(array[index2], index2, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator2, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator2(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add2 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add2;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN2;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result2 = toFinite_default(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n2, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty3 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array, placeholder) {
  var length = array.length, result2 = 0;
  while (length--) {
    if (array[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty4 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array = realNames_default[result2], length = hasOwnProperty4.call(realNames_default, result2) ? array.length : 0;
  while (length--) {
    var data = array[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty5 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty5.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string2) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee2) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee2(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG2], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair2) {
    var value = "_." + pair2[0];
    if (bitmask & pair2[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array, indexes) {
  var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
  while (length--) {
    var index2 = indexes[length];
    array[length] = isIndex_default(index2, arrLength) ? oldArray[index2] : void 0;
  }
  return array;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array, placeholder) {
  var index2 = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index2 < length) {
    var value = array[index2];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index2] = PLACEHOLDER;
      result2[resIndex++] = index2;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index2 = length;
    while (index2--) {
      args[index2] = arguments[index2];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index2 = length, placeholder = getHolder_default(wrapper);
    while (index2--) {
      args[index2] = arguments[index2];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry_default(func, bitmask, createHybrid_default, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length);
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n2, guard) {
  n2 = guard ? void 0 : n2;
  n2 = func && n2 == null ? func.length : n2;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n2);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty6 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty6.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform3) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax4(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform3(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type == "string" && index2 in object) {
    return eq_default(object[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n2, iteratee2) {
  var index2 = -1, result2 = Array(n2);
  while (++index2 < n2) {
    result2[index2] = iteratee2(index2);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty7 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty8 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes_default(value.length, String) : [], length = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform3) {
  return function(arg) {
    return func(transform3(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty9 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty9.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty10 = objectProto11.hasOwnProperty;
var assign = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty10.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty11 = objectProto12.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty11.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty12 = objectProto13.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty12.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty13 = objectProto14.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty13.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache.set(key, result2) || cache;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
  var result2 = [];
  if (string2.charCodeAt(0) === 46) {
    result2.push("");
  }
  string2.replace(rePropName, function(match, number2, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result2;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey_default(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index2 = -1, length = paths.length, result2 = Array(length), skip = object == null;
  while (++index2 < length) {
    result2[index2] = skip ? void 0 : get_default(object, paths[index2]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index2 = -1, length = values2.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth2, predicate, isStrict, result2) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth2 > 0 && predicate(value)) {
      if (depth2 > 1) {
        baseFlatten(value, depth2 - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty14 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty14.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e2) {
    return isError_default(e2) ? e2 : new Error(e2);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n2, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n2 = toInteger_default(n2);
  return function() {
    if (--n2 > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n2 <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length);
  while (++index2 < length) {
    result2[index2] = array[index2 + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string2) {
  return reHasUnicode.test(string2);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string2) {
  return string2.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string2) {
  return string2.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string2) {
  return hasUnicode_default(string2) ? unicodeToArray_default(string2) : asciiToArray_default(string2);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string2) {
    string2 = toString_default(string2);
    var strSymbols = hasUnicode_default(string2) ? stringToArray_default(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string2) {
  return upperFirst_default(toString_default(string2).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index2 = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee2(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string2) {
  string2 = toString_default(string2);
  return string2 && string2.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string2) {
  return string2.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string2) {
  return reHasUnicodeWord.test(string2);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
function unicodeWords(string2) {
  return string2.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string2, pattern, guard) {
  string2 = toString_default(string2);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string2) ? unicodeWords_default(string2) : asciiWords_default(string2);
  }
  return string2.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "[']";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string2) {
    return arrayReduce_default(words_default(deburr_default(string2).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index2) {
  word = word.toLowerCase();
  return result2 + (index2 ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number2, precision) {
    number2 = toNumber_default(number2);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number2)) {
      var pair2 = (toString_default(number2) + "e").split("e"), value = func(pair2[0] + "e" + (+pair2[1] + precision));
      pair2 = (toString_default(value) + "e").split("e");
      return +(pair2[0] + "e" + (+pair2[1] - precision));
    }
    return func(number2);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array, size2, guard) {
  if (guard ? isIterateeCall_default(array, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax5(toInteger_default(size2), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size2 < 1) {
    return [];
  }
  var index2 = 0, resIndex = 0, result2 = Array(nativeCeil(length / size2));
  while (index2 < length) {
    result2[resIndex++] = baseSlice_default(array, index2, index2 += size2);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number2, lower, upper) {
  if (number2 === number2) {
    if (upper !== void 0) {
      number2 = number2 <= upper ? number2 : upper;
    }
    if (lower !== void 0) {
      number2 = number2 >= lower ? number2 : lower;
    }
  }
  return number2;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp(number2, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number2), lower, upper);
}
var clamp_default = clamp;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result2 = baseGetTag_default(value), Ctor = result2 == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty15 = objectProto17.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result2 = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty15.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact(array) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index2 < length) {
    var value = array[index2];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array = arguments[0], index2 = length;
  while (index2--) {
    args[index2 - 1] = arguments[index2];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index2 = -1, result2 = Array(map2.size);
  map2.forEach(function(value, key) {
    result2[++index2] = [key, value];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index2 = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index2] = value;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result2 = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty16 = objectProto18.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty16.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty17 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty17.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty17.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default(object), length = result2.length;
  while (length--) {
    var key = result2[length], value = object[key];
    result2[length] = [key, value, isStrictComparable_default(value)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index2 = -1, length = path.length, result2 = false;
  while (++index2 < length) {
    var key = toKey_default(path[index2]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index2 != length) {
    return result2;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length ? [] : arrayMap_default(pairs, function(pair2) {
    if (typeof pair2[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair2[0]), pair2[1]];
  });
  return baseRest_default(function(args) {
    var index2 = -1;
    while (++index2 < length) {
      var pair2 = pairs[index2];
      if (apply_default(pair2[0], this, args)) {
        return apply_default(pair2[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (length--) {
    var key = props[length], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee2, accumulator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    var value = array[index2];
    setter(accumulator, value, iteratee2(value), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee2(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty18 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty18.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax6(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty19 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index2 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index2 < length) {
    var source = sources[index2];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto21[key]) && !hasOwnProperty19.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer;

// node_modules/lodash-es/delay.js
var delay = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array, values2, iteratee2, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
  if (!length) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer: while (++index2 < length) {
    var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values2[valuesIndex] === computed) {
          continue outer;
        }
      }
      result2.push(value);
    } else if (!includes2(values2, computed, comparator)) {
      result2.push(value);
    }
  }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference;

// node_modules/lodash-es/last.js
function last2(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last2;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array, n2, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array, n2 < 0 ? 0 : n2, length);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array, n2, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length - n2;
  return baseSlice_default(array, 0, n2 < 0 ? 0 : n2);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length, index2 = fromRight ? length : -1;
  while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
  }
  return isDrop ? baseSlice_default(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice_default(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  while (length--) {
    if (iteratee2(array[length], length, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string2, target, position) {
  string2 = toString_default(string2);
  target = baseToString_default(target);
  var length = string2.length;
  position = position === void 0 ? length : baseClamp_default(toInteger_default(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string2.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set2) {
  var index2 = -1, result2 = Array(set2.size);
  set2.forEach(function(value) {
    result2[++index2] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape2(string2) {
  string2 = toString_default(string2);
  return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar_default) : string2;
}
var escape_default = escape2;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string2) {
  string2 = toString_default(string2);
  return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar2, "\\$&") : string2;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (!predicate(array[index2], index2, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index2, collection2) {
    result2 = !!predicate(value, index2, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array, value, start, end) {
  var length = array.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger_default(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array, value, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill_default(array, value, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax7(length + index2, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index2);
}
var findIndex_default = findIndex;

// node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = length - 1;
  if (fromIndex !== void 0) {
    index2 = toInteger_default(fromIndex);
    index2 = fromIndex < 0 ? nativeMax8(length + index2, 0) : nativeMin5(index2, length - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index2, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index2 = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index2] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth2) {
  depth2 = depth2 === void 0 ? 1 : toInteger_default(depth2);
  return baseFlatten_default(map_default(collection, iteratee2), depth2);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array, depth2) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  depth2 = depth2 === void 0 ? 1 : toInteger_default(depth2);
  return baseFlatten_default(array, depth2);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index2 = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index2--) {
      var func = funcs[index2];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index2 = wrapper ? index2 : length;
    while (++index2 < length) {
      func = funcs[index2];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
      while (++index3 < length) {
        result2 = funcs[index3].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index2 < length) {
    var pair2 = pairs[index2];
    result2[pair2[0]] = pair2[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty20 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty20.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator2) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator2(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty21 = objectProto23.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty21.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path) {
  return object != null && hasPath_default(object, path, baseHas_default);
}
var has_default = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number2, start, end) {
  return number2 >= nativeMin6(start, end) && number2 < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number2, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number2 = toNumber_default(number2);
  return baseInRange_default(number2, start, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax11(length + index2, 0);
  }
  return baseIndexOf_default(array, value, index2);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial2(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 0, -1) : [];
}
var initial_default = initial2;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee2) {
      array = arrayMap_default(array, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index2 = -1, seen = caches[0];
  outer: while (++index2 < length && result2.length < maxLength) {
    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result2.push(value);
    }
  }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result2[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty22 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString4.call(value);
  }
  if (hasOwnProperty22.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index2] = isFunc ? apply_default(path, value, args) : baseInvoke_default(value, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag5;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty23 = objectProto26.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag8 || tag == setTag8) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty23.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/isEqual.js
function isEqual2(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual2;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite2(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite2;

// node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag5;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array, separator) {
  return array == null ? "" : nativeJoin.call(array, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array, value, fromIndex) {
  var index2 = fromIndex + 1;
  while (index2--) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return index2;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = length;
  if (fromIndex !== void 0) {
    index2 = toInteger_default(fromIndex);
    index2 = index2 < 0 ? nativeMax12(length + index2, 0) : nativeMin8(index2, length - 1);
  }
  return value === value ? strictLastIndexOf_default(array, value, index2) : baseFindIndex_default(array, baseIsNaN_default, index2, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee2, comparator) {
  var index2 = -1, length = array.length;
  while (++index2 < length) {
    var value = array[index2], current = iteratee2(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseGt_default) : void 0;
}
var max_default = max;

// node_modules/lodash-es/maxBy.js
function maxBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee2) {
  var result2, index2 = -1, length = array.length;
  while (++index2 < length) {
    var current = iteratee2(array[index2]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  return length ? baseSum_default(array, iteratee2) / length : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean(array) {
  return baseMean_default(array, identity_default);
}
var mean_default = mean;

// node_modules/lodash-es/meanBy.js
function meanBy(array, iteratee2) {
  return baseMean_default(array, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min;

// node_modules/lodash-es/minBy.js
function minBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options) && "chain" in options) || !!options.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({
            "func": func,
            "args": arguments,
            "thisArg": object
          });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return {
    "done": done,
    "value": value
  };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array, n2) {
  var length = array.length;
  if (!length) {
    return;
  }
  n2 += n2 < 0 ? length : 0;
  return isIndex_default(n2, length) ? array[n2] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array, n2) {
  return array && array.length ? baseNth_default(array, toInteger_default(n2)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n2) {
  n2 = toInteger_default(n2);
  return baseRest_default(function(args) {
    return baseNth_default(args, n2);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length = paths.length;
  while (length--) {
    baseUnset_default(result2, paths[length]);
  }
  return result2;
});
var omit_default = omit;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey_default(path[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index2 = -1, length = paths.length, result2 = {};
  while (++index2 < length) {
    var path = paths[index2], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result2, castPath_default(path, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length) {
    var result2 = compareAscending_default(objCriteria[index2], othCriteria[index2]);
    if (result2) {
      if (index2 >= ordersLength) {
        return result2;
      }
      var order = orders[index2];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index2 = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return {
      "criteria": criteria,
      "index": ++index2,
      "value": value
    };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index2 = -1, length = nativeMin9(args.length, funcsLength);
    while (++index2 < length) {
      args[index2] = transforms[index2].call(this, args[index2]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string2, n2) {
  var result2 = "";
  if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n2 % 2) {
      result2 += string2;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string2 += string2;
    }
  } while (n2);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string2) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string2)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string2) {
  return hasUnicode_default(string2) ? unicodeSize_default(string2) : asciiSize_default(string2);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length).join("") : result2.slice(0, length);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string2, length, chars) {
  string2 = toString_default(string2);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string2) : 0;
  if (!length || strLength >= length) {
    return string2;
  }
  var mid = (length - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string2 + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad;

// node_modules/lodash-es/padEnd.js
function padEnd(string2, length, chars) {
  string2 = toString_default(string2);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string2) : 0;
  return length && strLength < length ? string2 + createPadding_default(length - strLength, chars) : string2;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string2, length, chars) {
  string2 = toString_default(string2);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string2) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string2 : string2;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string2, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string2).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (comparator(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index2 = -1, length = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array, baseUnary_default(iteratee2));
  }
  while (++index2 < length) {
    var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2) : array;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array, values2, iteratee2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, baseIteratee_default(iteratee2, 2)) : array;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array, values2, comparator) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, void 0, comparator) : array;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index2 = indexes[length];
    if (length == lastIndex || index2 !== previous) {
      var previous = index2;
      if (isIndex_default(index2)) {
        splice3.call(array, index2, 1);
      } else {
        baseUnset_default(array, index2);
      }
    }
  }
  return array;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array, indexes) {
  var length = array == null ? 0 : array.length, result2 = baseAt_default(array, indexes);
  basePullAt_default(array, arrayMap_default(indexes, function(index2) {
    return isIndex_default(index2, length) ? +index2 : index2;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index2 = -1, length = nativeMax13(nativeCeil4((end - start) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index2] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index2, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
  var length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array[length], length, array);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove2(array, predicate) {
  var result2 = [];
  if (!(array && array.length)) {
    return result2;
  }
  var index2 = -1, indexes = [], length = array.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result2.push(value);
      indexes.push(index2);
    }
  }
  basePullAt_default(array, indexes);
  return result2;
}
var remove_default = remove2;

// node_modules/lodash-es/repeat.js
function repeat(string2, n2, guard) {
  if (guard ? isIterateeCall_default(string2, n2, guard) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  return baseRepeat_default(toString_default(string2), n2);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace2() {
  var args = arguments, string2 = toString_default(args[0]);
  return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
}
var replace_default = replace2;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index2 = -1, length = path.length;
  if (!length) {
    length = 1;
    object = void 0;
  }
  while (++index2 < length) {
    var value = object == null ? void 0 : object[toKey_default(path[index2])];
    if (value === void 0) {
      index2 = length;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}
var reverse_default = reverse;

// node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// node_modules/lodash-es/_arraySample.js
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom_default(0, length - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size2) {
  var index2 = -1, length = array.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index2 < size2) {
    var rand = baseRandom_default(index2, lastIndex), value = array[rand];
    array[rand] = array[index2];
    array[index2] = value;
  }
  array.length = size2;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array, n2) {
  return shuffleSelf_default(copyArray_default(array), baseClamp_default(n2, 0, array.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n2) {
  var array = values_default(collection);
  return shuffleSelf_default(array, baseClamp_default(n2, 0, array.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n2, guard) {
  if (guard ? isIterateeCall_default(collection, n2, guard) : n2 === void 0) {
    n2 = 1;
  } else {
    n2 = toInteger_default(n2);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n2);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// node_modules/lodash-es/slice.js
function slice(array, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length : toInteger_default(end);
  }
  return baseSlice_default(array, start, end);
}
var slice_default = slice;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index2, collection2) {
    result2 = predicate(value, index2, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array, value, iteratee2, retHighest) {
  var low = 0, high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array, value, retHighest) {
  var low = 0, high = array == null ? low : array.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array, value, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array, value) {
  return baseSortedIndex_default(array, value);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index2 = baseSortedIndex_default(array, value);
    if (index2 < length && eq_default(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array, value) {
  return baseSortedIndex_default(array, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index2 = baseSortedIndex_default(array, value, true) - 1;
    if (eq_default(array[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array, iteratee2) {
  var index2 = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index2 < length) {
    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
    if (!index2 || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq_default(array) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array, iteratee2) {
  return array && array.length ? baseSortedUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string2, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string2, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string2 = toString_default(string2);
  if (string2 && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string2)) {
      return castSlice_default(stringToArray_default(string2), 0, limit);
    }
  }
  return string2.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array) {
      arrayPush_default(otherArgs, array);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith2(string2, target, position) {
  string2 = toString_default(string2);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string2.length);
  target = baseToString_default(target);
  return string2.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith2;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum(array) {
  return array && array.length ? baseSum_default(array, identity_default) : 0;
}
var sum_default = sum;

// node_modules/lodash-es/sumBy.js
function sumBy(array, iteratee2) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 1, length) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take(array, n2, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  return baseSlice_default(array, 0, n2 < 0 ? 0 : n2);
}
var take_default = take;

// node_modules/lodash-es/takeRight.js
function takeRight(array, n2, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger_default(n2);
  n2 = length - n2;
  return baseSlice_default(array, n2 < 0 ? 0 : n2, length);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto27 = Object.prototype;
var hasOwnProperty24 = objectProto27.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto27[key]) && !hasOwnProperty24.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": {
      "escape": escape_default
    }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto28 = Object.prototype;
var hasOwnProperty25 = objectProto28.hasOwnProperty;
function template(string2, options, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string2, options, guard)) {
    options = void 0;
  }
  string2 = toString_default(string2);
  options = assignInWith_default({}, options, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
  var sourceURL = hasOwnProperty25.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string2.slice(index2, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index2 = offset + match.length;
    return match;
  });
  source += "';\n";
  var variable = hasOwnProperty25.call(options, "variable") && options.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n2, iteratee2) {
  n2 = toInteger_default(n2);
  if (n2 < 1 || n2 > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index2 = MAX_ARRAY_LENGTH6, length = nativeMin12(n2, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n2 -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length, iteratee2);
  while (++index2 < n2) {
    iteratee2(index2);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform2(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index2, object2) {
    return iteratee2(accumulator, value, index2, object2);
  });
  return accumulator;
}
var transform_default = transform2;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index2 = strSymbols.length;
  while (index2-- && baseIndexOf_default(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index2 = -1, length = strSymbols.length;
  while (++index2 < length && baseIndexOf_default(chrSymbols, strSymbols[index2], 0) > -1) {
  }
  return index2;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string2, chars, guard) {
  string2 = toString_default(string2);
  if (string2 && (guard || chars === void 0)) {
    return baseTrim_default(string2);
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string2, chars, guard) {
  string2 = toString_default(string2);
  if (string2 && (guard || chars === void 0)) {
    return string2.slice(0, trimmedEndIndex_default(string2) + 1);
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string2, chars, guard) {
  string2 = toString_default(string2);
  if (string2 && (guard || chars === void 0)) {
    return string2.replace(reTrimStart3, "");
  }
  if (!string2 || !(chars = baseToString_default(chars))) {
    return string2;
  }
  var strSymbols = stringToArray_default(string2), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string2, options) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options)) {
    var separator = "separator" in options ? options.separator : separator;
    length = "length" in options ? toInteger_default(options.length) : length;
    omission = "omission" in options ? baseToString_default(options.omission) : omission;
  }
  string2 = toString_default(string2);
  var strLength = string2.length;
  if (hasUnicode_default(string2)) {
    var strSymbols = stringToArray_default(string2);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string2;
  }
  var end = length - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string2.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string2.slice(end).search(separator)) {
      var match, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string2.indexOf(baseToString_default(separator), end) != end) {
    var index2 = result2.lastIndexOf(separator);
    if (index2 > -1) {
      result2 = result2.slice(0, index2);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape2(string2) {
  string2 = toString_default(string2);
  return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar_default) : string2;
}
var unescape_default = unescape2;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array, iteratee2, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set2 = iteratee2 ? null : createSet_default(array);
    if (set2) {
      return setToArray_default(set2);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer: while (++index2 < length) {
    var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee2) {
        seen.push(computed);
      }
      result2.push(value);
    } else if (!includes2(seen, computed, comparator)) {
      if (seen !== result2) {
        seen.push(computed);
      }
      result2.push(value);
    }
  }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee2) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id2 = ++idCounter;
  return toString_default(prefix) + id2;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter_default(array, function(group) {
    if (isArrayLikeObject_default(group)) {
      length = nativeMax15(group.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index2) {
    return arrayMap_default(array, baseProperty_default(index2));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array, iteratee2) {
  if (!(array && array.length)) {
    return [];
  }
  var result2 = unzip_default(array);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group) {
    return apply_default(iteratee2, void 0, group);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index2) {
  return result2 + (index2 ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array) {
    if (length && !array.length) {
      array.push(void 0);
    }
    return array;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq_default(arrays[0]) : [];
  }
  var index2 = -1, result2 = Array(length);
  while (++index2 < length) {
    var array = arrays[index2], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index2) {
        result2[index2] = baseDifference_default(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index2 < length) {
    var value = index2 < valsLength ? values2[index2] : void 0;
    assignFunc(result2, props[index2], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index2 = -1, length = transforms.length;
  while (++index2 < length) {
    var data = transforms[index2], size2 = data.size;
    switch (data.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size2);
        break;
    }
  }
  return {
    "start": start,
    "end": end
  };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue_default(array, this.__actions__);
  }
  var result2 = [];
  outer: while (length-- && resIndex < takeCount) {
    index2 += dir;
    var iterIndex = -1, value = array[index2];
    while (++iterIndex < iterLength) {
      var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
      if (type == LAZY_MAP_FLAG) {
        value = computed;
      } else if (!computed) {
        if (type == LAZY_FILTER_FLAG) {
          continue outer;
        } else {
          break outer;
        }
      }
    }
    result2[resIndex++] = value;
  }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto29 = Object.prototype;
var hasOwnProperty26 = objectProto29.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ function(func) {
  return function(object, source, options) {
    if (options == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty26.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), {
  "chain": false
});
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index2) {
  LazyWrapper_default.prototype[methodName] = function(n2) {
    n2 = n2 === void 0 ? 1 : nativeMax17(toInteger_default(n2), 0);
    var result2 = this.__filtered__ && !index2 ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n2, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n2, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n2) {
    return this.reverse()[methodName](n2).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index2) {
  var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index2) {
  var takeName = "take" + (index2 ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index2) {
  var dropName = "drop" + (index2 ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({
        "func": thru_default,
        "args": [interceptor],
        "thisArg": void 0
      });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty26.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({
      "name": methodName,
      "func": lodashFunc
    });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}
var lodash_default_default = wrapperLodash_default;

// node_modules/@jsonquerylang/jsonquery/lib/jsonquery.js
var N = (t3) => Array.isArray(t3);
var Y = (t3) => t3 !== null && typeof t3 == "object" && !N(t3);
var q = (t3) => typeof t3 == "string";
var A = (t3, e2) => t3 === e2 ? true : t3 !== null && e2 !== null && typeof t3 == "object" && typeof e2 == "object" && Object.keys(t3).length === Object.keys(e2).length && Object.entries(t3).every(([r2, s2]) => A(s2, e2[r2]));
function p(t3) {
  return (...e2) => {
    const n2 = e2.map((o2) => h(o2)), r2 = n2[0], s2 = n2[1];
    return n2.length === 1 ? (o2) => t3(r2(o2)) : n2.length === 2 ? (o2) => t3(r2(o2), s2(o2)) : (o2) => t3(...n2.map((d) => d(o2)));
  };
}
var F = {
  boolean: 0,
  number: 1,
  string: 2
};
var V = 3;
var D = (t3, e2) => typeof t3 == typeof e2 && typeof t3 in F ? t3 > e2 : false;
var tt = (t3, e2) => A(t3, e2) || D(t3, e2);
var C = (t3, e2) => typeof t3 == typeof e2 && typeof t3 in F ? t3 < e2 : false;
var et = (t3, e2) => A(t3, e2) || C(t3, e2);
var M = {
  pipe: (...t3) => {
    const e2 = t3.map((n2) => h(n2));
    return (n2) => e2.reduce((r2, s2) => s2(r2), n2);
  },
  object: (t3) => {
    const e2 = Object.keys(t3).map((n2) => [n2, h(t3[n2])]);
    return (n2) => {
      const r2 = {};
      for (const [s2, o2] of e2) r2[s2] = o2(n2);
      return r2;
    };
  },
  array: (...t3) => {
    const e2 = t3.map((n2) => h(n2));
    return (n2) => e2.map((r2) => r2(n2));
  },
  get: (...t3) => {
    if (t3.length === 0) return (e2) => e2 ?? null;
    if (t3.length === 1) {
      const e2 = t3[0];
      return (n2) => (n2 == null ? void 0 : n2[e2]) ?? null;
    }
    return (e2) => {
      let n2 = e2;
      for (const r2 of t3) n2 = n2 == null ? void 0 : n2[r2];
      return n2 ?? null;
    };
  },
  map: (t3) => {
    const e2 = h(t3);
    return (n2) => n2.map(e2);
  },
  mapObject: (t3) => {
    const e2 = h(t3);
    return (n2) => {
      const r2 = {};
      for (const s2 of Object.keys(n2)) {
        const o2 = e2({
          key: s2,
          value: n2[s2]
        });
        r2[o2.key] = o2.value;
      }
      return r2;
    };
  },
  mapKeys: (t3) => {
    const e2 = h(t3);
    return (n2) => {
      const r2 = {};
      for (const s2 of Object.keys(n2)) {
        const o2 = e2(s2);
        r2[o2] = n2[s2];
      }
      return r2;
    };
  },
  mapValues: (t3) => {
    const e2 = h(t3);
    return (n2) => {
      const r2 = {};
      for (const s2 of Object.keys(n2)) r2[s2] = e2(n2[s2]);
      return r2;
    };
  },
  filter: (t3) => {
    const e2 = h(t3);
    return (n2) => n2.filter((r2) => Z(e2(r2)));
  },
  sort: (t3 = ["get"], e2) => {
    const n2 = h(t3), r2 = e2 === "desc" ? -1 : 1;
    function s2(o2, d) {
      const u = n2(o2), x = n2(d);
      if (typeof u != typeof x) {
        const I = F[typeof u] ?? V, S = F[typeof x] ?? V;
        return I > S ? r2 : I < S ? -r2 : 0;
      }
      return typeof u in F ? u > x ? r2 : u < x ? -r2 : 0 : 0;
    }
    return (o2) => o2.slice().sort(s2);
  },
  reverse: () => (t3) => t3.toReversed(),
  pick: (...t3) => {
    const e2 = t3.map(([r2, ...s2]) => [s2[s2.length - 1], M.get(...s2)]), n2 = (r2, s2) => {
      const o2 = {};
      for (const [d, u] of s2) o2[d] = u(r2);
      return o2;
    };
    return (r2) => N(r2) ? r2.map((s2) => n2(s2, e2)) : n2(r2, e2);
  },
  groupBy: (t3) => {
    const e2 = h(t3);
    return (n2) => {
      const r2 = {};
      for (const s2 of n2) {
        const o2 = e2(s2);
        r2[o2] ? r2[o2].push(s2) : r2[o2] = [s2];
      }
      return r2;
    };
  },
  keyBy: (t3) => {
    const e2 = h(t3);
    return (n2) => {
      const r2 = {};
      for (const s2 of n2) {
        const o2 = e2(s2);
        o2 in r2 || (r2[o2] = s2);
      }
      return r2;
    };
  },
  flatten: () => (t3) => t3.flat(),
  join: (t3 = "") => (e2) => e2.join(t3),
  split: p((t3, e2) => e2 !== void 0 ? t3.split(e2) : t3.trim().split(/\s+/)),
  substring: p((t3, e2, n2) => t3.slice(Math.max(e2, 0), n2)),
  uniq: () => (t3) => {
    const e2 = [];
    for (const n2 of t3) e2.findIndex((r2) => A(r2, n2)) === -1 && e2.push(n2);
    return e2;
  },
  uniqBy: (t3) => (e2) => Object.values(M.keyBy(t3)(e2)),
  limit: (t3) => (e2) => e2.slice(0, Math.max(t3, 0)),
  size: () => (t3) => t3.length,
  keys: () => Object.keys,
  values: () => Object.values,
  prod: () => (t3) => T(t3, (e2, n2) => e2 * n2),
  sum: () => (t3) => N(t3) ? t3.reduce((e2, n2) => e2 + n2, 0) : U(),
  average: () => (t3) => N(t3) ? t3.length > 0 ? t3.reduce((e2, n2) => e2 + n2) / t3.length : null : U(),
  min: () => (t3) => T(t3, (e2, n2) => Math.min(e2, n2)),
  max: () => (t3) => T(t3, (e2, n2) => Math.max(e2, n2)),
  and: p((...t3) => T(t3, (e2, n2) => !!(e2 && n2))),
  or: p((...t3) => T(t3, (e2, n2) => !!(e2 || n2))),
  not: p((t3) => !t3),
  exists: (t3) => {
    const e2 = t3.slice(1), n2 = e2.pop(), r2 = M.get(...e2);
    return (s2) => {
      const o2 = r2(s2);
      return !!o2 && Object.hasOwnProperty.call(o2, n2);
    };
  },
  if: (t3, e2, n2) => {
    const r2 = h(t3), s2 = h(e2), o2 = h(n2);
    return (d) => Z(r2(d)) ? s2(d) : o2(d);
  },
  in: (t3, e2) => {
    const n2 = h(t3), r2 = h(e2);
    return (s2) => {
      const o2 = n2(s2);
      return r2(s2).findIndex((u) => A(u, o2)) !== -1;
    };
  },
  "not in": (t3, e2) => {
    const n2 = M.in(t3, e2);
    return (r2) => !n2(r2);
  },
  regex: (t3, e2, n2) => {
    const r2 = new RegExp(e2, n2), s2 = h(t3);
    return (o2) => r2.test(s2(o2));
  },
  eq: p(A),
  gt: p(D),
  gte: p(tt),
  lt: p(C),
  lte: p(et),
  ne: p((t3, e2) => !A(t3, e2)),
  add: p((t3, e2) => t3 + e2),
  subtract: p((t3, e2) => t3 - e2),
  multiply: p((t3, e2) => t3 * e2),
  divide: p((t3, e2) => t3 / e2),
  mod: p((t3, e2) => t3 % e2),
  pow: p((t3, e2) => t3 ** e2),
  abs: p(Math.abs),
  round: p((t3, e2 = 0) => +`${Math.round(+`${t3}e${e2}`)}e${-e2}`),
  number: p((t3) => {
    const e2 = Number(t3);
    return Number.isNaN(Number(t3)) ? null : e2;
  }),
  string: p(String)
};
var Z = (t3) => t3 !== null && t3 !== 0 && t3 !== false;
var T = (t3, e2) => (N(t3) || U(), t3.length === 0 ? null : t3.reduce(e2));
var U = () => {
  z("Array expected");
};
var z = (t3) => {
  throw new TypeError(t3);
};
var W = [];
function h(t3, e2) {
  W.unshift(__spreadValues(__spreadValues(__spreadValues({}, M), W[0]), e2 == null ? void 0 : e2.functions));
  try {
    const n2 = N(t3) ? nt(t3, W[0]) : Y(t3) ? z(`Function notation ["object", {...}] expected but got ${JSON.stringify(t3)}`) : () => t3;
    return (r2) => {
      try {
        return n2(r2);
      } catch (s2) {
        throw s2.jsonquery = [{
          data: r2,
          query: t3
        }, ...s2.jsonquery ?? []], s2;
      }
    };
  } finally {
    W.shift();
  }
}
function nt(t3, e2) {
  const [n2, ...r2] = t3, s2 = e2[n2];
  return s2 || z(`Unknown function '${n2}'`), s2(...r2);
}
var G = [{
  pow: "^"
}, {
  multiply: "*",
  divide: "/",
  mod: "%"
}, {
  add: "+",
  subtract: "-"
}, {
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  in: "in",
  "not in": "not in"
}, {
  eq: "==",
  ne: "!="
}, {
  and: "and"
}, {
  or: "or"
}, {
  pipe: "|"
}];
var rt = ["|", "and", "or"];
var H = ["|", "and", "or", "*", "/", "%", "+", "-"];
function X(t3, e2) {
  if (!N(e2)) throw new Error("Invalid custom operators");
  return e2.reduce(st, t3);
}
function st(t3, {
  name: e2,
  op: n2,
  at: r2,
  after: s2,
  before: o2
}) {
  if (r2) return t3.map((x) => Object.values(x).includes(r2) ? __spreadProps(__spreadValues({}, x), {
    [e2]: n2
  }) : x);
  const d = s2 ?? o2, u = t3.findIndex((x) => Object.values(x).includes(d));
  if (u !== -1) return t3.toSpliced(u + (s2 ? 1 : 0), 0, {
    [e2]: n2
  });
  throw new Error("Invalid custom operator");
}
var ot = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
var ct = /^[a-zA-Z_$][a-zA-Z\d_$]*/;
var it = /^"(?:[^"\\]|\\.)*"/;
var ut = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
var lt2 = /^(0|[1-9][0-9]*)/;
var at2 = /^(true|false|null)/;
var ft = /^[ \n\t\r]+/;
function pt(t3, e2) {
  const n2 = (e2 == null ? void 0 : e2.operators) ?? [], r2 = X(G, n2), s2 = Object.assign({}, ...r2), o2 = rt.concat(n2.filter((c) => c.vararg).map((c) => c.op)), d = H.concat(n2.filter((c) => c.leftAssociative).map((c) => c.op)), u = (c = r2.length - 1) => {
    const g = r2[c];
    if (!g) return I();
    const m = t3[i2] === "(";
    let $ = u(c - 1);
    for (; ; ) {
      f();
      const P = i2, R = x(g);
      if (!R) break;
      const B = u(c - 1), Q = $[0], K = R === Q && !m;
      if (K && !d.includes(s2[R])) {
        i2 = P;
        break;
      }
      $ = K && o2.includes(s2[R]) ? [...$, B] : [R, $, B];
    }
    return $;
  }, x = (c) => {
    const g = Object.keys(c).sort((m, $) => $.length - m.length);
    for (const m of g) {
      const $ = c[m];
      if (t3.substring(i2, i2 + $.length) === $) return i2 += $.length, f(), m;
    }
  }, I = () => {
    if (f(), t3[i2] === "(") {
      i2++;
      const c = u();
      return j(")"), c;
    }
    return S();
  }, S = () => {
    if (t3[i2] === ".") {
      const c = [];
      for (; t3[i2] === "."; ) i2++, c.push(l() ?? y() ?? O() ?? _("Property expected"));
      return ["get", ...c];
    }
    return L();
  }, L = () => {
    const c = i2, g = y();
    if (f(), !g || t3[i2] !== "(") return i2 = c, E();
    i2++, f();
    const m = t3[i2] !== ")" ? [u()] : [];
    for (; i2 < t3.length && t3[i2] !== ")"; ) f(), j(","), m.push(u());
    return j(")"), [g, ...m];
  }, E = () => {
    if (t3[i2] === "{") {
      i2++, f();
      const c = {};
      let g = true;
      for (; i2 < t3.length && t3[i2] !== "}"; ) {
        g ? g = false : (j(","), f());
        const m = l() ?? y() ?? O() ?? _("Key expected");
        f(), j(":"), c[m] = u();
      }
      return j("}"), ["object", c];
    }
    return a2();
  }, a2 = () => {
    if (t3[i2] === "[") {
      i2++, f();
      const c = [];
      let g = true;
      for (; i2 < t3.length && t3[i2] !== "]"; ) g ? g = false : (j(","), f()), c.push(u());
      return j("]"), ["array", ...c];
    }
    return l() ?? b() ?? k();
  }, l = () => v(it, JSON.parse), y = () => v(ct, (c) => c), b = () => v(ut, JSON.parse), O = () => v(lt2, JSON.parse), k = () => {
    const c = v(at2, JSON.parse);
    if (c !== void 0) return c;
    _("Value expected");
  }, w = () => {
    f(), i2 < t3.length && _(`Unexpected part '${t3.substring(i2)}'`);
  }, v = (c, g) => {
    const m = t3.substring(i2).match(c);
    if (m) return i2 += m[0].length, g(m[0]);
  }, f = () => v(ft, (c) => c), j = (c) => {
    t3[i2] !== c && _(`Character '${c}' expected`), i2++;
  }, _ = (c, g = i2) => {
    throw new SyntaxError(`${c} (pos: ${g})`);
  };
  let i2 = 0;
  const J = u();
  return w(), J;
}
var gt2 = 40;
var ht = "  ";
var mt = (t3, e2) => {
  const n2 = (e2 == null ? void 0 : e2.indentation) ?? ht, r2 = (e2 == null ? void 0 : e2.operators) ?? [], s2 = X(G, r2), o2 = Object.assign({}, ...s2), d = H.concat(r2.filter((a2) => a2.leftAssociative).map((a2) => a2.op)), u = (a2, l, y = false) => N(a2) ? x(a2, l, y) : JSON.stringify(a2), x = (a2, l, y) => {
    const [b, ...O] = a2;
    if (b === "get" && O.length > 0) return S(O);
    if (b === "object") return I(O[0], l);
    if (b === "array") {
      const f = O.map((j) => u(j, l));
      return E(f, ["[", ", ", "]"], [`[
${l + n2}`, `,
${l + n2}`, `
${l}]`]);
    }
    const k = o2[b];
    if (k) {
      const f = y ? "(" : "", j = y ? ")" : "", _ = O.map((i2, J) => {
        const c = i2 == null ? void 0 : i2[0], g = s2.findIndex((P) => b in P), m = s2.findIndex((P) => c in P), $ = g < m || g === m && J > 0 || b === c && !d.includes(k);
        return u(i2, l + n2, $);
      });
      return E(_, [f, ` ${k} `, j], [f, `
${l + n2}${k} `, j]);
    }
    const w = O.length === 1 ? l : l + n2, v = O.map((f) => u(f, w));
    return E(v, [`${b}(`, ", ", ")"], O.length === 1 ? [`${b}(`, `,
${l}`, ")"] : [`${b}(
${w}`, `,
${w}`, `
${l})`]);
  }, I = (a2, l) => {
    const y = l + n2, b = Object.entries(a2).map(([O, k]) => `${L(O)}: ${u(k, y)}`);
    return E(b, ["{ ", ", ", " }"], [`{
${y}`, `,
${y}`, `
${l}}`]);
  }, S = (a2) => a2.map((l) => `.${L(l)}`).join(""), L = (a2) => ot.test(a2) ? a2 : JSON.stringify(a2), E = (a2, [l, y, b], [O, k, w]) => l.length + a2.reduce((f, j) => f + j.length + y.length, 0) - y.length + b.length <= ((e2 == null ? void 0 : e2.maxLineLength) ?? gt2) ? l + a2.join(y) + b : O + a2.join(k) + w;
  return u(t3, "");
};
function dt(t3, e2, n2) {
  return h(q(e2) ? pt(e2, n2) : e2, n2)(t3);
}

// node_modules/@fortawesome/free-regular-svg-icons/index.mjs
var faLightbulb = {
  prefix: "far",
  iconName: "lightbulb",
  icon: [384, 512, [128161], "f0eb", "M297.2 248.9C311.6 228.3 320 203.2 320 176c0-70.7-57.3-128-128-128S64 105.3 64 176c0 27.2 8.4 52.3 22.8 72.9c3.7 5.3 8.1 11.3 12.8 17.7c0 0 0 0 0 0c12.9 17.7 28.3 38.9 39.8 59.8c10.4 19 15.7 38.8 18.3 57.5L109 384c-2.2-12-5.9-23.7-11.8-34.5c-9.9-18-22.2-34.9-34.5-51.8c0 0 0 0 0 0s0 0 0 0c-5.2-7.1-10.4-14.2-15.4-21.4C27.6 247.9 16 213.3 16 176C16 78.8 94.8 0 192 0s176 78.8 176 176c0 37.3-11.6 71.9-31.4 100.3c-5 7.2-10.2 14.3-15.4 21.4c0 0 0 0 0 0s0 0 0 0c-12.3 16.8-24.6 33.7-34.5 51.8c-5.9 10.8-9.6 22.5-11.8 34.5l-48.6 0c2.6-18.7 7.9-38.6 18.3-57.5c11.5-20.9 26.9-42.1 39.8-59.8c0 0 0 0 0 0s0 0 0 0s0 0 0 0c4.7-6.4 9-12.4 12.7-17.7zM192 128c-26.5 0-48 21.5-48 48c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-44.2 35.8-80 80-80c8.8 0 16 7.2 16 16s-7.2 16-16 16zm0 384c-44.2 0-80-35.8-80-80l0-16 160 0 0 16c0 44.2-35.8 80-80 80z"]
};
var faSquareCheck = {
  prefix: "far",
  iconName: "square-check",
  icon: [448, 512, [9745, 9989, 61510, "check-square"], "f14a", "M64 80c-8.8 0-16 7.2-16 16l0 320c0 8.8 7.2 16 16 16l320 0c8.8 0 16-7.2 16-16l0-320c0-8.8-7.2-16-16-16L64 80zM0 96C0 60.7 28.7 32 64 32l320 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM337 209L209 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L303 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
};
var faCheckSquare = faSquareCheck;
var faSquare = {
  prefix: "far",
  iconName: "square",
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M384 80c8.8 0 16 7.2 16 16l0 320c0 8.8-7.2 16-16 16L64 432c-8.8 0-16-7.2-16-16L48 96c0-8.8 7.2-16 16-16l320 0zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"]
};
var faClock = {
  prefix: "far",
  iconName: "clock",
  icon: [512, 512, [128339, "clock-four"], "f017", "M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"]
};

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faTrashCan = {
  prefix: "fas",
  iconName: "trash-can",
  icon: [448, 512, [61460, "trash-alt"], "f2ed", "M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"]
};
var faDownLeftAndUpRightToCenter = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39L439 7zM72 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39L73 505c-9.4 9.4-24.6 9.4-33.9 0L7 473c-9.4-9.4-9.4-24.6 0-33.9l87-87L55 313c-6.9-6.9-8.9-17.2-5.2-26.2s12.5-14.8 22.2-14.8z"]
};
var faCaretRight = {
  prefix: "fas",
  iconName: "caret-right",
  icon: [256, 512, [], "f0da", "M246.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 256c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l128-128z"]
};
var faPaste = {
  prefix: "fas",
  iconName: "paste",
  icon: [512, 512, ["file-clipboard"], "f0ea", "M160 0c-23.7 0-44.4 12.9-55.4 32L48 32C21.5 32 0 53.5 0 80L0 400c0 26.5 21.5 48 48 48l144 0 0-272c0-44.2 35.8-80 80-80l48 0 0-16c0-26.5-21.5-48-48-48l-56.6 0C204.4 12.9 183.7 0 160 0zM272 128c-26.5 0-48 21.5-48 48l0 272 0 16c0 26.5 21.5 48 48 48l192 0c26.5 0 48-21.5 48-48l0-220.1c0-12.7-5.1-24.9-14.1-33.9l-67.9-67.9c-9-9-21.2-14.1-33.9-14.1L320 128l-48 0zM160 40a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
};
var faCircleNotch = {
  prefix: "fas",
  iconName: "circle-notch",
  icon: [512, 512, [], "f1ce", "M222.7 32.1c5 16.9-4.6 34.8-21.5 39.8C121.8 95.6 64 169.1 64 256c0 106 86 192 192 192s192-86 192-192c0-86.9-57.8-160.4-137.1-184.1c-16.9-5-26.6-22.9-21.5-39.8s22.9-26.6 39.8-21.5C434.9 42.1 512 140 512 256c0 141.4-114.6 256-256 256S0 397.4 0 256C0 140 77.1 42.1 182.9 10.6c16.9-5 34.8 4.6 39.8 21.5z"]
};
var faScissors = {
  prefix: "fas",
  iconName: "scissors",
  icon: [512, 512, [9984, 9986, 9988, "cut"], "f0c4", "M256 192l-39.5-39.5c4.9-12.6 7.5-26.2 7.5-40.5C224 50.1 173.9 0 112 0S0 50.1 0 112s50.1 112 112 112c14.3 0 27.9-2.7 40.5-7.5L192 256l-39.5 39.5c-12.6-4.9-26.2-7.5-40.5-7.5C50.1 288 0 338.1 0 400s50.1 112 112 112s112-50.1 112-112c0-14.3-2.7-27.9-7.5-40.5L499.2 76.8c7.1-7.1 7.1-18.5 0-25.6c-28.3-28.3-74.1-28.3-102.4 0L256 192zm22.6 150.6L396.8 460.8c28.3 28.3 74.1 28.3 102.4 0c7.1-7.1 7.1-18.5 0-25.6L342.6 278.6l-64 64zM64 112a48 48 0 1 1 96 0 48 48 0 1 1 -96 0zm48 240a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"]
};
var faCut = faScissors;
var faSquareCaretDown = {
  prefix: "fas",
  iconName: "square-caret-down",
  icon: [448, 512, ["caret-square-down"], "f150", "M384 480c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0zM224 352c-6.7 0-13-2.8-17.6-7.7l-104-112c-6.5-7-8.2-17.2-4.4-25.9s12.5-14.4 22-14.4l208 0c9.5 0 18.2 5.7 22 14.4s2.1 18.9-4.4 25.9l-104 112c-4.5 4.9-10.9 7.7-17.6 7.7z"]
};
var faCaretSquareDown = faSquareCaretDown;
var faCaretLeft = {
  prefix: "fas",
  iconName: "caret-left",
  icon: [256, 512, [], "f0d9", "M9.4 278.6c-12.5-12.5-12.5-32.8 0-45.3l128-128c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 256c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-128-128z"]
};
var faSquareCheck2 = {
  prefix: "fas",
  iconName: "square-check",
  icon: [448, 512, [9745, 9989, 61510, "check-square"], "f14a", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM337 209L209 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L303 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
};
var faCheckSquare2 = faSquareCheck2;
var faPenToSquare = {
  prefix: "fas",
  iconName: "pen-to-square",
  icon: [512, 512, ["edit"], "f044", "M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z"]
};
var faEdit = faPenToSquare;
var faChevronUp = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [512, 512, [], "f077", "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
};
var faAngleRight = {
  prefix: "fas",
  iconName: "angle-right",
  icon: [320, 512, [8250], "f105", "M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"]
};
var faSquareCaretUp = {
  prefix: "fas",
  iconName: "square-caret-up",
  icon: [448, 512, ["caret-square-up"], "f151", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM224 160c6.7 0 13 2.8 17.6 7.7l104 112c6.5 7 8.2 17.2 4.4 25.9s-12.5 14.4-22 14.4l-208 0c-9.5 0-18.2-5.7-22-14.4s-2.1-18.9 4.4-25.9l104-112c4.5-4.9 10.9-7.7 17.6-7.7z"]
};
var faCaretSquareUp = faSquareCaretUp;
var faCaretUp = {
  prefix: "fas",
  iconName: "caret-up",
  icon: [320, 512, [], "f0d8", "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"]
};
var faSquare2 = {
  prefix: "fas",
  iconName: "square",
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M0 96C0 60.7 28.7 32 64 32H384c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96z"]
};
var faFilter = {
  prefix: "fas",
  iconName: "filter",
  icon: [512, 512, [], "f0b0", "M3.9 54.9C10.5 40.9 24.5 32 40 32l432 0c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9 320 448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6l0-79.1L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"]
};
var faCode = {
  prefix: "fas",
  iconName: "code",
  icon: [640, 512, [], "f121", "M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"]
};
var faWrench = {
  prefix: "fas",
  iconName: "wrench",
  icon: [512, 512, [128295], "f0ad", "M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"]
};
var faEye = {
  prefix: "fas",
  iconName: "eye",
  icon: [576, 512, [128065], "f06e", "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"]
};
var faPen = {
  prefix: "fas",
  iconName: "pen",
  icon: [512, 512, [128394], "f304", "M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z"]
};
var faArrowRotateRight = {
  prefix: "fas",
  iconName: "arrow-rotate-right",
  icon: [512, 512, [8635, "arrow-right-rotate", "arrow-rotate-forward", "redo"], "f01e", "M386.3 160L336 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0s-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3s163.8-62.5 226.3 0L386.3 160z"]
};
var faRedo = faArrowRotateRight;
var faArrowRotateLeft = {
  prefix: "fas",
  iconName: "arrow-rotate-left",
  icon: [512, 512, [8634, "arrow-left-rotate", "arrow-rotate-back", "arrow-rotate-backward", "undo"], "f0e2", "M125.7 160l50.3 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L48 224c-17.7 0-32-14.3-32-32L16 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 51.2L97.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L125.7 160z"]
};
var faUndo = faArrowRotateLeft;
var faCropSimple = {
  prefix: "fas",
  iconName: "crop-simple",
  icon: [512, 512, ["crop-alt"], "f565", "M128 32c0-17.7-14.3-32-32-32S64 14.3 64 32l0 32L32 64C14.3 64 0 78.3 0 96s14.3 32 32 32l32 0 0 256c0 35.3 28.7 64 64 64l224 0 0-64-224 0 0-352zM384 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32 32 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-32 0 0-256c0-35.3-28.7-64-64-64L160 64l0 64 224 0 0 352z"]
};
var faCropAlt = faCropSimple;
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
};
var faCog = faGear;
var faCaretDown = {
  prefix: "fas",
  iconName: "caret-down",
  icon: [320, 512, [], "f0d7", "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"]
};
var faEllipsisVertical = {
  prefix: "fas",
  iconName: "ellipsis-vertical",
  icon: [128, 512, ["ellipsis-v"], "f142", "M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"]
};
var faEllipsisV = faEllipsisVertical;
var faArrowRightArrowLeft = {
  prefix: "fas",
  iconName: "arrow-right-arrow-left",
  icon: [448, 512, [8644, "exchange"], "f0ec", "M438.6 150.6c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.7 96 32 96C14.3 96 0 110.3 0 128s14.3 32 32 32l306.7 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l96-96zm-333.3 352c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 416 416 416c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96z"]
};
var faArrowDownShortWide = {
  prefix: "fas",
  iconName: "arrow-down-short-wide",
  icon: [576, 512, ["sort-amount-desc", "sort-amount-down-alt"], "f884", "M151.6 469.6C145.5 476.2 137 480 128 480s-17.5-3.8-23.6-10.4l-88-96c-11.9-13-11.1-33.3 2-45.2s33.3-11.1 45.2 2L96 365.7 96 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 301.7 32.4-35.4c11.9-13 32.2-13.9 45.2-2s13.9 32.2 2 45.2l-88 96zM320 32l32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-32 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-96 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l160 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-160 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 128l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"]
};
var faSortAmountDownAlt = faArrowDownShortWide;
var faAngleDown = {
  prefix: "fas",
  iconName: "angle-down",
  icon: [448, 512, [8964], "f107", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var faArrowDown = {
  prefix: "fas",
  iconName: "arrow-down",
  icon: [384, 512, [8595], "f063", "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var faMagnifyingGlass = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
};
var faSearch = faMagnifyingGlass;
var faChevronDown = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
};
var faCopy = {
  prefix: "fas",
  iconName: "copy",
  icon: [448, 512, [], "f0c5", "M208 0L332.1 0c12.7 0 24.9 5.1 33.9 14.1l67.9 67.9c9 9 14.1 21.2 14.1 33.9L448 336c0 26.5-21.5 48-48 48l-192 0c-26.5 0-48-21.5-48-48l0-288c0-26.5 21.5-48 48-48zM48 128l80 0 0 64-64 0 0 256 192 0 0-32 64 0 0 48c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 176c0-26.5 21.5-48 48-48z"]
};
var faPlus = {
  prefix: "fas",
  iconName: "plus",
  icon: [448, 512, [10133, 61543, "add"], "2b", "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"]
};
var faXmark = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
};
var faClose = faXmark;
var faTimes = faXmark;
var faRotate = {
  prefix: "fas",
  iconName: "rotate",
  icon: [512, 512, [128260, "sync-alt"], "f2f1", "M142.9 142.9c-17.5 17.5-30.1 38-37.8 59.8c-5.9 16.7-24.2 25.4-40.8 19.5s-25.4-24.2-19.5-40.8C55.6 150.7 73.2 122 97.6 97.6c87.2-87.2 228.3-87.5 315.8-1L455 55c6.9-6.9 17.2-8.9 26.2-5.2s14.8 12.5 14.8 22.2l0 128c0 13.3-10.7 24-24 24l-8.4 0c0 0 0 0 0 0L344 224c-9.7 0-18.5-5.8-22.2-14.8s-1.7-19.3 5.2-26.2l41.1-41.1c-62.6-61.5-163.1-61.2-225.3 1zM16 312c0-13.3 10.7-24 24-24l7.6 0 .7 0L168 288c9.7 0 18.5 5.8 22.2 14.8s1.7 19.3-5.2 26.2l-41.1 41.1c62.6 61.5 163.1 61.2 225.3-1c17.5-17.5 30.1-38 37.8-59.8c5.9-16.7 24.2-25.4 40.8-19.5s25.4 24.2 19.5 40.8c-10.8 30.6-28.4 59.3-52.9 83.8c-87.2 87.2-228.3 87.5-315.8 1L57 457c-6.9 6.9-17.2 8.9-26.2 5.2S16 449.7 16 440l0-119.6 0-.7 0-7.6z"]
};
var faUpRightAndDownLeftFromCenter = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87L327 41c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8z"]
};
var faClone = {
  prefix: "fas",
  iconName: "clone",
  icon: [512, 512, [], "f24d", "M288 448L64 448l0-224 64 0 0-64-64 0c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l224 0c35.3 0 64-28.7 64-64l0-64-64 0 0 64zm-64-96l224 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64L224 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64z"]
};
var faCheck = {
  prefix: "fas",
  iconName: "check",
  icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
};
var faTriangleExclamation = {
  prefix: "fas",
  iconName: "triangle-exclamation",
  icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
};
var faExclamationTriangle = faTriangleExclamation;

// node_modules/vanilla-jsoneditor/index.js
var import_natural_compare_lite = __toESM(require_natural_compare_lite());

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual3(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual3(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (cache && cache.lastThis === this && isEqual4(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// node_modules/vanilla-jsoneditor/index.js
var import_ajv = __toESM(require_ajv());
var import_jmespath = __toESM(require_jmespath());

// node_modules/jsonpath-plus/dist/index-browser-esm.js
var Hooks = class {
  /**
   * @callback HookCallback
   * @this {*|Jsep} this
   * @param {Jsep} env
   * @returns: void
   */
  /**
   * Adds the given callback to the list of callbacks for the given hook.
   *
   * The callback will be invoked when the hook it is registered for is run.
   *
   * One callback function can be registered to multiple hooks and the same hook multiple times.
   *
   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
   * @param {HookCallback|boolean} callback The callback function which is given environment variables.
   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
   * @public
   */
  add(name2, callback, first) {
    if (typeof arguments[0] != "string") {
      for (let name3 in arguments[0]) {
        this.add(name3, arguments[0][name3], arguments[1]);
      }
    } else {
      (Array.isArray(name2) ? name2 : [name2]).forEach(function(name3) {
        this[name3] = this[name3] || [];
        if (callback) {
          this[name3][first ? "unshift" : "push"](callback);
        }
      }, this);
    }
  }
  /**
   * Runs a hook invoking all registered callbacks with the given environment variables.
   *
   * Callbacks will be invoked synchronously and in the order in which they were registered.
   *
   * @param {string} name The name of the hook.
   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
   * @public
   */
  run(name2, env) {
    this[name2] = this[name2] || [];
    this[name2].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var Plugins = class {
  constructor(jsep2) {
    this.jsep = jsep2;
    this.registered = {};
  }
  /**
   * @callback PluginSetup
   * @this {Jsep} jsep
   * @returns: void
   */
  /**
   * Adds the given plugin(s) to the registry
   *
   * @param {object} plugins
   * @param {string} plugins.name The name of the plugin
   * @param {PluginSetup} plugins.init The init function
   * @public
   */
  register() {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }
    plugins.forEach((plugin3) => {
      if (typeof plugin3 !== "object" || !plugin3.name || !plugin3.init) {
        throw new Error("Invalid JSEP plugin format");
      }
      if (this.registered[plugin3.name]) {
        return;
      }
      plugin3.init(this.jsep);
      this.registered[plugin3.name] = plugin3;
    });
  }
};
var Jsep = class _Jsep {
  /**
   * @returns {string}
   */
  static get version() {
    return "1.4.0";
  }
  /**
   * @returns {string}
   */
  static toString() {
    return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
  }
  // ==================== CONFIG ================================
  /**
   * @method addUnaryOp
   * @param {string} op_name The name of the unary op to add
   * @returns {Jsep}
   */
  static addUnaryOp(op_name) {
    _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
    _Jsep.unary_ops[op_name] = 1;
    return _Jsep;
  }
  /**
   * @method jsep.addBinaryOp
   * @param {string} op_name The name of the binary op to add
   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
   * @param {boolean} [isRightAssociative=false] whether operator is right-associative
   * @returns {Jsep}
   */
  static addBinaryOp(op_name, precedence, isRightAssociative) {
    _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
    _Jsep.binary_ops[op_name] = precedence;
    if (isRightAssociative) {
      _Jsep.right_associative.add(op_name);
    } else {
      _Jsep.right_associative.delete(op_name);
    }
    return _Jsep;
  }
  /**
   * @method addIdentifierChar
   * @param {string} char The additional character to treat as a valid part of an identifier
   * @returns {Jsep}
   */
  static addIdentifierChar(char) {
    _Jsep.additional_identifier_chars.add(char);
    return _Jsep;
  }
  /**
   * @method addLiteral
   * @param {string} literal_name The name of the literal to add
   * @param {*} literal_value The value of the literal
   * @returns {Jsep}
   */
  static addLiteral(literal_name, literal_value) {
    _Jsep.literals[literal_name] = literal_value;
    return _Jsep;
  }
  /**
   * @method removeUnaryOp
   * @param {string} op_name The name of the unary op to remove
   * @returns {Jsep}
   */
  static removeUnaryOp(op_name) {
    delete _Jsep.unary_ops[op_name];
    if (op_name.length === _Jsep.max_unop_len) {
      _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
    }
    return _Jsep;
  }
  /**
   * @method removeAllUnaryOps
   * @returns {Jsep}
   */
  static removeAllUnaryOps() {
    _Jsep.unary_ops = {};
    _Jsep.max_unop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeIdentifierChar
   * @param {string} char The additional character to stop treating as a valid part of an identifier
   * @returns {Jsep}
   */
  static removeIdentifierChar(char) {
    _Jsep.additional_identifier_chars.delete(char);
    return _Jsep;
  }
  /**
   * @method removeBinaryOp
   * @param {string} op_name The name of the binary op to remove
   * @returns {Jsep}
   */
  static removeBinaryOp(op_name) {
    delete _Jsep.binary_ops[op_name];
    if (op_name.length === _Jsep.max_binop_len) {
      _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
    }
    _Jsep.right_associative.delete(op_name);
    return _Jsep;
  }
  /**
   * @method removeAllBinaryOps
   * @returns {Jsep}
   */
  static removeAllBinaryOps() {
    _Jsep.binary_ops = {};
    _Jsep.max_binop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeLiteral
   * @param {string} literal_name The name of the literal to remove
   * @returns {Jsep}
   */
  static removeLiteral(literal_name) {
    delete _Jsep.literals[literal_name];
    return _Jsep;
  }
  /**
   * @method removeAllLiterals
   * @returns {Jsep}
   */
  static removeAllLiterals() {
    _Jsep.literals = {};
    return _Jsep;
  }
  // ==================== END CONFIG ============================
  /**
   * @returns {string}
   */
  get char() {
    return this.expr.charAt(this.index);
  }
  /**
   * @returns {number}
   */
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * @param {string} expr a string with the passed in express
   * @returns Jsep
   */
  constructor(expr) {
    this.expr = expr;
    this.index = 0;
  }
  /**
   * static top-level parser
   * @returns {jsep.Expression}
   */
  static parse(expr) {
    return new _Jsep(expr).parse();
  }
  /**
   * Get the longest key length of any object
   * @param {object} obj
   * @returns {number}
   */
  static getMaxKeyLen(obj) {
    return Math.max(0, ...Object.keys(obj).map((k) => k.length));
  }
  /**
   * `ch` is a character code in the next three functions
   * @param {number} ch
   * @returns {boolean}
   */
  static isDecimalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 57;
  }
  /**
   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
   * @param {string} op_val
   * @returns {number}
   */
  static binaryPrecedence(op_val) {
    return _Jsep.binary_ops[op_val] || 0;
  }
  /**
   * Looks for start of identifier
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierStart(ch2) {
    return ch2 >= 65 && ch2 <= 90 || // A...Z
    ch2 >= 97 && ch2 <= 122 || // a...z
    ch2 >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch2)] || // any non-ASCII that is not an operator
    _Jsep.additional_identifier_chars.has(String.fromCharCode(ch2));
  }
  /**
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierPart(ch2) {
    return _Jsep.isIdentifierStart(ch2) || _Jsep.isDecimalDigit(ch2);
  }
  /**
   * throw error at index of the expression
   * @param {string} message
   * @throws
   */
  throwError(message) {
    const error = new Error(message + " at character " + this.index);
    error.index = this.index;
    error.description = message;
    throw error;
  }
  /**
   * Run a given hook
   * @param {string} name
   * @param {jsep.Expression|false} [node]
   * @returns {?jsep.Expression}
   */
  runHook(name2, node) {
    if (_Jsep.hooks[name2]) {
      const env = {
        context: this,
        node
      };
      _Jsep.hooks.run(name2, env);
      return env.node;
    }
    return node;
  }
  /**
   * Runs a given hook until one returns a node
   * @param {string} name
   * @returns {?jsep.Expression}
   */
  searchHook(name2) {
    if (_Jsep.hooks[name2]) {
      const env = {
        context: this
      };
      _Jsep.hooks[name2].find(function(callback) {
        callback.call(env.context, env);
        return env.node;
      });
      return env.node;
    }
  }
  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch2 = this.code;
    while (ch2 === _Jsep.SPACE_CODE || ch2 === _Jsep.TAB_CODE || ch2 === _Jsep.LF_CODE || ch2 === _Jsep.CR_CODE) {
      ch2 = this.expr.charCodeAt(++this.index);
    }
    this.runHook("gobble-spaces");
  }
  /**
   * Top-level method to parse all expressions and returns compound or single node
   * @returns {jsep.Expression}
   */
  parse() {
    this.runHook("before-all");
    const nodes = this.gobbleExpressions();
    const node = nodes.length === 1 ? nodes[0] : {
      type: _Jsep.COMPOUND,
      body: nodes
    };
    return this.runHook("after-all", node);
  }
  /**
   * top-level parser (but can be reused within as well)
   * @param {number} [untilICode]
   * @returns {jsep.Expression[]}
   */
  gobbleExpressions(untilICode) {
    let nodes = [], ch_i, node;
    while (this.index < this.expr.length) {
      ch_i = this.code;
      if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
        this.index++;
      } else {
        if (node = this.gobbleExpression()) {
          nodes.push(node);
        } else if (this.index < this.expr.length) {
          if (ch_i === untilICode) {
            break;
          }
          this.throwError('Unexpected "' + this.char + '"');
        }
      }
    }
    return nodes;
  }
  /**
   * The main parsing function.
   * @returns {?jsep.Expression}
   */
  gobbleExpression() {
    const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return this.runHook("after-expression", node);
  }
  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   * @returns {string|boolean}
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substr(0, --tc_len);
    }
    return false;
  }
  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   * @returns {?jsep.BinaryExpression}
   */
  gobbleBinaryExpression() {
    let node, biop, prec2, stack, biop_info, left, right, i2, cur_biop;
    left = this.gobbleToken();
    if (!left) {
      return left;
    }
    biop = this.gobbleBinaryOp();
    if (!biop) {
      return left;
    }
    biop_info = {
      value: biop,
      prec: _Jsep.binaryPrecedence(biop),
      right_a: _Jsep.right_associative.has(biop)
    };
    right = this.gobbleToken();
    if (!right) {
      this.throwError("Expected expression after " + biop);
    }
    stack = [left, biop_info, right];
    while (biop = this.gobbleBinaryOp()) {
      prec2 = _Jsep.binaryPrecedence(biop);
      if (prec2 === 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = {
        value: biop,
        prec: prec2,
        right_a: _Jsep.right_associative.has(biop)
      };
      cur_biop = biop;
      const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec2 > prev.prec : prec2 <= prev.prec;
      while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
        right = stack.pop();
        biop = stack.pop().value;
        left = stack.pop();
        node = {
          type: _Jsep.BINARY_EXP,
          operator: biop,
          left,
          right
        };
        stack.push(node);
      }
      node = this.gobbleToken();
      if (!node) {
        this.throwError("Expected expression after " + cur_biop);
      }
      stack.push(biop_info, node);
    }
    i2 = stack.length - 1;
    node = stack[i2];
    while (i2 > 1) {
      node = {
        type: _Jsep.BINARY_EXP,
        operator: stack[i2 - 1].value,
        left: stack[i2 - 2],
        right: node
      };
      i2 -= 2;
    }
    return node;
  }
  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   * @returns {boolean|jsep.Expression}
   */
  gobbleToken() {
    let ch2, to_check, tc_len, node;
    this.gobbleSpaces();
    node = this.searchHook("gobble-token");
    if (node) {
      return this.runHook("after-token", node);
    }
    ch2 = this.code;
    if (_Jsep.isDecimalDigit(ch2) || ch2 === _Jsep.PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    }
    if (ch2 === _Jsep.SQUOTE_CODE || ch2 === _Jsep.DQUOTE_CODE) {
      node = this.gobbleStringLiteral();
    } else if (ch2 === _Jsep.OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (!argument) {
            this.throwError("missing unaryOp argument");
          }
          return this.runHook("after-token", {
            type: _Jsep.UNARY_EXP,
            operator: to_check,
            argument,
            prefix: true
          });
        }
        to_check = to_check.substr(0, --tc_len);
      }
      if (_Jsep.isIdentifierStart(ch2)) {
        node = this.gobbleIdentifier();
        if (_Jsep.literals.hasOwnProperty(node.name)) {
          node = {
            type: _Jsep.LITERAL,
            value: _Jsep.literals[node.name],
            raw: node.name
          };
        } else if (node.name === _Jsep.this_str) {
          node = {
            type: _Jsep.THIS_EXP
          };
        }
      } else if (ch2 === _Jsep.OPAREN_CODE) {
        node = this.gobbleGroup();
      }
    }
    if (!node) {
      return this.runHook("after-token", false);
    }
    node = this.gobbleTokenProperty(node);
    return this.runHook("after-token", node);
  }
  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   * @param {jsep.Expression} node
   * @returns {jsep.Expression}
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch2 = this.code;
    while (ch2 === _Jsep.PERIOD_CODE || ch2 === _Jsep.OBRACK_CODE || ch2 === _Jsep.OPAREN_CODE || ch2 === _Jsep.QUMARK_CODE) {
      let optional;
      if (ch2 === _Jsep.QUMARK_CODE) {
        if (this.expr.charCodeAt(this.index + 1) !== _Jsep.PERIOD_CODE) {
          break;
        }
        optional = true;
        this.index += 2;
        this.gobbleSpaces();
        ch2 = this.code;
      }
      this.index++;
      if (ch2 === _Jsep.OBRACK_CODE) {
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: true,
          object: node,
          property: this.gobbleExpression()
        };
        if (!node.property) {
          this.throwError('Unexpected "' + this.char + '"');
        }
        this.gobbleSpaces();
        ch2 = this.code;
        if (ch2 !== _Jsep.CBRACK_CODE) {
          this.throwError("Unclosed [");
        }
        this.index++;
      } else if (ch2 === _Jsep.OPAREN_CODE) {
        node = {
          type: _Jsep.CALL_EXP,
          "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
          callee: node
        };
      } else if (ch2 === _Jsep.PERIOD_CODE || optional) {
        if (optional) {
          this.index--;
        }
        this.gobbleSpaces();
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: false,
          object: node,
          property: this.gobbleIdentifier()
        };
      }
      if (optional) {
        node.optional = true;
      }
      this.gobbleSpaces();
      ch2 = this.code;
    }
    return node;
  }
  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   * @returns {jsep.Literal}
   */
  gobbleNumericLiteral() {
    let number2 = "", ch2, chCode;
    while (_Jsep.isDecimalDigit(this.code)) {
      number2 += this.expr.charAt(this.index++);
    }
    if (this.code === _Jsep.PERIOD_CODE) {
      number2 += this.expr.charAt(this.index++);
      while (_Jsep.isDecimalDigit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
    }
    ch2 = this.char;
    if (ch2 === "e" || ch2 === "E") {
      number2 += this.expr.charAt(this.index++);
      ch2 = this.char;
      if (ch2 === "+" || ch2 === "-") {
        number2 += this.expr.charAt(this.index++);
      }
      while (_Jsep.isDecimalDigit(this.code)) {
        number2 += this.expr.charAt(this.index++);
      }
      if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
        this.throwError("Expected exponent (" + number2 + this.char + ")");
      }
    }
    chCode = this.code;
    if (_Jsep.isIdentifierStart(chCode)) {
      this.throwError("Variable names cannot start with a number (" + number2 + this.char + ")");
    } else if (chCode === _Jsep.PERIOD_CODE || number2.length === 1 && number2.charCodeAt(0) === _Jsep.PERIOD_CODE) {
      this.throwError("Unexpected period");
    }
    return {
      type: _Jsep.LITERAL,
      value: parseFloat(number2),
      raw: number2
    };
  }
  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   * @returns {jsep.Literal}
   */
  gobbleStringLiteral() {
    let str = "";
    const startIndex = this.index;
    const quote = this.expr.charAt(this.index++);
    let closed = false;
    while (this.index < this.expr.length) {
      let ch2 = this.expr.charAt(this.index++);
      if (ch2 === quote) {
        closed = true;
        break;
      } else if (ch2 === "\\") {
        ch2 = this.expr.charAt(this.index++);
        switch (ch2) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            str += ch2;
        }
      } else {
        str += ch2;
      }
    }
    if (!closed) {
      this.throwError('Unclosed quote after "' + str + '"');
    }
    return {
      type: _Jsep.LITERAL,
      value: str,
      raw: this.expr.substring(startIndex, this.index)
    };
  }
  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   * @returns {jsep.Identifier}
   */
  gobbleIdentifier() {
    let ch2 = this.code, start = this.index;
    if (_Jsep.isIdentifierStart(ch2)) {
      this.index++;
    } else {
      this.throwError("Unexpected " + this.char);
    }
    while (this.index < this.expr.length) {
      ch2 = this.code;
      if (_Jsep.isIdentifierPart(ch2)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: _Jsep.IDENTIFIER,
      name: this.expr.slice(start, this.index)
    };
  }
  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   * @param {number} termination
   * @returns {jsep.Expression[]}
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      let ch_i = this.code;
      if (ch_i === termination) {
        closed = true;
        this.index++;
        if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
          this.throwError("Unexpected token " + String.fromCharCode(termination));
        }
        break;
      } else if (ch_i === _Jsep.COMMA_CODE) {
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          if (termination === _Jsep.CPAREN_CODE) {
            this.throwError("Unexpected token ,");
          } else if (termination === _Jsep.CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              args.push(null);
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        this.throwError("Expected comma");
      } else {
        const node = this.gobbleExpression();
        if (!node || node.type === _Jsep.COMPOUND) {
          this.throwError("Expected comma");
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.throwError("Expected " + String.fromCharCode(termination));
    }
    return args;
  }
  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   * @returns {boolean|jsep.Expression}
   */
  gobbleGroup() {
    this.index++;
    let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
    if (this.code === _Jsep.CPAREN_CODE) {
      this.index++;
      if (nodes.length === 1) {
        return nodes[0];
      } else if (!nodes.length) {
        return false;
      } else {
        return {
          type: _Jsep.SEQUENCE_EXP,
          expressions: nodes
        };
      }
    } else {
      this.throwError("Unclosed (");
    }
  }
  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   * @returns {jsep.ArrayExpression}
   */
  gobbleArray() {
    this.index++;
    return {
      type: _Jsep.ARRAY_EXP,
      elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
    };
  }
};
var hooks = new Hooks();
Object.assign(Jsep, {
  hooks,
  plugins: new Plugins(Jsep),
  // Node Types
  // ----------
  // This is the full set of types that any JSEP node can be.
  // Store them here to save space when minified
  COMPOUND: "Compound",
  SEQUENCE_EXP: "SequenceExpression",
  IDENTIFIER: "Identifier",
  MEMBER_EXP: "MemberExpression",
  LITERAL: "Literal",
  THIS_EXP: "ThisExpression",
  CALL_EXP: "CallExpression",
  UNARY_EXP: "UnaryExpression",
  BINARY_EXP: "BinaryExpression",
  ARRAY_EXP: "ArrayExpression",
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  // '.'
  COMMA_CODE: 44,
  // ','
  SQUOTE_CODE: 39,
  // single quote
  DQUOTE_CODE: 34,
  // double quotes
  OPAREN_CODE: 40,
  // (
  CPAREN_CODE: 41,
  // )
  OBRACK_CODE: 91,
  // [
  CBRACK_CODE: 93,
  // ]
  QUMARK_CODE: 63,
  // ?
  SEMCOL_CODE: 59,
  // ;
  COLON_CODE: 58,
  // :
  // Operations
  // ----------
  // Use a quickly-accessible map to store all of the unary operators
  // Values are set to `1` (it really doesn't matter)
  unary_ops: {
    "-": 1,
    "!": 1,
    "~": 1,
    "+": 1
  },
  // Also use a map for the binary operations but set their values to their
  // binary precedence for quick reference (higher number = higher precedence)
  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
  binary_ops: {
    "||": 1,
    "??": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10,
    "**": 11
  },
  // sets specific binary_ops as right-associative
  right_associative: /* @__PURE__ */ new Set(["**"]),
  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
  additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
  // Literals
  // ----------
  // Store the values to return for the various literals we may encounter
  literals: {
    "true": true,
    "false": false,
    "null": null
  },
  // Except for `this`, which is special. This could be changed to something like `'self'` as well
  this_str: "this"
});
Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
var jsep = (expr) => new Jsep(expr).parse();
var stdClassProps = Object.getOwnPropertyNames(class Test {
});
Object.getOwnPropertyNames(Jsep).filter((prop) => !stdClassProps.includes(prop) && jsep[prop] === void 0).forEach((m) => {
  jsep[m] = Jsep[m];
});
jsep.Jsep = Jsep;
var CONDITIONAL_EXP = "ConditionalExpression";
var ternary = {
  name: "ternary",
  init(jsep2) {
    jsep2.hooks.add("after-expression", function gobbleTernary(env) {
      if (env.node && this.code === jsep2.QUMARK_CODE) {
        this.index++;
        const test2 = env.node;
        const consequent = this.gobbleExpression();
        if (!consequent) {
          this.throwError("Expected expression");
        }
        this.gobbleSpaces();
        if (this.code === jsep2.COLON_CODE) {
          this.index++;
          const alternate = this.gobbleExpression();
          if (!alternate) {
            this.throwError("Expected expression");
          }
          env.node = {
            type: CONDITIONAL_EXP,
            test: test2,
            consequent,
            alternate
          };
          if (test2.operator && jsep2.binary_ops[test2.operator] <= 0.9) {
            let newTest = test2;
            while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
              newTest = newTest.right;
            }
            env.node.test = newTest.right;
            newTest.right = env.node;
            env.node = test2;
          }
        } else {
          this.throwError("Expected :");
        }
      }
    });
  }
};
jsep.plugins.register(ternary);
var FSLASH_CODE = 47;
var BSLASH_CODE = 92;
var index = {
  name: "regex",
  init(jsep2) {
    jsep2.hooks.add("gobble-token", function gobbleRegexLiteral(env) {
      if (this.code === FSLASH_CODE) {
        const patternIndex = ++this.index;
        let inCharSet = false;
        while (this.index < this.expr.length) {
          if (this.code === FSLASH_CODE && !inCharSet) {
            const pattern = this.expr.slice(patternIndex, this.index);
            let flags = "";
            while (++this.index < this.expr.length) {
              const code = this.code;
              if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
                flags += this.char;
              } else {
                break;
              }
            }
            let value;
            try {
              value = new RegExp(pattern, flags);
            } catch (e2) {
              this.throwError(e2.message);
            }
            env.node = {
              type: jsep2.LITERAL,
              value,
              raw: this.expr.slice(patternIndex - 1, this.index)
            };
            env.node = this.gobbleTokenProperty(env.node);
            return env.node;
          }
          if (this.code === jsep2.OBRACK_CODE) {
            inCharSet = true;
          } else if (inCharSet && this.code === jsep2.CBRACK_CODE) {
            inCharSet = false;
          }
          this.index += this.code === BSLASH_CODE ? 2 : 1;
        }
        this.throwError("Unclosed Regex");
      }
    });
  }
};
var PLUS_CODE = 43;
var MINUS_CODE = 45;
var plugin = {
  name: "assignment",
  assignmentOperators: /* @__PURE__ */ new Set(["=", "*=", "**=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "||=", "&&=", "??="]),
  updateOperators: [PLUS_CODE, MINUS_CODE],
  assignmentPrecedence: 0.9,
  init(jsep2) {
    const updateNodeTypes = [jsep2.IDENTIFIER, jsep2.MEMBER_EXP];
    plugin.assignmentOperators.forEach((op2) => jsep2.addBinaryOp(op2, plugin.assignmentPrecedence, true));
    jsep2.hooks.add("gobble-token", function gobbleUpdatePrefix(env) {
      const code = this.code;
      if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
        this.index += 2;
        env.node = {
          type: "UpdateExpression",
          operator: code === PLUS_CODE ? "++" : "--",
          argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
          prefix: true
        };
        if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {
          this.throwError(`Unexpected ${env.node.operator}`);
        }
      }
    });
    jsep2.hooks.add("after-token", function gobbleUpdatePostfix(env) {
      if (env.node) {
        const code = this.code;
        if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
          if (!updateNodeTypes.includes(env.node.type)) {
            this.throwError(`Unexpected ${env.node.operator}`);
          }
          this.index += 2;
          env.node = {
            type: "UpdateExpression",
            operator: code === PLUS_CODE ? "++" : "--",
            argument: env.node,
            prefix: false
          };
        }
      }
    });
    jsep2.hooks.add("after-expression", function gobbleAssignment(env) {
      if (env.node) {
        updateBinariesToAssignments(env.node);
      }
    });
    function updateBinariesToAssignments(node) {
      if (plugin.assignmentOperators.has(node.operator)) {
        node.type = "AssignmentExpression";
        updateBinariesToAssignments(node.left);
        updateBinariesToAssignments(node.right);
      } else if (!node.operator) {
        Object.values(node).forEach((val) => {
          if (val && typeof val === "object") {
            updateBinariesToAssignments(val);
          }
        });
      }
    }
  }
};
jsep.plugins.register(index, plugin);
jsep.addUnaryOp("typeof");
jsep.addLiteral("null", null);
jsep.addLiteral("undefined", void 0);
var BLOCKED_PROTO_PROPERTIES = /* @__PURE__ */ new Set(["constructor", "__proto__", "__defineGetter__", "__defineSetter__"]);
var SafeEval = {
  /**
   * @param {jsep.Expression} ast
   * @param {Record<string, any>} subs
   */
  evalAst(ast, subs) {
    switch (ast.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        return SafeEval.evalBinaryExpression(ast, subs);
      case "Compound":
        return SafeEval.evalCompound(ast, subs);
      case "ConditionalExpression":
        return SafeEval.evalConditionalExpression(ast, subs);
      case "Identifier":
        return SafeEval.evalIdentifier(ast, subs);
      case "Literal":
        return SafeEval.evalLiteral(ast, subs);
      case "MemberExpression":
        return SafeEval.evalMemberExpression(ast, subs);
      case "UnaryExpression":
        return SafeEval.evalUnaryExpression(ast, subs);
      case "ArrayExpression":
        return SafeEval.evalArrayExpression(ast, subs);
      case "CallExpression":
        return SafeEval.evalCallExpression(ast, subs);
      case "AssignmentExpression":
        return SafeEval.evalAssignmentExpression(ast, subs);
      default:
        throw SyntaxError("Unexpected expression", ast);
    }
  },
  evalBinaryExpression(ast, subs) {
    const result2 = {
      "||": (a2, b) => a2 || b(),
      "&&": (a2, b) => a2 && b(),
      "|": (a2, b) => a2 | b(),
      "^": (a2, b) => a2 ^ b(),
      "&": (a2, b) => a2 & b(),
      // eslint-disable-next-line eqeqeq -- API
      "==": (a2, b) => a2 == b(),
      // eslint-disable-next-line eqeqeq -- API
      "!=": (a2, b) => a2 != b(),
      "===": (a2, b) => a2 === b(),
      "!==": (a2, b) => a2 !== b(),
      "<": (a2, b) => a2 < b(),
      ">": (a2, b) => a2 > b(),
      "<=": (a2, b) => a2 <= b(),
      ">=": (a2, b) => a2 >= b(),
      "<<": (a2, b) => a2 << b(),
      ">>": (a2, b) => a2 >> b(),
      ">>>": (a2, b) => a2 >>> b(),
      "+": (a2, b) => a2 + b(),
      "-": (a2, b) => a2 - b(),
      "*": (a2, b) => a2 * b(),
      "/": (a2, b) => a2 / b(),
      "%": (a2, b) => a2 % b()
    }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));
    return result2;
  },
  evalCompound(ast, subs) {
    let last3;
    for (let i2 = 0; i2 < ast.body.length; i2++) {
      if (ast.body[i2].type === "Identifier" && ["var", "let", "const"].includes(ast.body[i2].name) && ast.body[i2 + 1] && ast.body[i2 + 1].type === "AssignmentExpression") {
        i2 += 1;
      }
      const expr = ast.body[i2];
      last3 = SafeEval.evalAst(expr, subs);
    }
    return last3;
  },
  evalConditionalExpression(ast, subs) {
    if (SafeEval.evalAst(ast.test, subs)) {
      return SafeEval.evalAst(ast.consequent, subs);
    }
    return SafeEval.evalAst(ast.alternate, subs);
  },
  evalIdentifier(ast, subs) {
    if (Object.hasOwn(subs, ast.name)) {
      return subs[ast.name];
    }
    throw ReferenceError(`${ast.name} is not defined`);
  },
  evalLiteral(ast) {
    return ast.value;
  },
  evalMemberExpression(ast, subs) {
    const prop = String(
      // NOTE: `String(value)` throws error when
      // value has overwritten the toString method to return non-string
      // i.e. `value = {toString: () => []}`
      ast.computed ? SafeEval.evalAst(ast.property) : ast.property.name
      // `object.property` property is Identifier
    );
    const obj = SafeEval.evalAst(ast.object, subs);
    if (obj === void 0 || obj === null) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {
      throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
    }
    const result2 = obj[prop];
    if (typeof result2 === "function") {
      return result2.bind(obj);
    }
    return result2;
  },
  evalUnaryExpression(ast, subs) {
    const result2 = {
      "-": (a2) => -SafeEval.evalAst(a2, subs),
      "!": (a2) => !SafeEval.evalAst(a2, subs),
      "~": (a2) => ~SafeEval.evalAst(a2, subs),
      // eslint-disable-next-line no-implicit-coercion -- API
      "+": (a2) => +SafeEval.evalAst(a2, subs),
      typeof: (a2) => typeof SafeEval.evalAst(a2, subs)
    }[ast.operator](ast.argument);
    return result2;
  },
  evalArrayExpression(ast, subs) {
    return ast.elements.map((el2) => SafeEval.evalAst(el2, subs));
  },
  evalCallExpression(ast, subs) {
    const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));
    const func = SafeEval.evalAst(ast.callee, subs);
    return func(...args);
  },
  evalAssignmentExpression(ast, subs) {
    if (ast.left.type !== "Identifier") {
      throw SyntaxError("Invalid left-hand side in assignment");
    }
    const id2 = ast.left.name;
    const value = SafeEval.evalAst(ast.right, subs);
    subs[id2] = value;
    return subs[id2];
  }
};
var SafeScript = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
    this.ast = jsep(this.code);
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    const keyMap = Object.assign(/* @__PURE__ */ Object.create(null), context);
    return SafeEval.evalAst(this.ast, keyMap);
  }
};
function push(arr, item) {
  arr = arr.slice();
  arr.push(item);
  return arr;
}
function unshift(item, arr) {
  arr = arr.slice();
  arr.unshift(item);
  return arr;
}
var NewError = class extends Error {
  /**
   * @param {AnyResult} value The evaluated scalar value
   */
  constructor(value) {
    super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
    this.avoidNew = true;
    this.value = value;
    this.name = "NewError";
  }
};
function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
  if (!(this instanceof JSONPath)) {
    try {
      return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
    } catch (e2) {
      if (!e2.avoidNew) {
        throw e2;
      }
      return e2.value;
    }
  }
  if (typeof opts === "string") {
    otherTypeCallback = callback;
    callback = obj;
    obj = expr;
    expr = opts;
    opts = null;
  }
  const optObj = opts && typeof opts === "object";
  opts = opts || {};
  this.json = opts.json || obj;
  this.path = opts.path || expr;
  this.resultType = opts.resultType || "value";
  this.flatten = opts.flatten || false;
  this.wrap = Object.hasOwn(opts, "wrap") ? opts.wrap : true;
  this.sandbox = opts.sandbox || {};
  this.eval = opts.eval === void 0 ? "safe" : opts.eval;
  this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === "undefined" ? false : opts.ignoreEvalErrors;
  this.parent = opts.parent || null;
  this.parentProperty = opts.parentProperty || null;
  this.callback = opts.callback || callback || null;
  this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
    throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
  };
  if (opts.autostart !== false) {
    const args = {
      path: optObj ? opts.path : expr
    };
    if (!optObj) {
      args.json = obj;
    } else if ("json" in opts) {
      args.json = opts.json;
    }
    const ret = this.evaluate(args);
    if (!ret || typeof ret !== "object") {
      throw new NewError(ret);
    }
    return ret;
  }
}
JSONPath.prototype.evaluate = function(expr, json2, callback, otherTypeCallback) {
  let currParent = this.parent, currParentProperty = this.parentProperty;
  let {
    flatten: flatten3,
    wrap: wrap2
  } = this;
  this.currResultType = this.resultType;
  this.currEval = this.eval;
  this.currSandbox = this.sandbox;
  callback = callback || this.callback;
  this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
  json2 = json2 || this.json;
  expr = expr || this.path;
  if (expr && typeof expr === "object" && !Array.isArray(expr)) {
    if (!expr.path && expr.path !== "") {
      throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
    }
    if (!Object.hasOwn(expr, "json")) {
      throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
    }
    ({
      json: json2
    } = expr);
    flatten3 = Object.hasOwn(expr, "flatten") ? expr.flatten : flatten3;
    this.currResultType = Object.hasOwn(expr, "resultType") ? expr.resultType : this.currResultType;
    this.currSandbox = Object.hasOwn(expr, "sandbox") ? expr.sandbox : this.currSandbox;
    wrap2 = Object.hasOwn(expr, "wrap") ? expr.wrap : wrap2;
    this.currEval = Object.hasOwn(expr, "eval") ? expr.eval : this.currEval;
    callback = Object.hasOwn(expr, "callback") ? expr.callback : callback;
    this.currOtherTypeCallback = Object.hasOwn(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
    currParent = Object.hasOwn(expr, "parent") ? expr.parent : currParent;
    currParentProperty = Object.hasOwn(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
    expr = expr.path;
  }
  currParent = currParent || null;
  currParentProperty = currParentProperty || null;
  if (Array.isArray(expr)) {
    expr = JSONPath.toPathString(expr);
  }
  if (!expr && expr !== "" || !json2) {
    return void 0;
  }
  const exprList = JSONPath.toPathArray(expr);
  if (exprList[0] === "$" && exprList.length > 1) {
    exprList.shift();
  }
  this._hasParentSelector = null;
  const result2 = this._trace(exprList, json2, ["$"], currParent, currParentProperty, callback).filter(function(ea2) {
    return ea2 && !ea2.isParentSelector;
  });
  if (!result2.length) {
    return wrap2 ? [] : void 0;
  }
  if (!wrap2 && result2.length === 1 && !result2[0].hasArrExpr) {
    return this._getPreferredOutput(result2[0]);
  }
  return result2.reduce((rslt, ea2) => {
    const valOrPath = this._getPreferredOutput(ea2);
    if (flatten3 && Array.isArray(valOrPath)) {
      rslt = rslt.concat(valOrPath);
    } else {
      rslt.push(valOrPath);
    }
    return rslt;
  }, []);
};
JSONPath.prototype._getPreferredOutput = function(ea2) {
  const resultType = this.currResultType;
  switch (resultType) {
    case "all": {
      const path = Array.isArray(ea2.path) ? ea2.path : JSONPath.toPathArray(ea2.path);
      ea2.pointer = JSONPath.toPointer(path);
      ea2.path = typeof ea2.path === "string" ? ea2.path : JSONPath.toPathString(ea2.path);
      return ea2;
    }
    case "value":
    case "parent":
    case "parentProperty":
      return ea2[resultType];
    case "path":
      return JSONPath.toPathString(ea2[resultType]);
    case "pointer":
      return JSONPath.toPointer(ea2.path);
    default:
      throw new TypeError("Unknown result type");
  }
};
JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
  if (callback) {
    const preferredOutput = this._getPreferredOutput(fullRetObj);
    fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
    callback(preferredOutput, type, fullRetObj);
  }
};
JSONPath.prototype._trace = function(expr, val, path, parent2, parentPropName, callback, hasArrExpr, literalPriority) {
  let retObj;
  if (!expr.length) {
    retObj = {
      path,
      value: val,
      parent: parent2,
      parentProperty: parentPropName,
      hasArrExpr
    };
    this._handleCallback(retObj, callback, "value");
    return retObj;
  }
  const loc = expr[0], x = expr.slice(1);
  const ret = [];
  function addRet(elems) {
    if (Array.isArray(elems)) {
      elems.forEach((t3) => {
        ret.push(t3);
      });
    } else {
      ret.push(elems);
    }
  }
  if ((typeof loc !== "string" || literalPriority) && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
  } else if (loc === "*") {
    this._walk(val, (m) => {
      addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));
    });
  } else if (loc === "..") {
    addRet(this._trace(x, val, path, parent2, parentPropName, callback, hasArrExpr));
    this._walk(val, (m) => {
      if (typeof val[m] === "object") {
        addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));
      }
    });
  } else if (loc === "^") {
    this._hasParentSelector = true;
    return {
      path: path.slice(0, -1),
      expr: x,
      isParentSelector: true
    };
  } else if (loc === "~") {
    retObj = {
      path: push(path, loc),
      value: parentPropName,
      parent: parent2,
      parentProperty: null
    };
    this._handleCallback(retObj, callback, "property");
    return retObj;
  } else if (loc === "$") {
    addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
  } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
    addRet(this._slice(loc, x, val, path, parent2, parentPropName, callback));
  } else if (loc.indexOf("?(") === 0) {
    if (this.currEval === false) {
      throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
    }
    const safeLoc = loc.replace(/^\?\((.*?)\)$/u, "$1");
    const nested = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(safeLoc);
    if (nested) {
      this._walk(val, (m) => {
        const npath = [nested[2]];
        const nvalue = nested[1] ? val[m][nested[1]] : val[m];
        const filterResults = this._trace(npath, nvalue, path, parent2, parentPropName, callback, true);
        if (filterResults.length > 0) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    } else {
      this._walk(val, (m) => {
        if (this._eval(safeLoc, val[m], m, path, parent2, parentPropName)) {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
        }
      });
    }
  } else if (loc[0] === "(") {
    if (this.currEval === false) {
      throw new Error("Eval [(expr)] prevented in JSONPath expression.");
    }
    addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent2, parentPropName), x), val, path, parent2, parentPropName, callback, hasArrExpr));
  } else if (loc[0] === "@") {
    let addType = false;
    const valueType = loc.slice(1, -2);
    switch (valueType) {
      case "scalar":
        if (!val || !["object", "function"].includes(typeof val)) {
          addType = true;
        }
        break;
      case "boolean":
      case "string":
      case "undefined":
      case "function":
        if (typeof val === valueType) {
          addType = true;
        }
        break;
      case "integer":
        if (Number.isFinite(val) && !(val % 1)) {
          addType = true;
        }
        break;
      case "number":
        if (Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "nonFinite":
        if (typeof val === "number" && !Number.isFinite(val)) {
          addType = true;
        }
        break;
      case "object":
        if (val && typeof val === valueType) {
          addType = true;
        }
        break;
      case "array":
        if (Array.isArray(val)) {
          addType = true;
        }
        break;
      case "other":
        addType = this.currOtherTypeCallback(val, path, parent2, parentPropName);
        break;
      case "null":
        if (val === null) {
          addType = true;
        }
        break;
      /* c8 ignore next 2 */
      default:
        throw new TypeError("Unknown value type " + valueType);
    }
    if (addType) {
      retObj = {
        path,
        value: val,
        parent: parent2,
        parentProperty: parentPropName
      };
      this._handleCallback(retObj, callback, "value");
      return retObj;
    }
  } else if (loc[0] === "`" && val && Object.hasOwn(val, loc.slice(1))) {
    const locProp = loc.slice(1);
    addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
  } else if (loc.includes(",")) {
    const parts = loc.split(",");
    for (const part of parts) {
      addRet(this._trace(unshift(part, x), val, path, parent2, parentPropName, callback, true));
    }
  } else if (!literalPriority && val && Object.hasOwn(val, loc)) {
    addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
  }
  if (this._hasParentSelector) {
    for (let t3 = 0; t3 < ret.length; t3++) {
      const rett = ret[t3];
      if (rett && rett.isParentSelector) {
        const tmp = this._trace(rett.expr, val, rett.path, parent2, parentPropName, callback, hasArrExpr);
        if (Array.isArray(tmp)) {
          ret[t3] = tmp[0];
          const tl2 = tmp.length;
          for (let tt3 = 1; tt3 < tl2; tt3++) {
            t3++;
            ret.splice(t3, 0, tmp[tt3]);
          }
        } else {
          ret[t3] = tmp;
        }
      }
    }
  }
  return ret;
};
JSONPath.prototype._walk = function(val, f) {
  if (Array.isArray(val)) {
    const n2 = val.length;
    for (let i2 = 0; i2 < n2; i2++) {
      f(i2);
    }
  } else if (val && typeof val === "object") {
    Object.keys(val).forEach((m) => {
      f(m);
    });
  }
};
JSONPath.prototype._slice = function(loc, expr, val, path, parent2, parentPropName, callback) {
  if (!Array.isArray(val)) {
    return void 0;
  }
  const len = val.length, parts = loc.split(":"), step = parts[2] && Number.parseInt(parts[2]) || 1;
  let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
  start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
  end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
  const ret = [];
  for (let i2 = start; i2 < end; i2 += step) {
    const tmp = this._trace(unshift(i2, expr), val, path, parent2, parentPropName, callback, true);
    tmp.forEach((t3) => {
      ret.push(t3);
    });
  }
  return ret;
};
JSONPath.prototype._eval = function(code, _v2, _vname, path, parent2, parentPropName) {
  this.currSandbox._$_parentProperty = parentPropName;
  this.currSandbox._$_parent = parent2;
  this.currSandbox._$_property = _vname;
  this.currSandbox._$_root = this.json;
  this.currSandbox._$_v = _v2;
  const containsPath = code.includes("@path");
  if (containsPath) {
    this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
  }
  const scriptCacheKey = this.currEval + "Script:" + code;
  if (!JSONPath.cache[scriptCacheKey]) {
    let script = code.replaceAll("@parentProperty", "_$_parentProperty").replaceAll("@parent", "_$_parent").replaceAll("@property", "_$_property").replaceAll("@root", "_$_root").replaceAll(/@([.\s)[])/gu, "_$_v$1");
    if (containsPath) {
      script = script.replaceAll("@path", "_$_path");
    }
    if (this.currEval === "safe" || this.currEval === true || this.currEval === void 0) {
      JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);
    } else if (this.currEval === "native") {
      JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);
    } else if (typeof this.currEval === "function" && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, "runInNewContext")) {
      const CurrEval = this.currEval;
      JSONPath.cache[scriptCacheKey] = new CurrEval(script);
    } else if (typeof this.currEval === "function") {
      JSONPath.cache[scriptCacheKey] = {
        runInNewContext: (context) => this.currEval(script, context)
      };
    } else {
      throw new TypeError(`Unknown "eval" property "${this.currEval}"`);
    }
  }
  try {
    return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
  } catch (e2) {
    if (this.ignoreEvalErrors) {
      return false;
    }
    throw new Error("jsonPath: " + e2.message + ": " + code);
  }
};
JSONPath.cache = {};
JSONPath.toPathString = function(pathArr) {
  const x = pathArr, n2 = x.length;
  let p2 = "$";
  for (let i2 = 1; i2 < n2; i2++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i2])) {
      p2 += /^[0-9*]+$/u.test(x[i2]) ? "[" + x[i2] + "]" : "['" + x[i2] + "']";
    }
  }
  return p2;
};
JSONPath.toPointer = function(pointer) {
  const x = pointer, n2 = x.length;
  let p2 = "";
  for (let i2 = 1; i2 < n2; i2++) {
    if (!/^(~|\^|@.*?\(\))$/u.test(x[i2])) {
      p2 += "/" + x[i2].toString().replaceAll("~", "~0").replaceAll("/", "~1");
    }
  }
  return p2;
};
JSONPath.toPathArray = function(expr) {
  const {
    cache
  } = JSONPath;
  if (cache[expr]) {
    return cache[expr].concat();
  }
  const subx = [];
  const normalized = expr.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function($0, $1) {
    return "[#" + (subx.push($1) - 1) + "]";
  }).replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
    return "['" + prop.replaceAll(".", "%@%").replaceAll("~", "%%@@%%") + "']";
  }).replaceAll("~", ";~;").replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replaceAll("%@%", ".").replaceAll("%%@@%%", "~").replaceAll(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
    return ";" + ups.split("").join(";") + ";";
  }).replaceAll(/;;;|;;/gu, ";..;").replaceAll(/;$|'?\]|'$/gu, "");
  const exprList = normalized.split(";").map(function(exp) {
    const match = exp.match(/#(\d+)/u);
    return !match || !match[1] ? exp : subx[match[1]];
  });
  cache[expr] = exprList;
  return cache[expr].concat();
};
JSONPath.prototype.safeVm = {
  Script: SafeScript
};
var moveToAnotherArray = function(source, target, conditionCb) {
  const il2 = source.length;
  for (let i2 = 0; i2 < il2; i2++) {
    const item = source[i2];
    if (conditionCb(item)) {
      target.push(source.splice(i2--, 1)[0]);
    }
  }
};
var Script = class {
  /**
   * @param {string} expr Expression to evaluate
   */
  constructor(expr) {
    this.code = expr;
  }
  /**
   * @param {object} context Object whose items will be added
   *   to evaluation
   * @returns {EvaluatedResult} Result of evaluated code
   */
  runInNewContext(context) {
    let expr = this.code;
    const keys3 = Object.keys(context);
    const funcs = [];
    moveToAnotherArray(keys3, funcs, (key) => {
      return typeof context[key] === "function";
    });
    const values2 = keys3.map((vr2) => {
      return context[vr2];
    });
    const funcString = funcs.reduce((s2, func) => {
      let fString = context[func].toString();
      if (!/function/u.test(fString)) {
        fString = "function " + fString;
      }
      return "var " + func + "=" + fString + ";" + s2;
    }, "");
    expr = funcString + expr;
    if (!/(['"])use strict\1/u.test(expr) && !keys3.includes("arguments")) {
      expr = "var arguments = undefined;" + expr;
    }
    expr = expr.replace(/;\s*$/u, "");
    const lastStatementEnd = expr.lastIndexOf(";");
    const code = lastStatementEnd !== -1 ? expr.slice(0, lastStatementEnd + 1) + " return " + expr.slice(lastStatementEnd + 1) : " return " + expr;
    return new Function(...keys3, code)(...values2);
  }
};
JSONPath.prototype.vm = {
  Script
};

// node_modules/@marijn/find-cluster-break/src/index.js
var rangeFrom = [];
var rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
  for (let i2 = 0, n2 = 0; i2 < numbers.length; i2++) (i2 % 2 ? rangeTo : rangeFrom).push(n2 = n2 + numbers[i2]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to2 = rangeFrom.length; ; ) {
    let mid = from + to2 >> 1;
    if (code < rangeFrom[mid]) to2 = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to2) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i2 = pos - 2;
      while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
        countBefore++;
        i2 -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch2) {
  return ch2 >= 56320 && ch2 < 57344;
}
function surrogateHigh(ch2) {
  return ch2 >= 55296 && ch2 < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}

// node_modules/@codemirror/state/dist/index.js
var Text2 = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n2) {
    if (n2 < 1 || n2 > this.lines) throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
    return this.lineInner(n2, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to2, text) {
    [from, to2] = clip(this, from, to2);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length) text.decompose(
      0,
      text.length,
      parts,
      1 | 2
      /* Open.To */
    );
    this.decompose(
      to2,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to2 - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to2 = this.length) {
    [from, to2] = clip(this, from, to2);
    let parts = [];
    this.decompose(from, to2, parts, 0);
    return TextNode.from(parts, to2 - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this) return true;
    if (other.length != this.length || other.lines != this.lines) return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a2 = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a2.next(skip);
      b.next(skip);
      skip = 0;
      if (a2.lineBreak != b.lineBreak || a2.done != b.done || a2.value != b.value) return false;
      pos += a2.value.length;
      if (a2.done || pos >= end) return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to2 = this.length) {
    return new PartialTextCursor(this, from, to2);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to2) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to2 == null) to2 = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0) throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0]) return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text2 {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let string2 = this.text[i2], end = offset + string2.length;
      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to2, target, open) {
    let text = from <= 0 && to2 >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to2), Math.min(to2, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to2, text) {
    if (!(text instanceof _TextLeaf)) return super.replace(from, to2, text);
    [from, to2] = clip(this, from, to2);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to2);
    let newLen = this.length + text.length - (to2 - from);
    if (lines.length <= 32) return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to2 = this.length, lineSep = "\n") {
    [from, to2] = clip(this, from, to2);
    let result2 = "";
    for (let pos = 0, i2 = 0; pos <= to2 && i2 < this.text.length; i2++) {
      let line = this.text[i2], end = pos + line.length;
      if (pos > from && i2) result2 += lineSep;
      if (from < end && to2 > pos) result2 += line.slice(Math.max(0, from - pos), to2 - pos);
      pos = end + 1;
    }
    return result2;
  }
  flatten(target) {
    for (let line of this.text) target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1) target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text2 {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children) this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to2, target, open) {
    for (let i2 = 0, pos = 0; pos <= to2 && i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (from <= end && to2 >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to2 ? 2 : 0));
        if (pos >= from && end <= to2 && !childOpen) target.push(child);
        else child.decompose(from - pos, to2 - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to2, text) {
    [from, to2] = clip(this, from, to2);
    if (text.lines < this.lines) for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (from >= pos && to2 <= end) {
        let updated = child.replace(from - pos, to2 - pos, text);
        let totalLines = this.lines - child.lines + updated.lines;
        if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
          let copy2 = this.children.slice();
          copy2[i2] = updated;
          return new _TextNode(copy2, this.length - (to2 - from) + text.length);
        }
        return super.replace(pos, end, updated);
      }
      pos = end + 1;
    }
    return super.replace(from, to2, text);
  }
  sliceString(from, to2 = this.length, lineSep = "\n") {
    [from, to2] = clip(this, from, to2);
    let result2 = "";
    for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to2; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos > from && i2) result2 += lineSep;
      if (from < end && to2 > pos) result2 += child.sliceString(from - pos, to2 - pos, lineSep);
      pos = end + 1;
    }
    return result2;
  }
  flatten(target) {
    for (let child of this.children) child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode)) return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB) return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB) return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch2) => l + ch2.length + 1, -1)) {
    let lines = 0;
    for (let ch2 of children) lines += ch2.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch2 of children) ch2.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk2 = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk2 << 1, minChunk = chunk2 >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add4(child) {
      let last3;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children) add4(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last3 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last3.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last3.text.concat(child.text), last3.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk2) flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0) return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children) add4(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text2.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text) length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to2 = 1e9) {
  for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to2; i2++) {
    let line = text[i2], end = pos + line.length;
    if (end >= from) {
      if (end > to2) line = line.slice(0, to2 - pos);
      if (pos < from) line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to2) {
  return appendText(text, [""], from, to2);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last3 = this.nodes.length - 1;
      let top2 = this.nodes[last3], offsetValue = this.offsets[last3], offset = offsetValue >> 1;
      let size2 = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size2 : 0)) {
        if (last3 == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0) this.offsets[last3 - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last3] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last3] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last3] += dir;
        } else {
          if (dir < 0) this.offsets[last3]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit) skip = limit;
    limit -= skip;
    let {
      value
    } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0) skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let {
      done,
      lineBreak,
      value
    } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text2.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to2, number2, text) {
    this.from = from;
    this.to = to2;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from, to2) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to2))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch2) {
  return ch2 >= 56320 && ch2 < 57344;
}
function surrogateHigh2(ch2) {
  return ch2 >= 55296 && ch2 < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535) return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result2 = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) result2 += this.sections[i2];
    return result2;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result2 = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let ins = this.sections[i2 + 1];
      result2 += ins < 0 ? this.sections[i2] : ins;
    }
    return result2;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) sections.push(len, ins);
      else sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before2 = false) {
    return other.empty ? this : mapSet(this, other, before2);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos) return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to2 = from) {
    for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to2; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
      if (ins >= 0 && pos <= to2 && end >= from) return pos < from && end > to2 ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result2 = "";
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      result2 += (result2 ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result2;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a2) => typeof a2 != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json2);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length) throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before2 = false) {
    return mapSet(this, other, before2, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
      let len = sections[i2], ins = sections[i2 + 1];
      if (ins >= 0) {
        sections[i2] = ins;
        sections[i2 + 1] = len;
        let index2 = i2 >> 1;
        while (inserted.length < index2) inserted.push(Text2.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text2.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before2 = false) {
    return other.empty ? this : mapSet(this, other, before2, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i2 = 0, pos = 0; ; ) {
      let next = i2 == ranges.length ? 1e9 : ranges[i2++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done) break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i2++];
      while (pos < end) {
        if (iter.done) break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let len = this.sections[i2], ins = this.sections[i2 + 1];
      if (ins < 0) parts.push(len);
      else if (ins == 0) parts.push([len]);
      else parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length) return;
      if (pos < length) addSection(sections, length - pos, -1);
      let set2 = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec) process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let {
          from,
          to: to2 = from,
          insert: insert2
        } = spec;
        if (from > to2 || from < 0 || to2 > length) throw new RangeError(`Invalid change range ${from} to ${to2} (in doc of length ${length})`);
        let insText = !insert2 ? Text2.empty : typeof insert2 == "string" ? Text2.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to2 && insLen == 0) return;
        if (from < pos) flush();
        if (from > pos) addSection(sections, from - pos, -1);
        addSection(sections, to2 - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to2;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2)) throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i2 = 0; i2 < json2.length; i2++) {
      let part = json2[i2];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i2) inserted.push(Text2.empty);
        inserted[i2] = Text2.of(part.slice(1));
        sections.push(part[0], inserted[i2].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0) return;
  let last3 = sections.length - 2;
  if (last3 >= 0 && ins <= 0 && ins == sections[last3 + 1]) sections[last3] += len;
  else if (last3 >= 0 && len == 0 && sections[last3] == 0) sections[last3 + 1] += ins;
  else if (forceJoin) {
    sections[last3] += len;
    sections[last3 + 1] += ins;
  } else sections.push(len, ins);
}
function addInsert(values2, sections, value) {
  if (value.length == 0) return;
  let index2 = sections.length - 2 >> 1;
  if (index2 < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index2) values2.push(Text2.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
    let len = desc.sections[i2++], ins = desc.sections[i2++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text2.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted) text = text.append(inserted[i2 - 2 >> 1]);
        if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0) break;
        len = desc.sections[i2++];
        ins = desc.sections[i2++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before2, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a2.done && b.len || b.done && a2.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a2.ins == -1 && b.ins == -1) {
      let len = Math.min(a2.len, b.len);
      addSection(sections, len, -1);
      a2.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b.len < a2.len || b.len == a2.len && !before2))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a2.len, len);
        if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
          addSection(sections, 0, a2.ins);
          if (insert2) addInsert(insert2, sections, a2.text);
          inserted = a2.i;
        }
        a2.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a2.ins >= 0) {
      let len = 0, left = a2.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a2.i ? a2.ins : 0);
      if (insert2 && inserted < a2.i) addInsert(insert2, sections, a2.text);
      inserted = a2.i;
      a2.forward(a2.len - left);
    } else if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a2.ins == 0) {
      addSection(sections, a2.len, 0, open);
      a2.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2) addInsert(insert2, sections, b.text);
      b.next();
    } else if (a2.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a2.len2, b.len), sectionLen = sections.length;
      if (a2.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB) addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a2.off ? 0 : a2.len, len, open);
        if (insert2) addInsert(insert2, sections, a2.textBit(len));
      } else {
        addSection(sections, a2.off ? 0 : a2.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off) addInsert(insert2, sections, b.text);
      }
      open = (a2.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a2.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let {
      sections
    } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let {
      inserted
    } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text2.empty : inserted[index2];
  }
  textBit(len) {
    let {
      inserted
    } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text2.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len) this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1) this.forward(len);
    else if (len == this.ins) this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to2, flags) {
    this.from = from;
    this.to = to2;
    this.flags = flags;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to2;
    if (this.empty) {
      from = to2 = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to2 = change.mapPos(this.to, -1);
    }
    return from == this.from && to2 == this.to ? this : new _SelectionRange(from, to2, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to2 = from) {
    if (from <= this.anchor && to2 >= this.anchor) return EditorSelection.range(from, to2);
    let head2 = Math.abs(from - this.anchor) > Math.abs(to2 - this.anchor) ? from : to2;
    return EditorSelection.range(this.anchor, head2);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return {
      anchor: this.anchor,
      head: this.head
    };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  /**
  @internal
  */
  static create(from, to2, flags) {
    return new _SelectionRange(from, to2, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty) return this;
    return _EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++) if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc)) return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range2, main = true) {
    return _EditorSelection.create([range2].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range2, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range2;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return {
      ranges: this.ranges.map((r2) => r2.toJSON()),
      main: this.mainIndex
    };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json2.ranges.map((r2) => SelectionRange.fromJSON(r2)), json2.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head2 = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head2)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
      let range2 = ranges[i2];
      if (range2.empty ? range2.from <= pos : range2.from < pos) return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range2.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(
      pos,
      pos,
      (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6
      /* RangeFlag.GoalColumnOffset */
    );
  }
  /**
  Create a selection range.
  */
  static range(anchor, head2, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head2 < anchor ? SelectionRange.create(head2, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head2, (head2 > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a2, b) => a2.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i2 = 1; i2 < ranges.length; i2++) {
      let range2 = ranges[i2], prev = ranges[i2 - 1];
      if (range2.empty ? range2.from <= prev.to : range2.from < prev.to) {
        let from = prev.from, to2 = Math.max(range2.to, prev.to);
        if (i2 <= mainIndex) mainIndex--;
        ranges.splice(--i2, 2, range2.anchor > range2.head ? _EditorSelection.range(to2, from) : _EditorSelection.range(from, to2));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection, docLength) {
  for (let range2 of selection.ranges) if (range2.to > docLength) throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b) => a2 === b), config2.compare || (!config2.combine ? sameArray : (a2, b) => a2 === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get2) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get2);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get2) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get2);
  }
  from(field, get2) {
    if (!get2) get2 = (x) => x;
    return this.compute([field], (state) => get2(state.field(field)));
  }
};
function sameArray(a2, b) {
  return a2 == b || a2.length == b.length && a2.every((e2, i2) => e2 === b[i2]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a3;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc") depDoc = true;
      else if (dep == "selection") depSel = true;
      else if ((((_a3 = addresses[dep.id]) !== null && _a3 !== void 0 ? _a3 : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr2) {
        if (depDoc && tr2.docChanged || depSel && (tr2.docChanged || tr2.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a2, b, compare2) {
  if (a2.length != b.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) if (!compare2(a2[i2], b[i2])) return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs) if (ensureAddr(state, addr) & 1) changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p2) => addresses[p2.id]);
  let providerTypes = providers.map((p2) => p2.type);
  let dynamic = providerAddrs.filter((p2) => !(p2 & 1));
  let idx = addresses[facet.id] >> 1;
  function get2(state) {
    let values2 = [];
    for (let i2 = 0; i2 < providerAddrs.length; i2++) {
      let value = getAddr(state, providerAddrs[i2]);
      if (providerTypes[i2] == 2) for (let val of value) values2.push(val);
      else values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs) ensureAddr(state, addr);
      state.values[idx] = get2(state);
      return 1;
    },
    update(state, tr2) {
      if (!ensureAll(state, dynamic)) return 0;
      let value = get2(state);
      if (facet.compare(value, state.values[idx])) return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get2(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = Facet.define({
  static: true
});
var StateField = class _StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b) => a2 === b), config2);
    if (config2.provide) field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i2) => i2.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr2) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr2);
        if (this.compareF(oldVal, value)) return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i2) => i2.field == this)) && reInit != oldInit.find((i2) => i2.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({
      field: this,
      create: create2
    })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = {
  lowest: 4,
  low: 3,
  default: 2,
  high: 1,
  highest: 0
};
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({
      compartment: this,
      extension: content2
    });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(
      0
      /* SlotStatus.Unresolved */
    );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten2(base2, compartments, newCompartments)) {
      if (ext instanceof StateField) fields.push(ext);
      else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a2) => field.slot(a2));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p2) => p2.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p2) => p2.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p2 of providers) {
          if (p2.type == 0) {
            address[p2.id] = staticValues.length << 1 | 1;
            staticValues.push(p2.value);
          } else {
            address[p2.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a2) => p2.dynamicSlot(a2));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten2(extension, compartments, newCompartments) {
  let result2 = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2) return;
      let found = result2[known].indexOf(ext);
      if (found > -1) result2[known].splice(found, 1);
      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e2 of ext) inner(e2, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result2[prec2].push(ext);
      if (ext.provides) inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result2[prec2].push(ext);
      if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result2.reduce((a2, b) => a2.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1) return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4) throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2) return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = Facet.define();
var allowMultipleSelections = Facet.define({
  combine: (values2) => values2.some((v) => v),
  static: true
});
var lineSeparator = Facet.define({
  combine: (values2) => values2.length ? values2[0] : void 0,
  static: true
});
var changeFilter = Facet.define();
var transactionFilter = Facet.define();
var transactionExtender = Facet.define();
var readOnly = Facet.define({
  combine: (values2) => values2.length ? values2[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map2) {
    this.map = map2;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length) return effects;
    let result2 = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped) result2.push(mapped);
    }
    return result2;
  }
};
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection) checkSelection(selection, changes.newLength);
    if (!annotations.some((a2) => a2.type == _Transaction.time)) this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state) this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations) if (ann.type == type) return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e2 = this.annotation(_Transaction.userEvent);
    return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
  }
};
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a2, b) {
  let result2 = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to2;
    if (iA < a2.length && (iB == b.length || b[iB] >= a2[iA])) {
      from = a2[iA++];
      to2 = a2[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to2 = b[iB++];
    } else return result2;
    if (!result2.length || result2[result2.length - 1] < from) result2.push(from, to2);
    else if (result2[result2.length - 1] < to2) result2[result2.length - 1] = to2;
  }
}
function mergeTransaction(a2, b, sequential) {
  var _a3;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a2.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a2.changes);
    mapForB = a2.changes.mapDesc(b.changes, true);
    changes = a2.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a3 = a2.selection) === null || _a3 === void 0 ? void 0 : _a3.map(mapForA),
    effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a2.annotations.length ? a2.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a2.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter2) {
  let s2 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false) filter2 = false;
  for (let i2 = 1; i2 < specs.length; i2++) {
    if (specs[i2].filter === false) filter2 = false;
    let seq = !!specs[i2].sequential;
    s2 = mergeTransaction(s2, resolveTransactionInner(state, specs[i2], seq ? s2.changes.newLength : state.doc.length), seq);
  }
  let tr2 = Transaction.create(state, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
  return extendTransaction(filter2 ? filterTransaction(tr2) : tr2);
}
function filterTransaction(tr2) {
  let state = tr2.startState;
  let result2 = true;
  for (let filter2 of state.facet(changeFilter)) {
    let value = filter2(tr2);
    if (value === false) {
      result2 = false;
      break;
    }
    if (Array.isArray(value)) result2 = result2 === true ? value : joinRanges(result2, value);
  }
  if (result2 !== true) {
    let changes, back;
    if (result2 === false) {
      back = tr2.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr2.changes.filter(result2);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr2 = Transaction.create(state, changes, tr2.selection && tr2.selection.map(back), StateEffect.mapEffects(tr2.effects, back), tr2.annotations, tr2.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i2 = filters.length - 1; i2 >= 0; i2--) {
    let filtered = filters[i2](tr2);
    if (filtered instanceof Transaction) tr2 = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr2 = filtered[0];
    else tr2 = resolveTransaction(state, asArray(filtered), false);
  }
  return tr2;
}
function extendTransaction(tr2) {
  let state = tr2.startState, extenders = state.facet(transactionExtender), spec = tr2;
  for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
    let extension = extenders[i2](tr2);
    if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr2.changes.newLength), true);
  }
  return spec == tr2 ? tr2 : Transaction.create(state, tr2.changes, tr2.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar) return wordChar.test(str);
  for (let i2 = 0; i2 < str.length; i2++) {
    let ch2 = str[i2];
    if (/\w/.test(ch2) || ch2 > "" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2))) return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char)) return CharCategory.Space;
    if (hasWordChar(char)) return CharCategory.Word;
    for (let i2 = 0; i2 < wordChars.length; i2++) if (char.indexOf(wordChars[i2]) > -1) return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection, values2, computeSlot, tr2) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values2;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr2) tr2._state = this;
    for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++) ensureAddr(this, i2 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2) throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr2) {
    let conf = this.config, {
      base: base2,
      compartments
    } = conf;
    for (let effect of tr2.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr2.startState.values.slice();
    }
    let selection = tr2.startState.facet(allowMultipleSelections) ? tr2.newSelection : tr2.newSelection.asSingle();
    new _EditorState(conf, tr2.newDoc, selection, startValues, (state, slot) => slot.update(state, tr2), tr2);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string") text = this.toText(text);
    return this.changeByRange((range2) => ({
      changes: {
        from: range2.from,
        to: range2.to,
        insert: text
      },
      range: EditorSelection.cursor(range2.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i2 = 1; i2 < sel.ranges.length; i2++) {
      let result2 = f(sel.ranges[i2]);
      let newChanges = this.changes(result2.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i2; j++) ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result2.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result2.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet) return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text2.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to2 = this.doc.length) {
    return this.doc.sliceString(from, to2, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null) return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result2 = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields) for (let prop in fields) {
      let value = fields[prop];
      if (value instanceof StateField && this.config.address[value.id] != null) result2[prop] = value.spec.toJSON(this.field(fields[prop]), this);
    }
    return result2;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json2, config2 = {}, fields) {
    if (!json2 || typeof json2.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields) for (let prop in fields) {
      if (Object.prototype.hasOwnProperty.call(json2, prop)) {
        let field = fields[prop], value = json2[prop];
        fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
      }
    }
    return _EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text2 ? config2.doc : Text2.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
    return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map2 of this.facet(_EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map2, phrase2)) {
      phrase2 = map2[phrase2];
      break;
    }
    if (insert2.length) phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i2) => {
      if (i2 == "$") return "$";
      let n2 = +(i2 || 1);
      return !n2 || n2 > insert2.length ? m : insert2[n2 - 1];
    });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values2 = [];
    for (let provider of this.facet(languageData)) {
      for (let result2 of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result2, name2)) values2.push(result2[name2]);
      }
    }
    return values2;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at4) {
    return makeCategorizer(this.languageDataAt("wordChars", at4).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let {
      text,
      from,
      length
    } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak2(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word) break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak2(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word) break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
  combine: (values2) => values2.length ? values2[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(a2, b) {
    let kA = Object.keys(a2), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a2[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults4, combine = {}) {
  let result2 = {};
  for (let config2 of configs) for (let key of Object.keys(config2)) {
    let value = config2[key], current = result2[key];
    if (current === void 0) result2[key] = value;
    else if (current === value || value === void 0) ;
    else if (Object.hasOwnProperty.call(combine, key)) result2[key] = combine[key](current, value);
    else throw new Error("Config merge conflict for field " + key);
  }
  for (let key in defaults4) if (result2[key] === void 0) result2[key] = defaults4[key];
  return result2;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to2 = from) {
    return Range.create(from, to2, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from, to2, value) {
    this.from = from;
    this.to = to2;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to2, value) {
    return new _Range(from, to2, value);
  }
};
function cmpRange(a2, b) {
  return a2.from - b.from || a2.value.startSide - b.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to2, value, maxPoint) {
    this.from = from;
    this.to = to2;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo2 = startAt, hi2 = arr.length; ; ) {
      if (lo2 == hi2) return lo2;
      let mid = lo2 + hi2 >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo2) return diff >= 0 ? lo2 : hi2;
      if (diff >= 0) hi2 = mid;
      else lo2 = mid + 1;
    }
  }
  between(offset, from, to2, f) {
    for (let i2 = this.findIndex(from, -1e9, true), e2 = this.findIndex(to2, 1e9, false, i2); i2 < e2; i2++) if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false) return false;
  }
  map(offset, changes) {
    let value = [], from = [], to2 = [], newPos = -1, maxPoint = -1;
    for (let i2 = 0; i2 < this.value.length; i2++) {
      let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null) continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom) continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
      if (newPos < 0) newPos = newFrom;
      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to2.push(newTo - newPos);
    }
    return {
      mapped: value.length ? new _Chunk(from, to2, value, maxPoint) : null,
      pos: newPos
    };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk2, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk2;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk2, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk2, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last3 = this.chunk.length - 1;
    return last3 < 0 ? 0 : Math.max(this.chunkEnd(last3), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty) return 0;
    let size2 = this.nextLayer.size;
    for (let chunk2 of this.chunk) size2 += chunk2.value.length;
    return size2;
  }
  /**
  @internal
  */
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let {
      add: add4 = [],
      sort = false,
      filterFrom = 0,
      filterTo = this.length
    } = updateSpec;
    let filter2 = updateSpec.filter;
    if (add4.length == 0 && !filter2) return this;
    if (sort) add4 = add4.slice().sort(cmpRange);
    if (this.isEmpty) return add4.length ? _RangeSet.of(add4) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i2 < add4.length) {
      if (i2 < add4.length && (cur2.from - add4[i2].from || cur2.startSide - add4[i2].value.startSide) >= 0) {
        let range2 = add4[i2++];
        if (!builder.addInner(range2.from, range2.to, range2.value)) spill.push(range2);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add4.length || this.chunkEnd(cur2.chunkIndex) < add4[i2].from) && (!filter2 || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter2 || filterFrom > cur2.to || filterTo < cur2.from || filter2(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value)) spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({
      add: spill,
      filter: filter2,
      filterFrom,
      filterTo
    }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty) return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk2 = this.chunk[i2];
      let touch = changes.touchesRange(start, start + chunk2.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk2.maxPoint);
        chunks.push(chunk2);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let {
          mapped,
          pos
        } = chunk2.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to2, f) {
    if (this.isEmpty) return;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk2 = this.chunk[i2];
      if (to2 >= start && from <= start + chunk2.length && chunk2.between(start, from - start, to2 - start, f) === false) return;
    }
    this.nextLayer.between(from, to2, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a2 = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a2, b, textDiff);
    let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to2) {
    if (to2 == null) to2 = 1e9 - 1;
    let a2 = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a2.length != b.length) return false;
    if (!a2.length) return true;
    let sharedChunks = findSharedChunks(a2, b);
    let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
      if (sideA.to > to2) return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to2, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to2);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to2) return openRanges + (cursor.point && cursor.to > to2 ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range2 of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range2.from, range2.to, range2.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length) return _RangeSet.empty;
    let result2 = sets[sets.length - 1];
    for (let i2 = sets.length - 2; i2 >= 0; i2--) {
      for (let layer2 = sets[i2]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer) result2 = new _RangeSet(layer2.chunkPos, layer2.chunk, result2, Math.max(layer2.maxPoint, result2.maxPoint));
    }
    return result2;
  }
};
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1) for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
    let cur2 = ranges[i2];
    if (cmpRange(prev, cur2) > 0) return ranges.slice().sort(cmpRange);
    prev = cur2;
  }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to2, value) {
    if (!this.addInner(from, to2, value)) (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to2, value);
  }
  /**
  @internal
  */
  addInner(from, to2, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0) return false;
    if (this.from.length == 250) this.finishChunk(true);
    if (this.chunkStart < 0) this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to2 - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to2;
    this.value.push(value);
    if (value.point) this.maxPoint = Math.max(this.maxPoint, to2 - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk2) {
    if ((from - this.lastTo || chunk2.value[0].startSide - this.last.endSide) < 0) return false;
    if (this.from.length) this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk2.maxPoint);
    this.chunks.push(chunk2);
    this.chunkPos.push(from);
    let last3 = chunk2.value.length - 1;
    this.last = chunk2.value[last3];
    this.lastFrom = chunk2.from[last3] + from;
    this.lastTo = chunk2.to[last3] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length) this.finishChunk(false);
    if (this.chunks.length == 0) return next;
    let result2 = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result2;
  }
};
function findSharedChunks(a2, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a2) for (let i2 = 0; i2 < set2.chunk.length; i2++) if (set2.chunk[i2].maxPoint <= 0) inA.set(set2.chunk[i2], set2.chunkPos[i2]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b) for (let i2 = 0; i2 < set2.chunk.length; i2++) {
    let known = inA.get(set2.chunk[i2]);
    if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i2].length))) shared.add(set2.chunk[i2]);
  }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk2 = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk2.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk2.to[this.rangeIndex];
        this.value = chunk2.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i2 = 0; i2 < sets.length; i2++) {
      for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint) heap.push(new LayerCursor(cur2, skip, minPoint, i2));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap) cur2.goto(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--) heapBubble(this.heap, i2);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap) cur2.forward(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--) heapBubble(this.heap, i2);
    if ((this.to - pos || this.value.endSide - side) < 0) this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value) top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length) break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0) break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove3(this.active, index2);
    remove3(this.activeTo, index2);
    remove3(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i2 = 0, {
      value,
      to: to2,
      rank
    } = this.cursor;
    while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to2 - this.activeTo[i2]) > 0) i2++;
    insert(this.active, i2, value);
    insert(this.activeTo, i2, to2);
    insert(this.activeRank, i2, rank);
    if (trackOpen) insert(trackOpen, i2, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a2 = this.minActive;
      if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a2] > from) {
          this.to = this.activeTo[a2];
          this.endSide = this.active[a2].endSide;
          break;
        }
        this.removeActive(a2);
        if (trackOpen) remove3(trackOpen, a2);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from; i2--) this.openStart++;
    }
  }
  activeForPoint(to2) {
    if (!this.active.length) return this.active;
    let active = [];
    for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
      if (this.activeRank[i2] < this.pointRank) break;
      if (this.activeTo[i2] > to2 || this.activeTo[i2] == to2 && this.active[i2].endSide >= this.point.endSide) active.push(this.active[i2]);
    }
    return active.reverse();
  }
  openEnd(to2) {
    let open = 0;
    for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to2; i2--) open++;
    return open;
  }
};
function compare(a2, startA, b, startB, length, comparator) {
  a2.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a2.to + dPos - b.to, diff = dEnd || a2.endSide - b.endSide;
    let end = diff < 0 ? a2.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a2.point || b.point) {
      if (!(a2.point && b.point && (a2.point == b.point || a2.point.eq(b.point)) && sameValues(a2.activeForPoint(a2.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a2.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a2.active, b.active)) comparator.compareRange(pos, clipEnd, a2.active, b.active);
    }
    if (end > endB) break;
    if ((dEnd || a2.openEnd != b.openEnd) && comparator.boundChange) comparator.boundChange(end);
    pos = end;
    if (diff <= 0) a2.next();
    if (diff >= 0) b.next();
  }
}
function sameValues(a2, b) {
  if (a2.length != b.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) if (a2[i2] != b[i2] && !a2[i2].eq(b[i2])) return false;
  return true;
}
function remove3(array, index2) {
  for (let i2 = index2, e2 = array.length - 1; i2 < e2; i2++) array[i2] = array[i2 + 1];
  array.pop();
}
function insert(array, index2, value) {
  for (let i2 = array.length - 1; i2 >= index2; i2--) array[i2 + 1] = array[i2];
  array[index2] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i2 = 0; i2 < array.length; i2++) if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
    found = i2;
    foundPos = array[i2];
  }
  return found;
}
function countColumn(string2, tabSize, to2 = string2.length) {
  let n2 = 0;
  for (let i2 = 0; i2 < to2 && i2 < string2.length; ) {
    if (string2.charCodeAt(i2) == 9) {
      n2 += tabSize - n2 % tabSize;
      i2++;
    } else {
      n2++;
      i2 = findClusterBreak2(string2, i2);
    }
  }
  return n2;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i2 = 0, n2 = 0; ; ) {
    if (n2 >= col) return i2;
    if (i2 == string2.length) break;
    n2 += string2.charCodeAt(i2) == 9 ? tabSize - n2 % tabSize : 1;
    i2 = findClusterBreak2(string2, i2);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C2 = "";
var COUNT = typeof Symbol == "undefined" ? "__" + C2 : Symbol.for(C2);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let {
      finish
    } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b) => a2.concat(b)), value, target);
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C2 + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root2, modules, options) {
    let set2 = root2[SET], nonce = options && options.nonce;
    if (!set2) set2 = new StyleSet(root2, nonce);
    else if (nonce) set2.setNonce(nonce);
    set2.mount(Array.isArray(modules) ? modules : [modules], root2);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root2, nonce) {
    let doc2 = root2.ownerDocument || root2, win = doc2.defaultView;
    if (!root2.head && root2.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root2[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root2[SET] = this;
  }
  mount(modules, root2) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i2 = 0; i2 < modules.length; i2++) {
      let mod = modules[i2], index2 = this.modules.indexOf(mod);
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1);
        j--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index2) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root2.adoptedStyleSheets.indexOf(this.sheet) < 0) root2.adoptedStyleSheets = [this.sheet, ...root2.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i2 = 0; i2 < this.modules.length; i2++) text += this.modules[i2].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root2.head || root2;
      if (this.styleTag.parentNode != target) target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++) base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++) base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift[i2] = String.fromCharCode(i2);
}
var i2;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i2 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt.setAttribute(name2, value);
      else if (value != null) elt[name2] = value;
    }
    i2++;
  }
  for (; i2 < arguments.length; i2++) add3(elt, arguments[i2]);
  return elt;
}
function add3(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i2 = 0; i2 < child.length; i2++) add3(elt, child[i2]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root2) {
  let target;
  if (root2.nodeType == 11) {
    target = root2.getSelection ? root2 : root2.ownerDocument;
  } else {
    target = root2;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode) return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1) return dom.getClientRects();
  else return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node) return index2;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff) return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV") return false;
      let parent2 = node.parentNode;
      if (!parent2 || parent2.nodeType != 1) return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent2;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false") return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return {
    left: x,
    right: x,
    top: rect.top,
    bottom: rect.bottom
  };
}
function windowRect(win) {
  let vp2 = win.visualViewport;
  if (vp2) return {
    left: 0,
    right: vp2.width,
    top: 0,
    bottom: vp2.height
  };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;
  return {
    scaleX,
    scaleY
  };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position)) stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({
          scaleX,
          scaleY
        } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top) moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX) moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1) x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1) y = "nearest";
        }
      }
      if (top2) break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right) rect = {
        left: Math.max(rect.left, bounding.left),
        right: Math.min(rect.right, bounding.right),
        top: Math.max(rect.top, bounding.top),
        bottom: Math.min(rect.bottom, bounding.bottom)
      };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x && y) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y && cur2.scrollHeight > cur2.clientHeight) y = cur2;
      if (!x && cur2.scrollWidth > cur2.clientWidth) x = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return {
    x,
    y
  };
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range2) {
    let {
      anchorNode,
      focusNode
    } = range2;
    this.set(anchorNode, Math.min(range2.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range2.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive();
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument) break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i2 = 0; i2 < stack.length; ) {
      let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
      if (elt.scrollTop != top2) elt.scrollTop = top2;
      if (elt.scrollLeft != left) elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to2 = from) {
  let range2 = scratchRange || (scratchRange = document.createRange());
  range2.setEnd(node, to2);
  range2.setStart(node, from);
  return range2;
}
function dispatchKey(elt, name2, code, mods) {
  let options = {
    key: name2,
    code: name2,
    keyCode: code,
    which: code,
    cancelable: true
  };
  if (mods) ({
    altKey: options.altKey,
    ctrlKey: options.ctrlKey,
    shiftKey: options.shiftKey,
    metaKey: options.metaKey
  } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up2 = new KeyboardEvent("keyup", options);
  up2.synthetic = true;
  elt.dispatchEvent(up2);
  return down.defaultPrevented || up2.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node = selection.focusNode, offset = selection.focusOffset;
  if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1) return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false") offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return {
        node,
        offset
      };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false") return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return {
        node,
        offset
      };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false") return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view) return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent2 = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent2.firstChild)) {
            let contentView = _ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent2.firstChild;
        if (track && !track.written && track.node == parent2 && next != child.dom) track.written = true;
        if (child.dom.parentNode == parent2) {
          while (next && next != child.dom) next = rm$1(next);
        } else {
          parent2.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent2.firstChild;
      if (next && track && track.node == parent2) track.written = true;
      while (next) next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children) if (child.flags & 7) {
        child.sync(view, track);
        child.flags &= ~7;
      }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset) {
    let after2;
    if (node == this.dom) {
      after2 = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent2 = node.parentNode;
        if (parent2 == this.dom) break;
        if (bias == 0 && parent2.firstChild != parent2.lastChild) {
          if (node == parent2.firstChild) bias = -1;
          else bias = 1;
        }
        node = parent2;
      }
      if (bias < 0) after2 = node;
      else after2 = node.nextSibling;
    }
    if (after2 == this.dom.firstChild) return 0;
    while (after2 && !_ContentView.get(after2)) after2 = after2.nextSibling;
    if (!after2) return this.length;
    for (let i2 = 0, pos = 0; ; i2++) {
      let child = this.children[i2];
      if (child.dom == after2) return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to2, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos < from && end > to2) return child.domBoundsAround(from, to2, pos);
      if (end >= from && fromI == -1) {
        fromI = i2;
        fromStart = pos;
      }
      if (pos > to2 && child.dom.parentNode == this.dom) {
        toI = i2;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent2 = this.parent; parent2; parent2 = parent2.parent) {
      if (childList) parent2.flags |= 2;
      if (parent2.flags & 1) return;
      parent2.flags |= 1;
      childList = false;
    }
  }
  setParent(parent2) {
    if (this.parent != parent2) {
      this.parent = parent2;
      if (this.flags & 7) this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom) return;
    if (this.dom) this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent2 = v.parent;
      if (!parent2) return v;
      v = parent2;
    }
  }
  replaceChildren(from, to2, children = noChildren) {
    this.markDirty();
    for (let i2 = from; i2 < to2; i2++) {
      let child = this.children[i2];
      if (child.parent == this && children.indexOf(child) < 0) child.destroy();
    }
    if (children.length < 250) this.children.splice(from, to2 - from, ...children);
    else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to2));
    for (let i2 = 0; i2 < children.length; i2++) children[i2].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to2, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children) if (child.parent == this) child.destroy();
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ChildCursor = class {
  constructor(children, pos, i2) {
    this.children = children;
    this.pos = pos;
    this.i = i2;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
function replaceRange(parent2, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let {
    children
  } = parent2;
  let before2 = children.length ? children[fromI] : null;
  let last3 = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last3 ? last3.breakAfter : breakAtStart;
  if (fromI == toI && before2 && !breakAtStart && !breakAtEnd && insert2.length < 2 && before2.merge(fromOff, toOff, insert2.length ? last3 : null, fromOff == 0, openStart, openEnd)) return;
  if (toI < children.length) {
    let after2 = children[toI];
    if (after2 && (toOff < after2.length || after2.breakAfter && (last3 === null || last3 === void 0 ? void 0 : last3.breakAfter))) {
      if (fromI == toI) {
        after2 = after2.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last3 && after2.merge(0, toOff, last3, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after2;
      } else {
        if (toOff || after2.children.length && !after2.children[0].length) after2.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after2);
      }
    } else if (after2 === null || after2 === void 0 ? void 0 : after2.breakAfter) {
      if (last3) last3.breakAfter = 1;
      else breakAtStart = 1;
    }
    toI++;
  }
  if (before2) {
    before2.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before2.merge(fromOff, before2.length, insert2[0], false, openStart, 0)) {
        before2.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before2.length || before2.children.length && before2.children[before2.children.length - 1].length == 0) {
        before2.merge(fromOff, before2.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;
  if (fromI < toI || insert2.length) parent2.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent2, from, to2, insert2, openStart, openEnd) {
  let cur2 = parent2.childCursor();
  let {
    i: toI,
    off: toOff
  } = cur2.findPos(to2, 1);
  let {
    i: fromI,
    off: fromOff
  } = cur2.findPos(from, -1);
  let dLen = from - to2;
  for (let view of insert2) dLen += view.length;
  parent2.length += dLen;
  replaceRange(parent2, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav = typeof navigator != "undefined" ? navigator : {
  userAgent: "",
  vendor: "",
  platform: ""
};
var doc = typeof document != "undefined" ? document : {
  documentElement: {
    style: {}
  }
};
var ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /MSIE \d/.test(nav.userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko = !ie2 && /gecko\/(\d+)/i.test(nav.userAgent);
var chrome = !ie2 && /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /Mac/.test(nav.platform),
  windows: /Win/.test(nav.platform),
  linux: /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom) this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom) track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3) this.createDOM(dom);
  }
  merge(from, to2, source) {
    if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to2 - from) + source.length > MaxJoinLen || source.flags & 8)) return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to2);
    this.markDirty();
    return true;
  }
  split(from) {
    let result2 = new _TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result2.flags |= this.flags & 8;
    return result2;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return {
      from: offset,
      to: offset + this.length,
      startDOM: this.dom,
      endDOM: this.dom.nextSibling
    };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch2 of children) ch2.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class) dom.className = this.mark.class;
    if (this.mark.attrs) for (let name2 in this.mark.attrs) dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4) this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to2, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to2 < this.length && openEnd <= 0)) return false;
    mergeChildrenInto(this, from, to2, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result2 = [], off = 0, detachFrom = -1, i2 = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from) result2.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from) detachFrom = i2;
      off = end;
      i2++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result2, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length) pos = length;
  let from = pos, to2 = pos, flatten3 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten3 = 1;
      } else if (to2 < length) {
        to2++;
        flatten3 = -1;
      }
    }
  } else {
    if (side < 0) from--;
    else if (to2 < length) to2++;
  }
  let rects = textRange(text, from, to2).getClientRects();
  if (!rects.length) return null;
  let rect = rects[(flatten3 ? flatten3 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten3 && rect.width == 0) rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
  return flatten3 ? flattenRect(rect, flatten3 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  static create(widget, length, side) {
    return new _WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result2 = _WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result2;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable) this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to2, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to2);
    return true;
  }
  become(other) {
    if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget)) this.markDirty(true);
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0) return Text2.empty;
    let top2 = this;
    while (top2.parent) top2 = top2.parent;
    let {
      view
    } = top2, text = view && view.state.doc, start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : Text2.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom) return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length) return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
      rect = rects[i2];
      if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom) break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom) this.widget.destroy(this.dom);
  }
};
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text2.empty;
  }
  get isHidden() {
    return true;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent2, pos) {
  let dom = parent2.dom, {
    children
  } = parent2, i2 = 0;
  for (let off = 0; i2 < children.length; i2++) {
    let child = children[i2], end = off + child.length;
    if (end == off && child.getSide() <= 0) continue;
    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
    if (pos <= off) break;
    off = end;
  }
  for (let j = i2; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);
  }
  for (let j = i2; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom) return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent2, view, open) {
  let last3, {
    children
  } = parent2;
  if (open > 0 && view instanceof MarkView && children.length && (last3 = children[children.length - 1]) instanceof MarkView && last3.mark.eq(view.mark)) {
    joinInlineInto(last3, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent2);
  }
  parent2.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before2 = null, beforePos = -1, after2 = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i2 = 0, off = 0; i2 < view2.children.length && off <= pos2; i2++) {
      let child = view2.children[i2], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after2 || after2.isHidden && (side > 0 || onSameLine(after2, child))) && (end > pos2 || off == end && child.getSide() > 0)) {
          after2 = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before2 = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before2 : after2) || before2 || after2;
  if (target) return target.coordsAt(Math.max(0, target == before2 ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last3 = view.dom.lastChild;
  if (!last3) return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last3);
  return rects[rects.length - 1] || null;
}
function onSameLine(a2, b) {
  let posA = a2.coordsAt(0, 1), posB = b.coordsAt(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class) target.class += " " + source.class;
    else if (name2 == "style" && target.style) target.style += ";" + source.style;
    else target[name2] = source[name2];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a2, b, ignore) {
  if (a2 == b) return true;
  if (!a2) a2 = noAttrs;
  if (!b) b = noAttrs;
  let keysA = Object.keys(a2), keysB = Object.keys(b);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a2[key] !== b[key])) return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev) if (!(attrs && name2 in attrs)) {
      changed = true;
      if (name2 == "style") dom.style.cssText = "";
      else dom.removeAttribute(name2);
    }
  }
  if (attrs) {
    for (let name2 in attrs) if (!(prev && prev[name2] == attrs[name2])) {
      changed = true;
      if (name2 == "style") dom.style.cssText = attrs[name2];
      else dom.setAttribute(name2, attrs[name2]);
    }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < dom.attributes.length; i2++) {
    let attr = dom.attributes[i2];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let {
        start,
        end
      } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of2, sort = false) {
    return RangeSet.of(of2, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let {
      start,
      end
    } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a3, _b;
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a3 = this.attrs) === null || _a3 === void 0 ? void 0 : _a3.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to2 = from) {
    if (from >= to2) throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to2);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to2 = from) {
    if (to2 != from) throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to2);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to2 = from) {
    if (this.isReplace && (from > to2 || from == to2 && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to2 != from) throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to2);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let {
    inclusiveStart: start,
    inclusiveEnd: end
  } = spec;
  if (start == null) start = spec.inclusive;
  if (end == null) end = spec.inclusive;
  return {
    start: start !== null && start !== void 0 ? start : block,
    end: end !== null && end !== void 0 ? end : block
  };
}
function widgetsEq(a2, b) {
  return a2 == b || !!(a2 && b && a2.compare(b));
}
function addRange(from, to2, ranges, margin = 0) {
  let last3 = ranges.length - 1;
  if (last3 >= 0 && ranges[last3] + margin >= from) ranges[last3] = Math.max(ranges[last3], to2);
  else ranges.push(from, to2);
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to2, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView)) return false;
      if (!this.dom) source.transferDOM(this);
    }
    if (hasStart) this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to2, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at4) {
    let end = new _LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0) return end;
    let {
      i: i2,
      off
    } = this.childPos(at4);
    if (off) {
      end.append(this.children[i2].split(off), 0);
      this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
      i2++;
    }
    for (let j = i2; j < this.children.length; j++) end.append(this.children[j], 0);
    while (i2 > 0 && this.children[i2 - 1].length == 0) this.children[--i2].destroy();
    this.children.length = i2;
    this.markDirty();
    this.length = at4;
    return end;
  }
  transferDOM(other) {
    if (!this.dom) return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls) this.attrs = combineAttrs({
      class: cls
    }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a3;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last3 = this.dom.lastChild;
    while (last3 && ContentView.get(last3) instanceof MarkView) last3 = last3.lastChild;
    if (!last3 || !this.length || last3.nodeName != "BR" && ((_a3 = ContentView.get(last3)) === null || _a3 === void 0 ? void 0 : _a3.isEditable) == false && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1) return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let {
        heightOracle
      } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return {
          top: rect.top + dist2,
          bottom: rect.bottom - dist2,
          left: rect.left,
          right: rect.left
        };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
      let block = docView.children[i2], end = off + block.length;
      if (end >= pos) {
        if (block instanceof _LineView) return block;
        if (end > pos) break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to2, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to2);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at4) {
    let len = this.length - at4;
    this.length = at4;
    let end = new _BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable) this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text2.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget)) this.markDirty(true);
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom) return custom;
    if (this.widget instanceof BlockGapWidget) return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom) this.widget.destroy(this.dom);
  }
  covers(side) {
    let {
      startSide,
      endSide
    } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
};
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last3 = this.content[this.content.length - 1];
    return !(last3.breakAfter || last3 instanceof BlockWidgetView && last3.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();
    else this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let {
          value,
          lineBreak,
          done
        } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done) throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered()) this.getLine();
          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;
          else this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take2 = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take2)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take2;
      length -= take2;
      openStart = 0;
    }
  }
  span(from, to2, active, openStart) {
    this.buildText(to2 - from, active, openStart);
    this.pos = to2;
    if (this.openStart < 0) this.openStart = openStart;
  }
  point(from, to2, deco, active, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block) throw new RangeError("Block decorations may not be specified via plugins");
      if (to2 > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to2 - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered()) this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to2 || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to2 || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable) this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to2 || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer) this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to2;
    }
    if (this.openStart < 0) this.openStart = openStart;
  }
  static build(text, from, to2, decorations2, dynamicDecorationMap) {
    let builder = new _ContentBuilder(text, from, to2, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from, to2, builder);
    if (builder.openStart < 0) builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
};
function wrapMarks(view, active) {
  for (let mark of active) view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");
var Direction = function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result2 = [];
  for (let i2 = 0; i2 < str.length; i2++) result2.push(1 << +str[i2]);
  return result2;
}
var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p2 of ["()", "[]", "{}"]) {
  let l = p2.charCodeAt(0), r2 = p2.charCodeAt(1);
  Brackets[l] = r2;
  Brackets[r2] = -l;
}
function charType(ch2) {
  return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8204 ? 256 : 64336 <= ch2 && ch2 <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to2, level) {
    this.from = from;
    this.to = to2;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index2, level, assoc) {
    let maybe = -1;
    for (let i2 = 0; i2 < order.length; i2++) {
      let span = order[i2];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level) return i2;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order[maybe].level > span.level)) maybe = i2;
      }
    }
    if (maybe < 0) throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a2, b) {
  if (a2.length != b.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    let iA = a2[i2], iB = b[i2];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to2; i2++) {
      let type = charType(line.charCodeAt(i2));
      if (type == 512) type = prev;
      else if (type == 8 && prevStrong == 4) type = 16;
      types[i2] = type == 4 ? 2 : type;
      if (type & 7) prevStrong = type;
      prev = type;
    }
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to2; i2++) {
      let type = types[i2];
      if (type == 128) {
        if (i2 < to2 - 1 && prev == types[i2 + 1] && prev & 24) type = types[i2] = prev;
        else types[i2] = 256;
      } else if (type == 64) {
        let end = i2 + 1;
        while (end < to2 && types[end] == 64) end++;
        let replace4 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++) types[j] = replace4;
        i2 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type;
      if (type & 7) prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from, ch2, br2, type; i2 < to2; i2++) {
      if (br2 = Brackets[ch2 = line.charCodeAt(i2)]) {
        if (br2 < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br2) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2) types[i2] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch2;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i2]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2) break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4) break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to2 = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from; i2 < to2; ) {
      let type = types[i2];
      if (type == 256) {
        let end = i2 + 1;
        for (; ; ) {
          if (end == to2) {
            if (iI == isolates.length) break;
            end = isolates[iI++].to;
            to2 = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace4 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace4;
        }
        i2 = end;
      } else {
        prev = type;
        i2++;
      }
    }
  }
}
function emitSpans(line, from, to2, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to2; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum) break run;
          let iso = isolates[iI];
          if (!sameDir) for (let upto = iso.to, jI = iI + 1; ; ) {
            if (upto == to2) break run;
            if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;
            else if (types[upto] == ourType) break run;
            else break;
          }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to2 || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to2, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum) break run;
          let iso = isolates[--iI];
          if (!sameDir) for (let upto = iso.from, jI = iI; ; ) {
            if (upto == from) break run;
            if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;
            else if (types[upto - 1] == ourType) break run;
            else break;
          }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to2, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to2, isolates, outerType);
  processBracketPairs(line, from, to2, isolates, outerType);
  processNeutrals(from, to2, isolates, outerType);
  emitSpans(line, from, to2, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);
  if (isolates.length) while (line.length > types.length) types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a3;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a3 = start.bidiLevel) !== null && _a3 !== void 0 ? _a3 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length) return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to2) {
  for (let i2 = from; i2 < to2; i2++) {
    let type = charType(text.charCodeAt(i2));
    if (type == 1) return LTR;
    if (type == 2 || type == 4) return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = Facet.define();
var dragMovesSelection$1 = Facet.define();
var mouseSelectionStyle = Facet.define();
var exceptionSink = Facet.define();
var updateListener = Facet.define();
var inputHandler = Facet.define();
var focusChangeEffect = Facet.define();
var clipboardInputFilter = Facet.define();
var clipboardOutputFilter = Facet.define();
var perLineTextDirection = Facet.define({
  combine: (values2) => values2.some((x) => x)
});
var nativeSelectionHidden = Facet.define({
  combine: (values2) => values2.some((x) => x)
});
var scrollHandler = Facet.define();
var ScrollTarget = class _ScrollTarget {
  constructor(range2, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range2;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView = StateEffect.define({
  map: (t3, ch2) => t3.map(ch2)
});
var setEditContextFormatting = StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length) handler[0](exception);
  else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception)) ;
  else if (context) console.error(context + ":", exception);
  else console.error(exception);
}
var editable = Facet.define({
  combine: (values2) => values2.length ? values2[0] : true
});
var nextPluginID = 0;
var viewPlugin = Facet.define({
  combine(plugins) {
    return plugins.filter((p2, i2) => {
      for (let j = 0; j < i2; j++) if (plugins[j].plugin == p2.plugin) return false;
      return true;
    });
  }
});
var ViewPlugin = class _ViewPlugin {
  constructor(id2, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.baseExtensions = buildExtensions(this);
    this.extension = this.baseExtensions.concat(viewPlugin.of({
      plugin: this,
      arg: void 0
    }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(arg) {
    return this.baseExtensions.concat(viewPlugin.of({
      plugin: this,
      arg
    }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const {
      eventHandlers,
      eventObservers,
      provide,
      decorations: deco
    } = spec || {};
    return new _ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin3) => {
      let ext = [];
      if (deco) ext.push(decorations.of((view) => {
        let pluginInst = view.plugin(plugin3);
        return pluginInst ? deco(pluginInst) : Decoration.none;
      }));
      if (provide) ext.push(provide(plugin3));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view, arg) => new cls(view, arg), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.plugin.create(view, this.spec.arg);
        } catch (e2) {
          logException(view.state, e2, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update2 = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update2);
        } catch (e2) {
          logException(update2.state, e2, "CodeMirror plugin crashed");
          if (this.value.destroy) try {
            this.value.destroy();
          } catch (_) {
          }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a3;
    if ((_a3 = this.value) === null || _a3 === void 0 ? void 0 : _a3.destroy) {
      try {
        this.value.destroy();
      } catch (e2) {
        logException(view.state, e2, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = Facet.define();
var contentAttributes = Facet.define();
var decorations = Facet.define();
var outerDecorations = Facet.define();
var atomicRanges = Facet.define();
var bidiIsolatedRanges = Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length) return isolates;
  let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
  let result2 = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to2 = toDoc - line.from;
      let level = result2;
      for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
        let direction = active[i2].spec.bidiIsolate, update2;
        if (direction == null) direction = autoDirection(line.text, from, to2);
        if (open > 0 && level.length && (update2 = level[level.length - 1]).to == from && update2.direction == direction) {
          update2.to = to2;
          level = update2.inner;
        } else {
          let add4 = {
            from,
            to: to2,
            direction,
            inner: []
          };
          level.push(add4);
          level = add4.inner;
        }
      }
    }
  });
  return result2;
}
var scrollMargins = Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view);
    if (m) {
      if (m.left != null) left = Math.max(left, m.left);
      if (m.right != null) right = Math.max(right, m.right);
      if (m.top != null) top2 = Math.max(top2, m.top);
      if (m.bottom != null) bottom = Math.max(bottom, m.bottom);
    }
  }
  return {
    left,
    right,
    top: top2,
    bottom
  };
}
var styleModule = Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i2 = set2.length, me = this;
    for (; i2 > 0; i2--) {
      let range2 = set2[i2 - 1];
      if (range2.fromA > me.toA) continue;
      if (range2.toA < me.fromA) break;
      me = me.join(range2);
      set2.splice(i2 - 1, 1);
    }
    set2.splice(i2, 0, me);
    return set2;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0) return diff;
    let result2 = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to2 = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to2);
        if (fromB <= toB) new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result2);
        if (to2 > end) break;
        else rI += 2;
      }
      if (!next) return result2;
      new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result2);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr2 of transactions) this.changes = this.changes.compose(tr2.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr2) => tr2.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update2) {
    var _a3;
    let changedRanges = update2.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({
        fromA,
        toA
      }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update2.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update2.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update2);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a3 = this.domChanged) === null || _a3 === void 0 ? void 0 : _a3.newSel) readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update2.changes, this.hasComposition) && !update2.selectionSet) readCompositionAt = update2.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update2.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let {
        from,
        to: to2
      } = this.hasComposition;
      changedRanges = new ChangedRange(from, to2, update2.changes.mapPos(from, -1), update2.changes.mapPos(to2, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? {
      from: composition.range.fromB,
      to: composition.range.toB
    } : null;
    if ((browser.ie || browser.chrome) && !composition && update2 && update2.state.doc.lines != update2.startState.doc.lines) this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update2.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update2.startState.doc.length, composition);
      if (update2.transactions.length) this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let {
      observer
    } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? {
        node: observer.selectionRange.focusNode,
        written: false
      } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children) if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor = this.childCursor(oldLength);
    for (let i2 = ranges.length - 1; ; i2--) {
      let next = i2 >= 0 ? ranges[i2] : null;
      if (!next) break;
      let {
        fromA,
        toA,
        fromB,
        toB
      } = next, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before2 = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after2 = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before2.breakAtStart;
        openStart = before2.openStart;
        openEnd = after2.openEnd;
        let compLine = this.compositionView(composition);
        if (after2.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after2.content.length && compLine.merge(compLine.length, compLine.length, after2.content[0], false, after2.openStart, 0)) {
          compLine.breakAfter = after2.content[0].breakAfter;
          after2.content.shift();
        }
        if (before2.content.length && compLine.merge(0, 0, before2.content[before2.content.length - 1], true, 0, before2.openEnd)) {
          before2.content.pop();
        }
        content2 = before2.content.concat(compLine).concat(after2.content);
      } else {
        ({
          content: content2,
          breakAtStart,
          openStart,
          openEnd
        } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let {
        i: toI,
        off: toOff
      } = cursor.findPos(toA, 1);
      let {
        i: fromI,
        off: fromOff
      } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition) this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update2) {
    this.editContextFormatting = this.editContextFormatting.map(update2.changes);
    for (let tr2 of update2.transactions) for (let effect of tr2.effects) if (effect.is(setEditContextFormatting)) {
      this.editContextFormatting = effect.value;
    }
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue);
    cur2.flags |= 8;
    for (let {
      deco
    } of composition.marks) cur2 = new MarkView(deco, [cur2], cur2.length);
    let line = new LineView();
    line.append(cur2, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2) prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus)) return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head2 = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head2 = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head2.node, head2.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({
            preventScroll: true
          });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text) anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0) rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head2.node, head2.offset);
          } catch (_) {
          }
        } else {
          let range2 = document.createRange();
          if (main.anchor > main.head) [anchor, head2] = [head2, anchor];
          range2.setEnd(head2.node, head2.offset);
          range2.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range2);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt) activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head2);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head2.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor) {
    return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let {
      view
    } = this, cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let {
      anchorNode,
      anchorOffset
    } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;
    let line = LineView.find(this, cursor.head);
    if (!line) return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
    let before2 = this.coordsAt(cursor.head, -1), after2 = this.coordsAt(cursor.head, 1);
    if (!before2 || !after2 || before2.bottom > after2.top) return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom) return pos;
    for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView) newPos = view.domAtPos(0);
    }
    for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView) newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this) return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let {
      i: i2,
      off
    } = this.childCursor().findPos(pos, -1);
    for (; i2 < this.children.length - 1; ) {
      let child = this.children[i2];
      if (off < child.length || child instanceof LineView) break;
      i2++;
      off = 0;
    }
    return this.children[i2].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
      let child = this.children[i2], end = off - child.breakAfter, start = end - child.length;
      if (end < pos) break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0) break;
        else if (i2) best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let {
      i: i2,
      off
    } = this.childPos(pos, 1), child = this.children[i2];
    if (!(child instanceof LineView)) return null;
    while (child.children.length) {
      let {
        i: i3,
        off: childOff
      } = child.childPos(off, 1);
      for (; ; i3++) {
        if (i3 == child.children.length) return null;
        if ((child = child.children[i3]).length) break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView)) return null;
    let end = findClusterBreak2(child.text, off);
    if (end == off) return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result2 = [], {
      from,
      to: to2
    } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (end > to2) break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result2.push(childRect.height);
        if (isWider) {
          let last3 = child.dom.lastChild;
          let rects = last3 ? clientRectsFor(last3) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result2;
  }
  textDirectionAt(pos) {
    let {
      i: i2
    } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure) return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return {
      lineHeight,
      charWidth,
      textHeight
    };
  }
  childCursor(pos = this.length) {
    let i2 = this.children.length;
    if (i2) pos -= this.children[--i2].length;
    return new ChildCursor(this.children, pos, i2);
  }
  computeBlockGapDeco() {
    let deco = [], vs2 = this.view.viewState;
    for (let pos = 0, i2 = 0; ; i2++) {
      let next = i2 == vs2.viewports.length ? null : vs2.viewports[i2];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs2.lineBlockAt(end).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next) break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i2 = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i2++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i3) => {
      let dynamic = typeof d == "function";
      if (dynamic) dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i2++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [this.editContextFormatting, ...allDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
    while (i2 < this.decorations.length) this.dynamicDecorationMap[i2++] = false;
    return this.decorations;
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target)) return true;
      } catch (e2) {
        logException(this.view.state, e2, "scroll handler");
      }
    }
    let {
      range: range2
    } = target;
    let rect = this.coordsAt(range2.head, range2.empty ? range2.assoc : range2.head > range2.anchor ? -1 : 1), other;
    if (!rect) return;
    if (!range2.empty && (other = this.coordsAt(range2.anchor, range2.anchor > range2.head ? -1 : 1))) rect = {
      left: Math.min(rect.left, other.left),
      top: Math.min(rect.top, other.top),
      right: Math.max(rect.right, other.right),
      bottom: Math.max(rect.bottom, other.bottom)
    };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let {
      offsetWidth,
      offsetHeight
    } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode) return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)) textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode) return null;
  let from = headPos - textNode.offset;
  return {
    from,
    to: from + textNode.node.nodeValue.length,
    node: textNode.node
  };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found) return null;
  let {
    node: textNode,
    from,
    to: to2
  } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text)) return null;
  if (view.state.doc.sliceString(found.from, found.to) != text) return null;
  let inv = changes.invertedDesc;
  let range2 = new ChangedRange(inv.mapPos(from), inv.mapPos(to2), from, to2);
  let marks2 = [];
  for (let parent2 = textNode.parentNode; ; parent2 = parent2.parentNode) {
    let parentView = ContentView.get(parent2);
    if (parentView instanceof MarkView) marks2.push({
      node: parent2,
      deco: parentView.mark
    });
    else if (parentView instanceof LineView || parent2.nodeName == "DIV" && parent2.parentNode == view.contentDOM) return {
      range: range2,
      text: textNode,
      marks: marks2,
      line: parent2
    };
    else if (parent2 != view.contentDOM) marks2.push({
      node: parent2,
      deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent2),
        tagName: parent2.tagName.toLowerCase()
      })
    });
    else return null;
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1) return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to2) {
    addRange(from, to2, this.changes);
  }
  comparePoint(from, to2) {
    addRange(from, to2, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a2, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a2, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition) changes.iterChangedRanges((from, to2) => {
    if (from < composition.to && to2 > composition.from) touched = true;
  });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0) return EditorSelection.cursor(pos);
  if (linePos == 0) bias = 1;
  else if (linePos == line.length) bias = -1;
  let from = linePos, to2 = linePos;
  if (bias < 0) from = findClusterBreak2(line.text, linePos, false);
  else to2 = findClusterBreak2(line.text, linePos);
  let cat = categorize(line.text.slice(from, to2));
  while (from > 0) {
    let prev = findClusterBreak2(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat) break;
    from = prev;
  }
  while (to2 < line.length) {
    let next = findClusterBreak2(line.text, to2);
    if (categorize(line.text.slice(to2, next)) != cat) break;
    to2 = next;
  }
  return EditorSelection.range(from + line.from, to2 + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a2, b) {
  return a2.top < b.bottom - 1 && a2.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? {
    top: top2,
    left: rect.left,
    right: rect.right,
    bottom: rect.bottom
  } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? {
    top: rect.top,
    left: rect.left,
    right: rect.right,
    bottom
  } : rect;
}
function domPosAtCoords(parent2, x, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent2.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        closestOverlap = !dx ? true : x < rect.left ? i2 > 0 : i2 < rects.length - 1;
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest) return {
    node: parent2,
    offset: 0
  };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false") return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent2.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return {
    node: parent2,
    offset
  };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i2 = 0; i2 < len; i2++) {
    let rects = textRange(node, i2, i2 + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom) continue;
      if (!generalSide) generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after2 = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i2).getBoundingClientRect();
          if (rectBefore.left == rect.right) after2 = !right;
        }
        if (dy <= 0) return {
          node,
          offset: i2 + (after2 ? 1 : 0)
        };
        closestOffset = i2 + (after2 ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return {
    node,
    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
  };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a3, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, {
    docHeight
  } = view.viewState;
  let {
    x,
    y
  } = coords, yOffset = y - docTop;
  if (yOffset < 0) return 0;
  if (yOffset > docHeight) return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text) break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight) break;
      if (bounced) return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
  let doc2 = view.dom.ownerDocument;
  let root2 = view.root.elementFromPoint ? view.root : doc2;
  let element = root2.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element)) element = null;
  if (!element) {
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    element = root2.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element)) element = null;
  }
  let node, offset = -1;
  if (element && ((_a3 = view.docView.nearest(element)) === null || _a3 === void 0 ? void 0 : _a3.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos) ({
        offsetNode: node,
        offset
      } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range2 = doc2.caretRangeFromPoint(x, y);
      if (range2) {
        ({
          startContainer: node,
          startOffset: offset
        } = range2);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = void 0;
      }
    }
    if (node) offset = Math.min(maxOffset(node), offset);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({
      node,
      offset
    } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest) return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  let len, scan = node;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
  for (; ; ) {
    let next = scan.nextSibling;
    if (next) {
      if (next.nodeName == "BR") break;
      return false;
    } else {
      let parent2 = scan.parentNode;
      if (!parent2 || parent2.nodeName == "DIV") break;
      scan = parent2;
    }
  }
  return textRange(node, len - 1, len).getBoundingClientRect().right > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0) return false;
  for (let cur2 = node; ; ) {
    let parent2 = cur2.parentNode;
    if (!parent2 || parent2.nodeType != 1 || parent2.firstChild != cur2) return false;
    if (parent2.classList.contains("cm-line")) break;
    cur2 = parent2;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l of line.type) {
      if (l.from > pos) break;
      if (l.to < pos) continue;
      if (l.from < pos && l.to > pos) return l;
      if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos))) best = l;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1)) return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by) return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space) cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0)) return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null) goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, {
      x: resolvedGoal,
      y: curY
    }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set2 of atoms) {
      set2.between(pos - 1, pos + 1, (from, to2, value) => {
        if (pos > from && pos < to2) {
          let side = moved || bias || (pos - from < to2 - pos ? -1 : 1);
          pos = side < 0 ? from : to2;
          moved = side;
        }
      });
    }
    if (!moved) return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var LineBreakPlaceholder = "";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start) return this;
    let parent2 = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent2, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end) break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen) this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent2, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0) break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points) if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore) return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i2 = fromView.iter(); !i2.next().done; ) {
        if (i2.lineBreak) this.lineBreak();
        else this.append(i2.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling) this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points) if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
};
function isAtEnd(parent2, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node)) return false;
    if (node == parent2) return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let {
      impreciseHead: iHead,
      impreciseAnchor: iAnchor
    } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head2 = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp2 = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head2 != anchor && (vp2.from > 0 || vp2.to < view.state.doc.length)) {
        let from = Math.min(head2, anchor), to2 = Math.max(head2, anchor);
        let offFrom = vp2.from - from, offTo = vp2.to - to2;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to2 == view.state.doc.length)) {
          head2 = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head2);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let {
    newSel
  } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let {
      from,
      to: to2
    } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to2 - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to2, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text2.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel) return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, sel.to)
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = {
      from: change.from,
      to: change.to,
      insert: Text2.of([change.insert.toString().replace(".", " ")])
    };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = {
      from: sel.from,
      to: sel.to,
      insert: Text2.of([" "])
    };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select") scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({
      selection: newSel,
      scrollIntoView: scrollIntoView3,
      userEvent
    });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change)) return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46))) return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0) view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h2) => h2(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr2, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before2 = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after2 = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr2 = startState.replaceSelection(view.state.toText(before2 + change.insert.sliceString(0, void 0, view.state.lineBreak) + after2));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = {
          from: composition.from,
          to: composition.to - dLen
        };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size2 = sel.to - sel.from;
      tr2 = startState.changeByRange((range2) => {
        if (range2.from == sel.from && range2.to == sel.to) return {
          changes,
          range: mainSel || range2.map(changes)
        };
        let to2 = range2.to - offset, from = to2 - replaced.length;
        if (range2.to - range2.from != size2 || view.state.sliceDoc(from, to2) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range2.to >= compositionRange.from && range2.from <= compositionRange.to) return {
          range: range2
        };
        let rangeChanges = startState.changes({
          from,
          to: to2,
          insert: change.insert
        }), selOff = range2.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range2.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr2 = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr2, {
    userEvent,
    scrollIntoView: true
  });
}
function findDiff(a2, b, preferredPos, preferredSide) {
  let minLen = Math.min(a2.length, b.length);
  let from = 0;
  while (from < minLen && a2.charCodeAt(from) == b.charCodeAt(from)) from++;
  if (from == minLen && a2.length == b.length) return null;
  let toA = a2.length, toB = b.length;
  while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a2.length < b.length) {
    let move2 = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move2;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move2 = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move2;
    toA = from + (toA - toB);
    toB = from;
  }
  return {
    from,
    toA,
    toB
  };
}
function selectionPoints(view) {
  let result2 = [];
  if (view.root.activeElement != view.contentDOM) return result2;
  let {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  } = view.observer.selectionRange;
  if (anchorNode) {
    result2.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset) result2.push(new DOMPoint(focusNode, focusOffset));
  }
  return result2;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0) return null;
  let anchor = points[0].pos, head2 = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head2 > -1 ? EditorSelection.single(anchor + base2, head2 + base2) : null;
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari) view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;
    if (event.type == "keydown" && this.keydown(event)) return;
    if (this.view.updateState != 0) Promise.resolve().then(() => this.runHandlers(event.type, event));
    else this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers) observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented) break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2) if (type != "scroll") {
      let passive = !handlers2[type].handlers.length;
      let exists = prev[type];
      if (exists && passive != !exists.handlers.length) {
        dom.removeEventListener(type, this.handleEvent);
        exists = null;
      }
      if (!exists) dom.addEventListener(type, this.handleEvent, {
        passive
      });
    }
    for (let type in prev) if (type != "scroll" && !handlers2[type]) dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229) this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key) return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString())) return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type)) return false;
    if (this.composing > 0) return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection) this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update2) {
    this.view.observer.update(update2);
    if (this.mouseSelection) this.mouseSelection.update(update2);
    if (this.draggedContent && update2.docChanged) this.draggedContent = this.draggedContent.map(update2.changes);
    if (update2.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection) this.mouseSelection.destroy();
  }
};
function bindHandler(plugin3, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin3, event, view);
    } catch (e2) {
      logException(view.state, e2);
    }
  };
}
function computeHandlers(plugins) {
  let result2 = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result2[type] || (result2[type] = {
      observers: [],
      handlers: []
    });
  }
  for (let plugin3 of plugins) {
    let spec = plugin3.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
    if (handlers2) for (let type in handlers2) {
      let f = handlers2[type];
      if (f) record(type).handlers.push(bindHandler(plugin3.value, f));
    }
    if (observers2) for (let type in observers2) {
      let f = observers2[type];
      if (f) record(type).observers.push(bindHandler(plugin3.value, f));
    }
  }
  for (let type in handlers) record(type).handlers.push(handlers[type]);
  for (let type in observers) record(type).observers.push(observers[type]);
  return result2;
}
var PendingKeys = [{
  key: "Backspace",
  keyCode: 8,
  inputType: "deleteContentBackward"
}, {
  key: "Enter",
  keyCode: 13,
  inputType: "insertParagraph"
}, {
  key: "Enter",
  keyCode: 13,
  inputType: "insertLineBreak"
}, {
  key: "Delete",
  keyCode: 46,
  inputType: "deleteContentForward"
}];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a2, b) {
  return Math.max(Math.abs(a2.clientX - b.clientX), Math.abs(a2.clientY - b.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = {
      x: 0,
      y: 0
    };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false) this.select(event);
  }
  move(event) {
    if (event.buttons == 0) return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x) ({
      left,
      right
    } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y) ({
      top: top2,
      bottom
    } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin) sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null) this.select(this.lastEvent);
    if (!this.dragging) event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = {
      x: sx,
      y: sy
    };
    if (sx || sy) {
      if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let {
      x,
      y
    } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y) this.view.win.scrollBy(x, y);
    if (this.dragging === false) this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let range2 = sel.ranges[i2], updated = null;
      if (range2.empty) {
        let pos = skipAtomicRanges(this.atoms, range2.from, 0);
        if (pos != range2.from) updated = EditorSelection.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range2.from, -1);
        let to2 = skipAtomicRanges(this.atoms, range2.to, 1);
        if (from != range2.from || to2 != range2.to) updated = EditorSelection.range(range2.from == range2.anchor ? from : to2, range2.from == range2.head ? from : to2);
      }
      if (updated) {
        if (!ranges) ranges = sel.ranges.slice();
        ranges[i2] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let {
      view
    } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({
      selection,
      userEvent: "select.pointer"
    });
    this.mustSelect = false;
  }
  update(update2) {
    if (update2.transactions.some((tr2) => tr2.isUserEvent("input.type"))) this.destroy();
    else if (this.style.update(update2)) setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let {
    main
  } = view.state.selection;
  if (main.empty) return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0) return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i2 = 0; i2 < rects.length; i2++) {
    let rect = rects[i2];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent2 = view.dom.parentNode;
  if (!parent2) return;
  let target = parent2.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter2 of state.facet(facet)) text = filter2(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let {
    state
  } = view, changes, i2 = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range2) => {
      let line = state.doc.lineAt(range2.from);
      if (line.from == lastLine) return {
        range: range2
      };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
      return {
        changes: {
          from: line.from,
          insert: insert2
        },
        range: EditorSelection.cursor(range2.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range2) => {
      let line = text.line(i2++);
      return {
        changes: {
          from: range2.from,
          to: range2.to,
          insert: line.text
        },
        range: EditorSelection.cursor(range2.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e2) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style) break;
  }
  if (!style && event.button == 0) style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus) view.observer.ignore(() => {
      focusPreventScroll(view.contentDOM);
      let active = view.root.activeElement;
      if (active && !active.contains(view.contentDOM)) active.blur();
    });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to2 = visual ? visual.posAtEnd : line.to;
    if (to2 < view.state.doc.length && to2 == line.to) to2++;
    return EditorSelection.range(from, to2);
  }
}
var inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line) return 1;
  let off = pos - line.posAtStart;
  if (off == 0) return 1;
  if (off == line.length) return -1;
  let before2 = line.coordsAt(off, -1);
  if (before2 && inside(x, y, before2)) return -1;
  let after2 = line.coordsAt(off, 1);
  if (after2 && inside(x, y, after2)) return 1;
  return before2 && before2.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  return {
    pos,
    bias: findPositionSide(view, pos, event.clientX, event.clientY)
  };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail) return event.detail;
  let last3 = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last3 || lastTime > Date.now() - 400 && Math.abs(last3.clientX - event.clientX) < 2 && Math.abs(last3.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update2) {
      if (update2.docChanged) {
        start.pos = update2.changes.mapPos(start.pos);
        startSel = startSel.map(update2.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur2 = queryPos(view, event2), removed;
      let range2 = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range2.from), to2 = Math.max(startRange.to, range2.to);
        range2 = from < range2.from ? EditorSelection.range(from, to2) : EditorSelection.range(to2, from);
      }
      if (extend) return startSel.replaceRange(startSel.main.extend(range2.from, range2.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos))) return removed;
      else if (multiple) return startSel.addRange(range2);
      else return EditorSelection.create([range2]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let {
      from,
      to: to2
    } = sel.ranges[i2];
    if (from <= pos && to2 >= pos) return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let {
    selection: {
      main: range2
    }
  } = view.state;
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target);
    if (cView && cView.isWidget) {
      let from = cView.posAtStart, to2 = from + cView.length;
      if (from >= range2.to || to2 <= range2.from) range2 = EditorSelection.range(from, to2);
    }
  }
  let {
    inputState
  } = view;
  if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range2;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range2.from, range2.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text) return;
  let dropPos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  let {
    draggedContent
  } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? {
    from: draggedContent.from,
    to: draggedContent.to
  } : null;
  let ins = {
    from: dropPos,
    insert: text
  };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: {
      anchor: changes.mapPos(dropPos, -1),
      head: changes.mapPos(dropPos, 1)
    },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer) return false;
  if (view.state.readOnly) return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length) dropText(view, event, text.filter((s2) => s2 != null).join(view.state.lineBreak), false);
    };
    for (let i2 = 0; i2 < files.length; i2++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i2] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i2]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly) return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent2 = view.dom.parentNode;
  if (!parent2) return;
  let target = parent2.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range2 of state.selection.ranges) if (!range2.empty) {
    content2.push(state.sliceDoc(range2.from, range2.to));
    ranges.push(range2);
  }
  if (!content2.length) {
    let upto = -1;
    for (let {
      from
    } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({
          from: line.from,
          to: Math.min(state.doc.length, line.to + 1)
        });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return {
    text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)),
    ranges,
    linewise
  };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let {
    text,
    ranges,
    linewise
  } = copiedRange(view.state);
  if (!text && !linewise) return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly) view.dispatch({
    changes: ranges,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
var isFocusChange = Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect) effects.push(effect);
  }
  return effects.length ? state.update({
    effects,
    annotations: isFocusChange.of(true)
  }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr2 = focusChangeTransaction(view.state, focus);
      if (tr2) view.dispatch(tr2);
      else view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext) return;
  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext) return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a3, _b;
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a3 = event.dataTransfer) === null || _a3 === void 0 ? void 0 : _a3.getData("text/plain"), ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r2 = ranges[0];
      let from = view.posAtDOM(r2.startContainer, r2.startOffset), to2 = view.posAtDOM(r2.endContainer, r2.endOffset);
      applyDOMChangeInner(view, {
        from,
        to: to2,
        insert: view.state.toText(text)
      }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a4;
        if ((((_a4 = window.visualViewport) === null || _a4 === void 0 ? void 0 : _a4.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text2.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to2) {
    let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping) lines += Math.max(0, Math.ceil((to2 - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping) return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i2 = 0; i2 < lineHeights.length; i2++) {
      let h2 = lineHeights[i2];
      if (h2 < 0) {
        i2++;
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i2 = 0; i2 < knownHeights.length; i2++) {
        let h2 = knownHeights[i2];
        if (h2 < 0) i2++;
        else this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result2) {
    result2.push(this);
  }
  decomposeRight(_from, result2) {
    result2.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i2 = changes.length - 1; i2 >= 0; i2--) {
      let {
        fromA,
        toA,
        fromB,
        toB
      } = changes[i2];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
        fromA = changes[i2 - 1].fromA;
        fromB = changes[i2 - 1].fromB;
        i2--;
        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace3(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1) return nodes[0];
    let i2 = 0, j = nodes.length, before2 = 0, after2 = 0;
    for (; ; ) {
      if (i2 == j) {
        if (before2 > after2 * 2) {
          let split2 = nodes[i2 - 1];
          if (split2.break) nodes.splice(--i2, 1, split2.left, null, split2.right);
          else nodes.splice(--i2, 1, split2.left, split2.right);
          j += 1 + split2.break;
          before2 -= split2.size;
        } else if (after2 > before2 * 2) {
          let split2 = nodes[j];
          if (split2.break) nodes.splice(j, 1, split2.left, null, split2.right);
          else nodes.splice(j, 1, split2.left, split2.right);
          j += 2 + split2.break;
          after2 -= split2.size;
        } else {
          break;
        }
      } else if (before2 < after2) {
        let next = nodes[i2++];
        if (next) before2 += next.size;
      } else {
        let next = nodes[--j];
        if (next) after2 += next.size;
      }
    }
    let brk = 0;
    if (nodes[i2 - 1] == null) {
      brk = 1;
      i2--;
    } else if (nodes[i2] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i2)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
function replace3(old, val) {
  if (old == val) return old;
  if (old.constructor != val.constructor) heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from, to2, oracle, top2, offset, f) {
    if (from <= offset + this.length && to2 >= offset) f(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap) node = new _HeightMapText(node.length, this.height);
      else node.height = this.height;
      if (!this.outdated) node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);
    else if (force || this.outdated) this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return {
      firstLine,
      lastLine,
      perLine,
      perChar
    };
  }
  blockAt(height, oracle, top2, offset) {
    let {
      firstLine,
      lastLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let {
        from,
        length
      } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let {
        from,
        to: to2
      } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to2 - from, 0, 0, 0);
    }
    let {
      firstLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to2, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to2 = Math.min(to2, offset + this.length);
    let {
      firstLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to2; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to2, nodes) {
    let after2 = this.length - to2;
    if (after2 > 0) {
      let last3 = nodes[nodes.length - 1];
      if (last3 instanceof _HeightMapGap) nodes[nodes.length - 1] = new _HeightMapGap(last3.length + after2);
      else nodes.push(null, new _HeightMapGap(after2 - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap) nodes[0] = new _HeightMapGap(from + first.length);
      else nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to2, result2) {
    result2.push(new _HeightMapGap(to2 - 1), null);
  }
  decomposeRight(from, result2) {
    result2.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset) nodes.push(new _HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length) nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1) singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end) nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result2 = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result2.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;
      return replace3(this, result2);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset)) return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left) return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to2, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset) this.left.forEachLine(from, to2, oracle, top2, offset, f);
      if (to2 >= rightOffset) this.right.forEachLine(from, to2, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to2) f(mid);
      if (to2 > mid.to) this.right.forEachLine(mid.to + 1, to2, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to2, nodes) {
    let rightStart = this.left.length + this.break;
    if (to2 < rightStart) return this.balanced(this.left.replace(from, to2, nodes), this.right);
    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to2 - rightStart, nodes));
    let result2 = [];
    if (from > 0) this.decomposeLeft(from, result2);
    let left = result2.length;
    for (let node of nodes) result2.push(node);
    if (from > 0) mergeGaps(result2, left - 1);
    if (to2 < this.length) {
      let right = result2.length;
      this.decomposeRight(to2, result2);
      mergeGaps(result2, right);
    }
    return HeightMap.of(result2);
  }
  decomposeLeft(to2, result2) {
    let left = this.left.length;
    if (to2 <= left) return this.left.decomposeLeft(to2, result2);
    result2.push(this.left);
    if (this.break) {
      left++;
      if (to2 >= left) result2.push(null);
    }
    if (to2 > left) this.right.decomposeLeft(to2 - left, result2);
  }
  decomposeRight(from, result2) {
    let left = this.left.length, right = left + this.break;
    if (from >= right) return this.right.decomposeRight(from - right, result2);
    if (from < left) this.left.decomposeRight(from, result2);
    if (this.break && from < right) result2.push(null);
    result2.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace3(this.left, left);
    this.right = replace3(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let {
      left,
      right
    } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else right.updateHeight(oracle, rightStart, force);
    if (rebalance) return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before2, after2;
  if (nodes[around] == null && (before2 = nodes[around - 1]) instanceof HeightMapGap && (after2 = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before2.length + 1 + after2.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to2) {
    if (this.lineStart > -1) {
      let end = Math.min(to2, this.lineEnd), last3 = this.nodes[this.nodes.length - 1];
      if (last3 instanceof HeightMapText) last3.length += end - this.pos;
      else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to2 > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to2;
  }
  point(from, to2, deco) {
    if (from < to2 || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0) height = this.oracle.lineHeight;
      let len = to2 - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to2 > from) {
      this.span(from, to2);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let {
      from,
      to: to2
    } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to2;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to2) {
    let gap = new HeightMapGap(to2 - from);
    if (this.oracle.doc.lineAt(from).to == to2) gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last3 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last3 instanceof HeightMapText) return last3;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0) this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last3 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last3 instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last3 == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to2) {
    let builder = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to2, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a2, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a2, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to2, a2, b) {
    if (from < to2 || a2 && a2.heightRelevant || b && b.heightRelevant) addRange(from, to2, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent2 = dom.parentNode; parent2 && parent2 != doc2.body; ) {
    if (parent2.nodeType == 1) {
      let elt = parent2;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent2 == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent2 = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent2.nodeType == 11) {
      parent2 = parent2.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt) {
  let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to2, size2, displaySize) {
    this.from = from;
    this.to = to2;
    this.size = size2;
    this.displaySize = displaySize;
  }
  static same(a2, b) {
    if (a2.length != b.length) return false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      let gA = a2[i2], gB = b[i2];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size2, vertical) {
    super();
    this.size = size2;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: 0
    };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i2 = 0; i2 < 2; i2++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport()) break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], {
      main
    } = this.state.selection;
    for (let i2 = 0; i2 <= 1; i2++) {
      let pos = i2 ? main.head : main.anchor;
      if (!viewports.some(({
        from,
        to: to2
      }) => pos >= from && pos <= to2)) {
        let {
          from,
          to: to2
        } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to2));
      }
    }
    this.viewports = viewports.sort((a2, b) => a2.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update2, scrollTarget = null) {
    this.state = update2.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update2.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update2 ? update2.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update2.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag) update2.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update2.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = prevHeight;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update2.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update2.flags |= this.updateForViewport();
    if (viewportChange || !update2.changes.empty || update2.flags & 2) this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update2.changes)));
    update2.flags |= this.computeVisibleRanges(update2.changes);
    if (scrollTarget) this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update2.selectionSet && update2.view.lineWrapping && update2.state.selection.main.empty && update2.state.selection.main.assoc && !update2.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result2 = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let {
        scaleX,
        scaleY
      } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result2 |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result2 |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping) measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result2 |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView) measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result2 |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let {
          lineHeight,
          charWidth,
          textHeight
        } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result2 |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp2 of this.viewports) {
        let heights = vp2.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp2);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text2.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp2.from, heights));
      }
      if (heightChangeFlag) result2 |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result2 & 2) result2 |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result2 |= this.updateForViewport();
    }
    if (result2 & 2 || viewportChange) this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result2 |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result2;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map2 = this.heightMap, oracle = this.heightOracle;
    let {
      visibleTop,
      visibleBottom
    } = this;
    let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let {
        head: head2
      } = scrollTarget.range;
      if (head2 < viewport.from || head2 > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map2.lineAt(head2, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head2 < viewport.from) topPos = block.top;
        else topPos = block.bottom - viewHeight;
        viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({
    from,
    to: to2
  }, bias = 0) {
    if (!this.inView) return true;
    let {
      top: top2
    } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let {
      bottom
    } = this.heightMap.lineAt(to2, QueryType.ByPos, this.heightOracle, 0, 0);
    let {
      visibleTop,
      visibleBottom
    } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to2 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3;
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty) return gaps;
    let mapped = [];
    for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];
    let gaps = [];
    let addGap = (from, to2, line, structure) => {
      if (to2 - from < halfMargin) return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty) avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to2) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to2, line, structure);
          return;
        }
      }
      let gap = find2(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to2) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to2 < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r2) => r2.from <= to2 && r2.to >= to2)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to2), false, true).head;
          if (lineStart > from) to2 = lineStart;
        }
        let size2 = this.gapSize(line, from, to2, structure);
        let displaySize = wrapping || size2 < 2e6 ? size2 : 2e6;
        gap = new LineGap(from, to2, size2, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text) return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin) return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6) for (let old of current) {
          if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;
        }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to) addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type)) line.type.forEach(checkLine);
      else checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to2, structure) {
    let fraction = findFraction(structure, to2) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to2) {
        ranges.push({
          from,
          to: to2
        });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i2 = 0; i2 < ranges.length && !(changed & 8); i2++) {
        let old = this.visibleRanges[i2], nw = ranges[i2];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to)) changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to2) {
    this.from = from;
    this.to = to2;
  }
};
function lineStructure(from, to2, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to2, {
    span() {
    },
    point(from2, to3) {
      if (from2 > pos) {
        ranges.push({
          from: pos,
          to: from2
        });
        total += from2 - pos;
      }
      pos = to3;
    }
  }, 20);
  if (pos < to2) {
    ranges.push({
      from: pos,
      to: to2
    });
    total += to2 - pos;
  }
  return {
    total,
    ranges
  };
}
function findPosition({
  total,
  ranges
}, ratio) {
  if (ratio <= 0) return ranges[0].from;
  if (ratio >= 1) return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i2 = 0; ; i2++) {
    let {
      from,
      to: to2
    } = ranges[i2], size2 = to2 - from;
    if (dist2 <= size2) return from + dist2;
    dist2 -= size2;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let {
    from,
    to: to2
  } of structure.ranges) {
    if (pos <= to2) {
      counted += pos - from;
      break;
    }
    counted += to2 - from;
  }
  return counted / structure.total;
}
function find2(array, f) {
  for (let val of array) if (f(val)) return val;
  return void 0;
}
var IdScaler = {
  toDOM(n2) {
    return n2;
  },
  fromDOM(n2) {
    return n2;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
var BigScaler = class _BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({
      from,
      to: to2
    }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to2, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return {
        from,
        to: to2,
        top: top2,
        bottom,
        domTop: 0,
        domBottom: 0
      };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp2 = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp2 || n2 < vp2.top) return domBase + (n2 - base2) * this.scale;
      if (n2 <= vp2.bottom) return vp2.domTop + (n2 - vp2.top);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
  fromDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp2 = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp2 || n2 < vp2.domTop) return base2 + (n2 - domBase) / this.scale;
      if (n2 <= vp2.domBottom) return vp2.top + (n2 - vp2.domTop);
      base2 = vp2.bottom;
      domBase = vp2.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof _BigScaler)) return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp2, i2) => vp2.from == other.viewports[i2].from && vp2.to == other.viewports[i2].to);
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1) return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
var theme = Facet.define({
  combine: (strs) => strs.join(" ")
});
var darkTheme = Facet.define({
  combine: (values2) => values2.indexOf(true) > -1
});
var baseThemeID = StyleModule.newName();
var baseLightID = StyleModule.newName();
var baseDarkID = StyleModule.newName();
var lightDarkIDs = {
  "&light": "." + baseLightID,
  "&dark": "." + baseDarkID
};
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&") return main;
        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": {
    caretColor: "black"
  },
  "&dark .cm-content": {
    caretColor: "white"
  },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": {
    "0%": {},
    "50%": {
      opacity: 0
    },
    "100%": {}
  },
  "@keyframes cm-blink2": {
    "0%": {},
    "50%": {
      opacity: 0
    },
    "100%": {}
  },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": {
      display: "none"
    }
  },
  "&light .cm-activeLine": {
    backgroundColor: "#cceeff44"
  },
  "&dark .cm-activeLine": {
    backgroundColor: "#99eeff33"
  },
  "&light .cm-specialChar": {
    color: "red"
  },
  "&dark .cm-specialChar": {
    color: "#f78"
  },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": {
    insetInlineStart: 0
  },
  ".cm-gutters-after": {
    insetInlineEnd: 0
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": {
      borderRightWidth: "1px"
    },
    "&.cm-gutters-after": {
      borderLeftWidth: "1px"
    }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": {
      fontSize: "80%"
    }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations) this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();
      else this.flush();
    });
    if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData) this.onCharData = (event) => {
      this.queue.push({
        target: event.target,
        type: "characterData",
        oldValue: event.prevValue
      });
      this.flushSoon();
    };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia) this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a3;
        if (((_a3 = this.view.docView) === null || _a3 === void 0 ? void 0 : _a3.lastUpdate) < Date.now() - 75) this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
        }
      }, {
        threshold: [0, 1e-3]
      });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e2) {
    this.view.inputState.runHandlers("scroll", e2);
    if (this.intersecting) this.view.measure();
  }
  onScroll(e2) {
    if (this.intersecting) this.flush(false);
    if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e2);
  }
  onResize() {
    if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1;
      this.view.requestMeasure();
    }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches) return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps) this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let {
      view
    } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged) this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();
    else this.flush(false);
  }
  readSelectionRange() {
    let {
      view
    } = this;
    let selection = getSelection(view.root);
    if (!selection) return false;
    let range2 = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
    if (!range2 || this.selectionRange.eq(range2)) return false;
    let local = hasSelection(this.dom, range2);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range2)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range2);
    if (local) this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head2) {
    this.selectionRange.set(anchor.node, anchor.offset, head2.node, head2.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i2 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom) i2++;
        else if (!changed) changed = this.scrollTargets.slice(0, i2);
        if (changed) changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i2 < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i2);
    if (changed) {
      for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed) dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active) return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active) return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active) return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a3;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force) dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter") this.delayedAndroidKey = {
      key,
      keyCode,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!((_a3 = this.delayedAndroidKey) === null || _a3 === void 0 ? void 0 : _a3.force)
    };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1;
      this.flush();
    });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords()) this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length) this.queue = [];
    let from = -1, to2 = -1, typeOver = false;
    for (let record of records) {
      let range2 = this.readMutation(record);
      if (!range2) continue;
      if (range2.typeOver) typeOver = true;
      if (from == -1) {
        ({
          from,
          to: to2
        } = range2);
      } else {
        from = Math.min(range2.from, from);
        to2 = Math.max(range2.to, to2);
      }
    }
    return {
      from,
      to: to2,
      typeOver
    };
  }
  readChange() {
    let {
      from,
      to: to2,
      typeOver
    } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel) return null;
    if (from > -1) this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to2, typeOver);
    this.view.docView.domChanged = {
      newSel: change.newSel ? change.newSel.main : null
    };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    if (readSelection) this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main))) this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec)) return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes") cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return {
        from: cView.posAtStart,
        to: cView.posAtEnd,
        typeOver: rec.target.nodeValue == rec.oldValue
      };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener) this.printQuery.addEventListener("change", this.onPrint);
      else this.printQuery.addListener(this.onPrint);
    } else win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener) this.printQuery.removeEventListener("change", this.onPrint);
      else this.printQuery.removeListener(this.onPrint);
    } else win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update2) {
    if (this.editContext) {
      this.editContext.update(update2);
      if (update2.startState.facet(editable) != update2.state.facet(editable)) update2.view.contentDOM.editContext = update2.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a3, _b, _c2;
    this.stop();
    (_a3 = this.intersection) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c2 = this.resizeScroll) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
    for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView) return curView;
    let parent2 = dom.parentNode;
    dom = parent2 != cView.dom ? parent2 : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range2) {
  let anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
  let focusNode = range2.endContainer, focusOffset = range2.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  };
}
function safariSelectionRangeHack(view, selection) {
  if (selection.getComposedRanges) {
    let range2 = selection.getComposedRanges(view.root)[0];
    if (range2) return buildSelectionRangeFromRange(view, range2);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
var EditContextManager = class {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e2) => {
      let main = view.state.selection.main, {
        anchor,
        head: head2
      } = main;
      let from = this.toEditorPos(e2.updateRangeStart), to2 = this.toEditorPos(e2.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing) this.composing = {
        contextBase: e2.updateRangeStart,
        editorBase: from,
        drifted: false
      };
      let change = {
        from,
        to: to2,
        insert: Text2.of(e2.text.split("\n"))
      };
      if (change.from == this.from && anchor < this.from) change.from = anchor;
      else if (change.to == this.to && anchor > this.to) change.to = anchor;
      if (change.from == change.to && !change.insert.length) {
        let newSel = EditorSelection.single(this.toEditorPos(e2.selectionStart), this.toEditorPos(e2.selectionEnd));
        if (!newSel.main.eq(main)) view.dispatch({
          selection: newSel,
          userEvent: "select"
        });
        return;
      }
      if ((browser.mac || browser.android) && change.from == head2 - 1 && /^\. ?$/.test(e2.text) && view.contentDOM.getAttribute("autocorrect") == "off") change = {
        from,
        to: to2,
        insert: Text2.of([e2.text.replace(".", " ")])
      };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e2.selectionStart, newLen), this.toEditorPos(e2.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = (e2) => {
      let rects = [], prev = null;
      for (let i2 = this.toEditorPos(e2.rangeStart), end = this.toEditorPos(e2.rangeEnd); i2 < end; i2++) {
        let rect = view.coordsForChar(i2);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e2.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e2) => {
      let deco = [];
      for (let format of e2.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let from = this.toEditorPos(format.rangeStart), to2 = this.toEditorPos(format.rangeEnd);
          if (from < to2) {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({
              attributes: {
                style
              }
            }).range(from, to2));
          }
        }
      }
      view.dispatch({
        effects: setEditContextFormatting.of(Decoration.set(deco))
      });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let {
          drifted
        } = this.composing;
        this.composing = null;
        if (drifted) this.reset(view.state);
      }
    };
    for (let event in this.handlers) context.addEventListener(event, this.handlers[event]);
    this.measureReq = {
      read: (view2) => {
        this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
        let sel = getSelection(view2.root);
        if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      }
    };
  }
  applyEdits(update2) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update2.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort) return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update2.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort) this.revertPending(update2.state);
    return !abort;
  }
  update(update2) {
    let reverted = this.pendingContextChange, startSel = update2.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update2.changes.touchesRange(startSel.from, startSel.to) && update2.transactions.some((tr2) => !tr2.isUserEvent("input.type") && tr2.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update2.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update2) || !this.rangeIsValid(update2.state)) {
      this.pendingContextChange = null;
      this.reset(update2.state);
    } else if (update2.docChanged || update2.selectionSet || reverted) {
      this.setSelection(update2.state);
    }
    if (update2.geometryChanged || update2.docChanged || update2.selectionSet) update2.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let {
      head: head2
    } = state.selection.main;
    this.from = Math.max(
      0,
      head2 - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head2 + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let {
      main
    } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let {
      head: head2
    } = state.selection.main;
    return !(this.from > 0 && head2 - this.from < 500 || this.to < state.doc.length && this.to - head2 < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers) this.editContext.removeEventListener(event, this.handlers[event]);
  }
};
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a3;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent) config2.parent.appendChild(this.dom);
    let {
      dispatch
    } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr2) => dispatch(tr2, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin3 of this.plugins) plugin3.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a3 = document.fonts) === null || _a3 === void 0 ? void 0 : _a3.ready) document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update2;
    let state = this.state;
    for (let tr2 of transactions) {
      if (tr2.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr2.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr2) => tr2.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus) focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(state);
    update2 = ViewUpdate.create(this, state, transactions);
    update2.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr2 of transactions) {
        if (scrollTarget) scrollTarget = scrollTarget.map(tr2.changes);
        if (tr2.scrollIntoView) {
          let {
            main
          } = tr2.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e2 of tr2.effects) if (e2.is(scrollIntoView)) scrollTarget = e2.value.clip(this.state);
      }
      this.viewState.update(update2, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update2.changes);
      if (!update2.empty) {
        this.updatePlugins(update2);
        this.inputState.update(update2);
      }
      redrawn = this.docView.update(update2);
      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr2) => tr2.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update2.startState.facet(theme) != update2.state.facet(theme)) this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
    if (redrawn) this.docViewUpdate();
    if (!update2.empty) for (let listener of this.state.facet(updateListener)) {
      try {
        listener(update2);
      } catch (e2) {
        logException(this.state, e2, "update listener");
      }
    }
    if (dispatchFocus || domChange) Promise.resolve().then(() => {
      if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin3 of this.plugins) plugin3.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin3 of this.plugins) plugin3.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus) this.focus();
    this.requestMeasure();
  }
  updatePlugins(update2) {
    let prevSpecs = update2.startState.facet(viewPlugin), specs = update2.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin3 = this.plugins[found];
          plugin3.mustUpdate = update2;
          newPlugins.push(plugin3);
        }
      }
      for (let plugin3 of this.plugins) if (plugin3.mustUpdate != update2) plugin3.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p2 of this.plugins) p2.mustUpdate = update2;
    }
    for (let i2 = 0; i2 < this.plugins.length; i2++) this.plugins[i2].update(this);
    if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin3 of this.plugins) {
      let val = plugin3.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e2) {
          logException(this.state, e2, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed) return;
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush) this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let {
      scrollAnchorPos,
      scrollAnchorHeight
    } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i2 = 0; ; i2++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (i2 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4)) [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e2) {
            logException(this.state, e2);
            return BadMeasure;
          }
        });
        let update2 = ViewUpdate.create(this, this.state, []), redrawn = false;
        update2.flags |= changed;
        if (!updated) updated = update2;
        else updated.flags |= changed;
        this.updateState = 2;
        if (!update2.empty) {
          this.updatePlugins(update2);
          this.inputState.update(update2);
          this.updateAttrs();
          redrawn = this.docView.update(update2);
          if (redrawn) this.docViewUpdate();
        }
        for (let i3 = 0; i3 < measuring.length; i3++) if (measured[i3] != BadMeasure) {
          try {
            let m = measuring[i3];
            if (m.write) m.write(measured[i3], this);
          } catch (e2) {
            logException(this.state, e2);
          }
        }
        if (redrawn) this.docView.updateSelection(true);
        if (!update2.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr2 of trs) for (let effect of tr2.effects) if (effect.is(_EditorView.announce)) {
      if (first) this.announceDOM.textContent = "";
      first = false;
      let div = this.announceDOM.appendChild(document.createElement("div"));
      div.textContent = effect.value;
    }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {
      nonce
    } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1) this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1) return;
      if (request.key != null) for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
        if (this.measureRequests[i2].key === request.key) {
          this.measureRequests[i2] = request;
          return;
        }
      }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin3) {
    let known = this.pluginMap.get(plugin3);
    if (known === void 0 || known && known.plugin != plugin3) this.pluginMap.set(plugin3, known = this.plugins.find((p2) => p2.plugin == plugin3) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return {
      top: this.viewState.paddingTop,
      bottom: this.viewState.paddingBottom
    };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial3) => byGroup(this, start.head, initial3)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right) return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine) return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;
    }
    if (!isolates) isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a3;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a3 = this.inputState) === null || _a3 === void 0 ? void 0 : _a3.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root2) {
    if (this._root != root2) {
      this._root = root2;
      this.observer.setWindow((root2.nodeType == 9 ? root2 : root2.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();
    for (let plugin3 of this.plugins) plugin3.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let {
      scrollTop,
      scrollLeft
    } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to2) {
    if (to2 == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to2 == "boolean") this.inputState.tabFocusMode = to2 ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to2;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), {
      eventHandlers: handlers2
    });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), {
      eventObservers: observers2
    });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result2 = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark) result2.push(darkTheme.of(true));
    return result2;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a3;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a3 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a3 === void 0 ? void 0 : _a3.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = Facet.define({
  combine: (values2) => values2.length ? values2[0] : ""
});
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({
  "class": "cm-lineWrapping"
});
EditorView.announce = StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to2, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to2;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c) => c.fresh)) return cache;
    let result2 = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i2 = Math.max(0, cache.length - 10); i2 < cache.length; i2++) {
      let entry = cache[i2];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result2.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result2;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
    let source = sources[i2], value = typeof source == "function" ? source(view) : source;
    if (value) combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result2 = parts[parts.length - 1];
  if (result2 == "Space") result2 = " ";
  let alt, ctrl, shift2, meta2;
  for (let i2 = 0; i2 < parts.length - 1; ++i2) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) meta2 = true;
    else if (/^a(lt)?$/i.test(mod)) alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
    else if (/^s(hift)?$/i.test(mod)) shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac") meta2 = true;
      else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt) result2 = "Alt-" + result2;
  if (ctrl) result2 = "Ctrl-" + result2;
  if (meta2) result2 = "Meta-" + result2;
  if (shift2) result2 = "Shift-" + result2;
  return result2;
}
function modifiers(name2, event, shift2) {
  if (event.altKey) name2 = "Alt-" + name2;
  if (event.ctrlKey) name2 = "Ctrl-" + name2;
  if (event.metaKey) name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey) name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = Prec.default(EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = Facet.define({
  enables: handleKeyEvents
});
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map2 = Keymaps.get(bindings);
  if (!map2) Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a2, b) => a2.concat(b), [])));
  return map2;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is2) => {
    let current = isPrefix[name2];
    if (current == null) isPrefix[name2] = is2;
    else if (current != is2) throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add4 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a3, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i2 = 1; i2 < parts.length; i2++) {
      let prefix = parts.slice(0, i2).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix]) scopeObj[prefix] = {
        preventDefault: true,
        stopPropagation: false,
        run: [(view) => {
          let ourObj = storedPrefix = {
            view,
            prefix,
            scope
          };
          setTimeout(() => {
            if (storedPrefix == ourObj) storedPrefix = null;
          }, PrefixTimeout);
          return true;
        }]
      };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a3 = scopeObj._any) === null || _a3 === void 0 ? void 0 : _a3.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2) binding.run.push(command2);
    if (preventDefault) binding.preventDefault = true;
    if (stopPropagation) binding.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any) for (let scope of scopes) {
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      if (!scopeObj._any) scopeObj._any = {
        preventDefault: false,
        stopPropagation: false,
        run: []
      };
      let {
        any
      } = b;
      for (let key in scopeObj) scopeObj[key].run.push((view) => any(view, currentKeyEvent));
    }
    let name2 = b[platform] || b.key;
    if (!name2) continue;
    for (let scope of scopes) {
      add4(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift) add4(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
var currentKeyEvent = null;
function runHandlers(map2, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt2(name2, 0), isChar = codePointSize2(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run) if (!ran.has(cmd2)) {
        ran.add(cmd2);
        if (cmd2(view)) {
          if (binding.stopPropagation) stopPropagation = true;
          return true;
        }
      }
      if (binding.preventDefault) {
        if (binding.stopPropagation) stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map2[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
    !(browser.mac && event.altKey && !event.ctrlKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any)) handled = true;
  }
  if (prevented) handled = true;
  if (handled && stopPropagation) event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className) return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null) elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p2) {
    return this.left == p2.left && this.top == p2.top && this.width == p2.width && this.height == p2.height && this.className == p2.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range2) {
    if (range2.empty) {
      let pos = view.coordsAtPos(range2.head, range2.assoc || 1);
      if (!pos) return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range2);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return {
    left: left - view.scrollDOM.scrollLeft * view.scaleX,
    top: rect.top - view.scrollDOM.scrollTop * view.scaleY
  };
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords) return inside2;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({
    x: editorRect.left + 1,
    y
  });
  let right = view.posAtCoords({
    x: editorRect.right - 1,
    y
  });
  if (left == null || right == null) return inside2;
  return {
    from: Math.max(inside2.from, Math.min(left, right)),
    to: Math.min(inside2.to, Math.max(left, right))
  };
}
function rectanglesForRange(view, className, range2) {
  if (range2.to <= view.viewport.from || range2.from >= view.viewport.to) return [];
  let from = Math.max(range2.from, view.viewport.from), to2 = Math.min(range2.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to2, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to2, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range2.from, range2.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range2.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range2.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text) top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({
    top: top2,
    bottom,
    horizontal
  }) {
    let pieces2 = [];
    for (let i2 = 0; i2 < horizontal.length; i2 += 2) pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to3, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to4, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to4, to4 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords) return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to3 !== null && to3 !== void 0 ? to3 : line.to;
    for (let r2 of view.visibleRanges) if (r2.to > start && r2.from < end) {
      for (let pos = Math.max(r2.from, start), endPos = Math.min(r2.to, end); ; ) {
        let docLine = view.state.doc.lineAt(pos);
        for (let span of view.bidiSpans(docLine)) {
          let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
          if (spanFrom >= endPos) break;
          if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to3 == null && spanTo >= end, span.dir);
        }
        pos = docLine.to + 1;
        if (pos >= endPos) break;
      }
    }
    if (horizontal.length == 0) addSpan(start, from2 == null, end, to3 == null, view.textDirection);
    return {
      top: top2,
      bottom,
      horizontal
    };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return {
      top: y,
      bottom: y,
      horizontal: []
    };
  }
}
function sameMarker(a2, b) {
  return a2.constructor == b.constructor && a2.eq(b);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = {
      read: this.measure.bind(this),
      write: this.draw.bind(this)
    };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above) this.dom.classList.add("cm-layer-above");
    if (layer2.class) this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount) layer2.mount(this.dom, view);
  }
  update(update2) {
    if (update2.startState.facet(layerOrder) != update2.state.facet(layerOrder)) this.setOrder(update2.state);
    if (this.layer.update(update2, this.dom) || update2.geometryChanged) {
      this.scale();
      update2.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer) pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let {
      scaleX,
      scaleY
    } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p2, i2) => !sameMarker(p2, this.drawn[i2]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy) this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = Facet.define();
function layer(config2) {
  return [ViewPlugin.define((v) => new LayerView(v, config2)), layerOrder.of(config2)];
}
var selectionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a2, b) => Math.min(a2, b),
      drawRangeCursor: (a2, b) => a2 || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [selectionConfig.of(config2), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];
}
function configChanged(update2) {
  return update2.startState.facet(selectionConfig) != update2.state.facet(selectionConfig);
}
var cursorLayer = layer({
  above: true,
  markers(view) {
    let {
      state
    } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r2 of state.selection.ranges) {
      let prim = r2 == state.selection.main;
      if (r2.empty || conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor)) cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update2, dom) {
    if (update2.transactions.some((tr2) => tr2.selection)) dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update2);
    if (confChange) setBlinkRate(update2.state, dom);
    return update2.docChanged || update2.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r2) => r2.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r2)).reduce((a2, b) => a2.concat(b));
  },
  update(update2, dom) {
    return update2.docChanged || update2.selectionSet || update2.viewportChanged || configChanged(update2);
  },
  class: "cm-selectionLayer"
});
var hideNativeSelection = Prec.highest(EditorView.theme({
  ".cm-line": {
    "& ::selection, &::selection": {
      backgroundColor: "transparent !important"
    },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
}));
var setDropCursorPos = StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = StateField.define({
  create() {
    return null;
  },
  update(pos, tr2) {
    if (pos != null) pos = tr2.changes.mapPos(pos);
    return tr2.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
  }
});
var drawDropCursor = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = {
      read: this.readPos.bind(this),
      write: this.drawCursor.bind(this)
    };
  }
  update(update2) {
    var _a3;
    let cursorPos = update2.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a3 = this.cursor) === null || _a3 === void 0 ? void 0 : _a3.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update2.startState.field(dropCursorPos) != cursorPos || update2.docChanged || update2.geometryChanged) this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let {
      view
    } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect) return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let {
        scaleX,
        scaleY
      } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor) this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({
      effects: setDropCursorPos.of(pos)
    });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({
        x: event.clientX,
        y: event.clientY
      }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from, to2, f) {
  re.lastIndex = 0;
  for (let cursor = doc2.iterRange(from, to2), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;
  let result2 = [];
  for (let {
    from,
    to: to2
  } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to2 = Math.min(view.state.doc.lineAt(to2).to, to2 + maxLength);
    if (result2.length && result2[result2.length - 1].to >= from) result2[result2.length - 1].to = to2;
    else result2.push({
      from,
      to: to2
    });
  }
  return result2;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const {
      regexp,
      decoration,
      decorate,
      boundary,
      maxLength = 1e3
    } = config2;
    if (!regexp.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add4) => decorate(add4, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add4) => {
        let deco = decoration(match, view, from);
        if (deco) add4(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add4) => add4(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add4 = build.add.bind(build);
    for (let {
      from,
      to: to2
    } of matchRanges(view, this.maxLength)) iterMatches(view.state.doc, this.regexp, from, to2, (from2, m) => this.addMatch(m, view, from2, add4));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update2, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update2.docChanged) update2.changes.iterChanges((_f2, _t2, from, to2) => {
      if (to2 >= update2.view.viewport.from && from <= update2.view.viewport.to) {
        changeFrom = Math.min(from, changeFrom);
        changeTo = Math.max(to2, changeTo);
      }
    });
    if (update2.viewportMoved || changeTo - changeFrom > 1e3) return this.createDeco(update2.view);
    if (changeTo > -1) return this.updateRange(update2.view, deco.map(update2.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r2 of view.visibleRanges) {
      let from = Math.max(r2.from, updateFrom), to2 = Math.min(r2.to, updateTo);
      if (to2 >= from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to2 ? view.state.doc.lineAt(to2) : fromLine;
        let start = Math.max(r2.from, fromLine.from), end = Math.min(r2.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
            start = from;
            break;
          }
          for (; to2 < toLine.to; to2++) if (this.boundary.test(toLine.text[to2 - toLine.from])) {
            end = to2;
            break;
          }
        }
        let ranges = [], m;
        let add4 = (from2, to3, deco2) => ranges.push(deco2.range(from2, to3));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) this.addMatch(m, view, m.index + fromLine.from, add4);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add4));
        }
        deco = deco.update({
          filterFrom: start,
          filterTo: end,
          filter: (from2, to3) => from2 < start || to3 > end,
          add: ranges
        });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = new RegExp("[\0-\b\n--\u2028\u2029\uFEFF-]", UnicodeRegexpSupport);
var Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
var _supportsTabSize = null;
function supportsTabSize() {
  var _a3;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a3 = styles.tabSize) !== null && _a3 !== void 0 ? _a3 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize()) config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars) config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
var _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let {
            doc: doc2
          } = view.state;
          let code = codePointAt2(m[0], 0);
          if (code == 9) {
            let line = doc2.lineAt(pos);
            let size2 = view.state.tabSize, col = countColumn(line.text, size2, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size2 - col % size2) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({
            widget: new SpecialCharWidget(conf, code)
          }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update2) {
      let conf = update2.state.facet(specialCharConfig);
      if (update2.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update2.view);
      } else {
        this.decorations = this.decorator.updateDeco(update2, this.decorations);
      }
    }
  }, {
    decorations: (v) => v.decorations
  }));
}
var DefaultPlaceholder = "";
function placeholder$1(code) {
  if (code >= 32) return DefaultPlaceholder;
  if (code == 10) return "";
  return String.fromCharCode(9216 + code);
}
var SpecialCharWidget = class extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph2 = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph2);
    if (custom) return custom;
    let span = document.createElement("span");
    span.textContent = ph2;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var TabWidget = class extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
};
var plugin2 = ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1e3;
    this.attrs = {
      style: "padding-bottom: 1000px"
    };
  }
  update(update2) {
    let {
      view
    } = update2;
    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = {
        style: `padding-bottom: ${height}px`
      };
    }
  }
});
function highlightActiveLine() {
  return activeLineHighlighter;
}
var lineDeco = Decoration.line({
  class: "cm-activeLine"
});
var activeLineHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update2) {
    if (update2.docChanged || update2.selectionSet) this.decorations = this.getDeco(update2.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r2 of view.state.selection.ranges) {
      let line = view.lineBlockAt(r2.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var MaxOff = 2e3;
function rectangleFor(state, a2, b) {
  let startLine = Math.min(a2.line, b.line), endLine = Math.max(a2.line, b.line);
  let ranges = [];
  if (a2.off > MaxOff || b.off > MaxOff || a2.col < 0 || b.col < 0) {
    let startOff = Math.min(a2.off, b.off), endOff = Math.max(a2.off, b.off);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a2.col, b.col), endCol = Math.max(a2.col, b.col);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  let line = view.state.doc.lineAt(offset), off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return {
    line: line.number,
    col,
    off
  };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start) return null;
  return {
    update(update2) {
      if (update2.docChanged) {
        let newStart = update2.changes.mapPos(update2.startState.doc.line(start.line).from);
        let newLine = update2.state.doc.lineAt(newStart);
        start = {
          line: newLine.number,
          col: start.col,
          off: Math.min(start.off, newLine.length)
        };
        startSel = startSel.map(update2.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2) return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length) return startSel;
      if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));
      else return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter2 = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter2(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys2 = {
  Alt: [18, (e2) => !!e2.altKey],
  Control: [17, (e2) => !!e2.ctrlKey],
  Shift: [16, (e2) => !!e2.shiftKey],
  Meta: [91, (e2) => !!e2.metaKey]
};
var showCrosshair = {
  style: "cursor: crosshair"
};
function crosshairCursor(options = {}) {
  let [code, getter] = keys2[options.key || "Alt"];
  let plugin3 = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e2) {
        this.set(e2.keyCode == code || getter(e2));
      },
      keyup(e2) {
        if (e2.keyCode == code || !getter(e2)) this.set(false);
      },
      mousemove(e2) {
        this.set(getter(e2));
      }
    }
  });
  return [plugin3, EditorView.contentAttributes.of((view) => {
    var _a3;
    return ((_a3 = view.plugin(plugin3)) === null || _a3 === void 0 ? void 0 : _a3.isDown) ? showCrosshair : null;
  })];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t3) => t3);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t3) => prev = createTooltipView(t3, prev));
  }
  update(update2, above) {
    var _a3;
    let input = update2.state.facet(this.facet);
    let tooltips = input.filter((x) => x);
    if (input === this.input) {
      for (let t3 of this.tooltipViews) if (t3.update) t3.update(update2);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i2 = 0; i2 < tooltips.length; i2++) {
      let tip = tooltips[i2], known = -1;
      if (!tip) continue;
      for (let i3 = 0; i3 < this.tooltips.length; i3++) {
        let other = this.tooltips[i3];
        if (other && other.create == tip.create) known = i3;
      }
      if (known < 0) {
        tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
        if (newAbove) newAbove[i2] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
        if (newAbove) newAbove[i2] = above[known];
        if (tooltipView.update) tooltipView.update(update2);
      }
    }
    for (let t3 of this.tooltipViews) if (tooltipViews.indexOf(t3) < 0) {
      this.removeTooltipView(t3);
      (_a3 = t3.destroy) === null || _a3 === void 0 ? void 0 : _a3.call(t3);
    }
    if (above) {
      newAbove.forEach((val, i2) => above[i2] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return {
    top: 0,
    left: 0,
    bottom: docElt.clientHeight,
    right: docElt.clientWidth
  };
}
var tooltipConfig = Facet.define({
  combine: (values2) => {
    var _a3, _b, _c2;
    return {
      position: browser.ios ? "absolute" : ((_a3 = values2.find((conf) => conf.position)) === null || _a3 === void 0 ? void 0 : _a3.position) || "fixed",
      parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c2 = values2.find((conf) => conf.tooltipSpace)) === null || _c2 === void 0 ? void 0 : _c2.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = {
      read: this.readMeasure.bind(this),
      write: this.writeMeasure.bind(this),
      key: this
    };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t3, p2) => this.createTooltip(t3, p2), (t3) => {
      if (this.resizeObserver) this.resizeObserver.unobserve(t3.dom);
      t3.dom.remove();
    });
    this.above = this.manager.tooltips.map((t3) => !!t3.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();
    }, {
      threshold: [1]
    }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews) this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0) this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1;
      this.maybeMeasure();
    }, 50);
  }
  update(update2) {
    if (update2.transactions.length) this.lastTransaction = Date.now();
    let updated = this.manager.update(update2, this.above);
    if (updated) this.observeIntersection();
    let shouldMeasure = updated || update2.geometryChanged;
    let newConfig = update2.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t3 of this.manager.tooltipViews) t3.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent) this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t3 of this.manager.tooltipViews) this.container.appendChild(t3.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure) this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before2 = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before2);
    if (tooltipView.mount) tooltipView.mount(this.view);
    if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a3, _b, _c2;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a3 = tooltipView.destroy) === null || _a3 === void 0 ? void 0 : _a3.call(tooltipView);
    }
    if (this.parent) this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c2 = this.intersectionObserver) === null || _c2 === void 0 ? void 0 : _c2.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let {
        dom
      } = this.manager.tooltipViews[0];
      if (browser.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({
          scaleX,
          scaleY
        } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t3, i2) => {
        let tv2 = this.manager.tooltipViews[i2];
        return tv2.getCoords ? tv2.getCoords(t3.pos) : this.view.coordsAtPos(t3.pos);
      }),
      size: this.manager.tooltipViews.map(({
        dom
      }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a3;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t3 of this.manager.tooltipViews) t3.dom.style.position = "absolute";
    }
    let {
      visible,
      space,
      scaleX,
      scaleY
    } = measured;
    let others = [];
    for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
      let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], {
        dom
      } = tView;
      let pos = measured.pos[i2], size2 = measured.size[i2];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - 0.1 || pos.left > Math.min(visible.right, space.right) + 0.1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size2.right - size2.left, height = (_a3 = knownHeight.get(tView)) !== null && _a3 !== void 0 ? _a3 : size2.bottom - size2.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size2.width > space.right - space.left ? ltr ? space.left : space.right - size2.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
      let above = this.above[i2];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i2] = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r2 of others) if (r2.left < right && r2.right > left && r2.top < top2 + height && r2.bottom > top2) top2 = above ? r2.top - height - 2 - arrowHeight : r2.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top2 / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true) others.push({
        left,
        top: top2,
        right,
        bottom: top2 + height
      });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned) tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView) this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView) for (let tv2 of this.manager.tooltipViews) tv2.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt, value) {
  let current = parseInt(elt.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1) elt.style.left = value + "px";
}
var baseTheme = EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = {
  x: 0,
  y: 0
};
var showTooltip = Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = Facet.define({
  combine: (inputs) => inputs.reduce((a2, i2) => a2.concat(i2), [])
});
var HoverTooltipHost = class _HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t3, p2) => this.createHostedView(t3, p2), (t3) => t3.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount) hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount) hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned) hostedView.positioned(space);
    }
  }
  update(update2) {
    this.manager.update(update2);
  }
  destroy() {
    var _a3;
    for (let t3 of this.manager.tooltipViews) (_a3 = t3.destroy) === null || _a3 === void 0 ? void 0 : _a3.call(t3);
  }
  passProp(name2) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name2];
      if (given !== void 0) {
        if (value === void 0) value = given;
        else if (value !== given) return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips = state.facet(showHoverTooltip);
  if (tooltips.length === 0) return null;
  return {
    pos: Math.min(...tooltips.map((t3) => t3.pos)),
    end: Math.max(...tooltips.map((t3) => {
      var _a3;
      return (_a3 = t3.end) !== null && _a3 !== void 0 ? _a3 : t3.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some((t3) => t3.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = {
      x: 0,
      y: 0,
      target: view.dom,
      time: 0
    };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length) return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let {
      view,
      lastMove
    } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc) return;
    let pos, side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null) return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s2) => s2.from <= pos && s2.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = {
        pos
      };
      open.then((result2) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result2 && !(Array.isArray(result2) && !result2.length)) view.dispatch({
            effects: this.setHover.of(Array.isArray(result2) ? result2 : [result2])
          });
        }
      }, (e2) => logException(view.state, e2, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({
        effects: this.setHover.of(Array.isArray(open) ? open : [open])
      });
    }
  }
  get tooltip() {
    let plugin3 = this.view.plugin(tooltipPlugin);
    let index2 = plugin3 ? plugin3.manager.tooltips.findIndex((t3) => t3.create == HoverTooltipHost.create) : -1;
    return index2 > -1 ? plugin3.manager.tooltipViews[index2] : null;
  }
  mousemove(event) {
    var _a3, _b;
    this.lastMove = {
      x: event.clientX,
      y: event.clientY,
      target: event.target,
      time: Date.now()
    };
    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let {
      active,
      tooltip
    } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let {
        pos
      } = active[0] || this.pending, end = (_b = (_a3 = active[0]) === null || _a3 === void 0 ? void 0 : _a3.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
        this.view.dispatch({
          effects: this.setHover.of([])
        });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let {
      active
    } = this;
    if (active.length) {
      let {
        tooltip
      } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip) this.view.dispatch({
        effects: this.setHover.of([])
      });
      else this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = (event) => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({
        effects: this.setHover.of([])
      });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let {
    left,
    right,
    top: top2,
    bottom
  } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to2, x, y, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;
  let pos = view.posAtCoords({
    x,
    y
  }, false);
  return pos >= from && pos <= to2;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr2) {
      if (value.length) {
        if (options.hideOnChange && (tr2.docChanged || tr2.selection)) value = [];
        else if (options.hideOn) value = value.filter((v) => !options.hideOn(tr2, v));
        if (tr2.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr2.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy2.pos = newPos;
              if (copy2.end != null) copy2.end = tr2.changes.mapPos(copy2.end);
              mapped.push(copy2);
            }
          }
          value = mapped;
        }
      }
      for (let effect of tr2.effects) {
        if (effect.is(setHover)) value = effect.value;
        if (effect.is(closeHoverTooltipEffect)) value = [];
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return {
    active: hoverState,
    extension: [hoverState, ViewPlugin.define((view) => new HoverPlugin(
      view,
      source,
      hoverState,
      setHover,
      options.hoverTime || 300
      /* Hover.Time */
    )), showHoverTooltipHost]
  };
}
function getTooltip(view, tooltip) {
  let plugin3 = view.plugin(tooltipPlugin);
  if (!plugin3) return null;
  let found = plugin3.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin3.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = StateEffect.define();
var closeHoverTooltips = closeHoverTooltipEffect.of(null);
var panelConfig = Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c of configs) {
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return {
      topContainer,
      bottomContainer
    };
  }
});
function getPanel(view, panel) {
  let plugin3 = view.plugin(panelPlugin);
  let index2 = plugin3 ? plugin3.specs.indexOf(panel) : -1;
  return index2 > -1 ? plugin3.panels[index2] : null;
}
var panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s2) => s2);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p2) => p2.top));
    this.bottom.sync(this.panels.filter((p2) => !p2.top));
    for (let p2 of this.panels) {
      p2.dom.classList.add("cm-panel");
      if (p2.mount) p2.mount();
    }
  }
  update(update2) {
    let conf = update2.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update2.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update2.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update2.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x) => x);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update2.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update) panel.update(update2);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p2 of mount) {
        p2.dom.classList.add("cm-panel");
        if (p2.mount) p2.mount();
      }
    } else {
      for (let p2 of this.panels) if (p2.update) p2.update(update2);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin3) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin3);
    return value && {
      top: value.top.scrollMargin(),
      bottom: value.bottom.scrollMargin()
    };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p2 of this.panels) if (p2.destroy && panels.indexOf(p2) < 0) p2.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent2 = this.container || this.view.dom;
      parent2.insertBefore(this.dom, this.top ? parent2.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom) curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM) curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses) return;
    for (let cls of this.classes.split(" ")) if (cls) this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" ")) if (cls) this.container.classList.add(cls);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = Facet.define({
  enables: panelPlugin
});
var dialogField = StateField.define({
  create() {
    return [];
  },
  update(dialogs, tr2) {
    for (let e2 of tr2.effects) {
      if (e2.is(openDialogEffect)) dialogs = [e2.value].concat(dialogs);
      else if (e2.is(closeDialogEffect)) dialogs = dialogs.filter((d) => d != e2.value);
    }
    return dialogs;
  },
  provide: (f) => showPanel.computeN([f], (state) => state.field(f))
});
var openDialogEffect = StateEffect.define();
var closeDialogEffect = StateEffect.define();
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = Facet.define();
var gutterWidgetClass = Facet.define();
var defaults2 = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
};
var activeGutters = Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(__spreadValues(__spreadValues({}, defaults2), config2))];
}
var unfixGutters = Facet.define({
  combine: (values2) => values2.some((x) => x)
});
function gutters(config2) {
  let result2 = [gutterView];
  if (config2 && config2.fixed === false) result2.push(unfixGutters.of(true));
  return result2;
}
var gutterView = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.domAfter = null;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters cm-gutters-before";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    this.fixed = !view.state.facet(unfixGutters);
    for (let gutter2 of this.gutters) {
      if (gutter2.config.side == "after") this.getDOMAfter().appendChild(gutter2.dom);
      else this.dom.appendChild(gutter2.dom);
    }
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  getDOMAfter() {
    if (!this.domAfter) {
      this.domAfter = document.createElement("div");
      this.domAfter.className = "cm-gutters cm-gutters-after";
      this.domAfter.setAttribute("aria-hidden", "true");
      this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.domAfter.style.position = this.fixed ? "sticky" : "";
      this.view.scrollDOM.appendChild(this.domAfter);
    }
    return this.domAfter;
  }
  update(update2) {
    if (this.updateGutters(update2)) {
      let vpA = this.prevViewport, vpB = update2.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update2.geometryChanged) {
      let min2 = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = min2;
      if (this.domAfter) this.domAfter.style.minHeight = min2;
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
      if (this.domAfter) this.domAfter.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update2.view.viewport;
  }
  syncGutters(detach) {
    let after2 = this.dom.nextSibling;
    if (detach) {
      this.dom.remove();
      if (this.domAfter) this.domAfter.remove();
    }
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length) classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b of line.type) {
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (let cx of contexts) cx.line(this.view, b, classSet);
            first = false;
          } else if (b.widget) {
            for (let cx of contexts) cx.widget(this.view, b);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts) cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts) cx.widget(this.view, line);
      }
    }
    for (let cx of contexts) cx.finish();
    if (detach) {
      this.view.scrollDOM.insertBefore(this.dom, after2);
      if (this.domAfter) this.view.scrollDOM.appendChild(this.domAfter);
    }
  }
  updateGutters(update2) {
    let prev = update2.startState.facet(activeGutters), cur2 = update2.state.facet(activeGutters);
    let change = update2.docChanged || update2.heightChanged || update2.viewportChanged || !RangeSet.eq(update2.startState.facet(gutterLineClass), update2.state.facet(gutterLineClass), update2.view.viewport.from, update2.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters) if (gutter2.update(update2)) change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update2);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0) g.destroy();
      }
      for (let g of gutters2) {
        if (g.config.side == "after") this.getDOMAfter().appendChild(g.dom);
        else this.dom.appendChild(g.dom);
      }
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters) view.destroy();
    this.dom.remove();
    if (this.domAfter) this.domAfter.remove();
  }
}, {
  provide: (plugin3) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin3);
    if (!value || value.gutters.length == 0 || !value.fixed) return null;
    let before2 = value.dom.offsetWidth * view.scaleX, after2 = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
    return view.textDirection == Direction.LTR ? {
      left: before2,
      right: after2
    } : {
      right: before2,
      left: after2
    };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos) collect.push(cursor.value);
    cursor.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let {
      gutter: gutter2
    } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine) localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements) return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block.widget, block);
      if (marker2) (markers || (markers = [])).push(marker2);
    }
    if (markers) this.addElement(view, block, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last3 = gutter2.elements.pop();
      gutter2.dom.removeChild(last3.dom);
      last3.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom) target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event)) event.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update2) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update2.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update2);
      if (updated != this.spacer.markers[0]) this.spacer.update(update2.view, 0, 0, [updated]);
    }
    let vp2 = update2.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp2.from, vp2.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update2) : false);
  }
  destroy() {
    for (let elt of this.elements) elt.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c) cls += " " + c;
        for (let i2 = iOld; i2 < this.markers.length; i2++) if (this.markers[i2].compare(marker)) {
          skipTo = i2;
          matched = true;
          break;
        }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after2 = domPos.nextSibling;
          domPos.remove();
          domPos = after2;
        }
      }
      if (!marker) break;
      if (marker.toDOM) {
        if (matched) domPos = domPos.nextSibling;
        else this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched) iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a2, b) {
  if (a2.length != b.length) return false;
  for (let i2 = 0; i2 < a2.length; i2++) if (!a2[i2].compare(b[i2])) return false;
  return true;
}
var lineNumberMarkers = Facet.define();
var lineNumberWidgetMarker = Facet.define();
var lineNumberConfig = Facet.define({
  combine(values2) {
    return combineConfig(values2, {
      formatNumber: String,
      domEventHandlers: {}
    }, {
      domEventHandlers(a2, b) {
        let result2 = Object.assign({}, a2);
        for (let event in b) {
          let exists = result2[event], add4 = b[event];
          result2[event] = exists ? (view, line, event2) => exists(view, line, event2) || add4(view, line, event2) : add4;
        }
        return result2;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM)) return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m of view.state.facet(lineNumberWidgetMarker)) {
      let result2 = m(view, widget, block);
      if (result2) return result2;
    }
    return null;
  },
  lineMarkerChange: (update2) => update2.startState.facet(lineNumberConfig) != update2.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update2) {
    let max2 = formatNumber(update2.view, maxLineNumber(update2.view.state.doc.lines));
    return max2 == spacer.number ? spacer : new NumberMarker(max2);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
  side: "before"
}));
function lineNumbers(config2 = {}) {
  return [lineNumberConfig.of(config2), gutters(), lineNumberGutter];
}
function maxLineNumber(lines) {
  let last3 = 9;
  while (last3 < lines) last3 = last3 * 10 + 9;
  return last3;
}
var activeLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last3 = -1;
  for (let range2 of state.selection.ranges) {
    let linePos = state.doc.lineAt(range2.head).from;
    if (linePos > last3) {
      last3 = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
function matcher(decorator) {
  return ViewPlugin.define((view) => ({
    decorations: decorator.createDeco(view),
    update(u) {
      this.decorations = decorator.updateDeco(u, this.decorations);
    }
  }), {
    decorations: (v) => v.decorations
  });
}
var tabDeco = Decoration.mark({
  class: "cm-highlightTab"
});
var spaceDeco = Decoration.mark({
  class: "cm-highlightSpace"
});
var whitespaceHighlighter = matcher(new MatchDecorator({
  regexp: /\t| /g,
  decoration: (match) => match[0] == "	" ? tabDeco : spaceDeco,
  boundary: /\S/
}));
var trailingHighlighter = matcher(new MatchDecorator({
  regexp: /\s+$/g,
  decoration: Decoration.mark({
    class: "cm-trailingSpace"
  })
}));

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from, to2) {
    this.from = from;
    this.to = to2;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function") match = NodeType.match(match);
    return (type) => {
      let result2 = match(type);
      return result2 === void 0 ? null : [this, result2];
    };
  }
};
NodeProp.closedBy = new NodeProp({
  deserialize: (str) => str.split(" ")
});
NodeProp.openedBy = new NodeProp({
  deserialize: (str) => str.split(" ")
});
NodeProp.group = new NodeProp({
  deserialize: (str) => str.split(" ")
});
NodeProp.isolate = new NodeProp({
  deserialize: (value) => {
    if (value && value != "rtl" && value != "ltr" && value != "auto") throw new RangeError("Invalid value for isolate: " + value);
    return value || "auto";
  }
});
NodeProp.contextHash = new NodeProp({
  perNode: true
});
NodeProp.lookAhead = new NodeProp({
  perNode: true
});
NodeProp.mounted = new NodeProp({
  perNode: true
});
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props) for (let src of spec.props) {
      if (!Array.isArray(src)) src = src(type);
      if (src) {
        if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
        props[src[0].id] = src[1];
      }
    }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2) return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map2) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map2) for (let name2 of prop.split(" ")) direct[name2] = map2[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
        let found = direct[i2 < 0 ? node.name : groups[i2]];
        if (found) return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i2 = 0; i2 < types2.length; i2++) if (types2[i2].id != i2) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add4 = source(type);
        if (add4) {
          if (!newProps) newProps = Object.assign({}, type.props);
          newProps[add4[0].id] = add4[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props) this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay) return mounted.tree.toString();
    let children = "";
    for (let ch2 of this.children) {
      let str = ch2.toString();
      if (str) {
        if (children) children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let {
      enter,
      leave,
      from = 0,
      to: to2 = this.length
    } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to2 && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild()) continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);
        if (c.nextSibling()) break;
        if (!c.parent()) return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result2 = [];
    if (this.props) for (let id2 in this.props) result2.push([+id2, this.props[id2]]);
    return result2;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set2) {
    this.buffer = buffer;
    this.length = length;
    this.set = set2;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result2 = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result2.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result2.join(",");
  }
  /**
  @internal
  */
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type = this.set.types[id2], result2 = type.name;
    if (/\W/.test(result2) && !type.isError) result2 = JSON.stringify(result2);
    index2 += 4;
    if (endIndex == index2) return result2;
    let children = [];
    while (index2 < endIndex) {
      children.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result2 + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let {
      buffer
    } = this, pick2 = -1;
    for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
      if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
        pick2 = i2;
        if (dir > 0) break;
      }
    }
    return pick2;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy2 = new Uint16Array(endI - startI), len = 0;
    for (let i2 = startI, j = 0; i2 < endI; ) {
      copy2[j++] = b[i2++];
      copy2[j++] = b[i2++] - from;
      let to2 = copy2[j++] = b[i2++] - from;
      copy2[j++] = b[i2++] - startI;
      len = Math.max(len, to2);
    }
    return new _TreeBuffer(copy2, len, this.set);
  }
};
function checkSide(side, pos, from, to2) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to2 >= pos && from < pos;
    case 0:
      return from < pos && to2 > pos;
    case 1:
      return from <= pos && to2 > pos;
    case 2:
      return to2 > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a3;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent2 = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent2) return node;
    node = parent2;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays) for (let scan = node, parent2 = scan.parent; parent2; scan = parent2, parent2 = scan.parent) {
    if (scan instanceof TreeNode && scan.index < 0 && ((_a3 = parent2.enter(pos, side, mode)) === null || _a3 === void 0 ? void 0 : _a3.from) != scan.from) node = parent2;
  }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner) return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before2 = null, after2 = null) {
    let r2 = getChildren(this, type, before2, after2);
    return r2.length ? r2[0] : null;
  }
  getChildren(type, before2 = null, after2 = null) {
    return getChildren(this, type, before2, after2);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last3 = scan.lastChild;
      if (!last3 || last3.to != scan.to) break;
      if (last3.type.isError && last3.from == last3.to) {
        node = scan;
        scan = last3.prevSibling;
      } else {
        scan = last3;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index2, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i2, dir, pos, side, mode = 0) {
    for (let parent2 = this; ; ) {
      for (let {
        children,
        positions
      } = parent2._tree, e2 = dir > 0 ? children.length : -1; i2 != e2; i2 += dir) {
        let next = children[i2], start = positions[i2] + parent2.from;
        if (!checkSide(side, pos, start, start + next.length)) continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers) continue;
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index2 > -1) return new BufferNode(new BufferContext(parent2, next, i2, start), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new _TreeNode(mounted.tree, start, i2, parent2);
          let inner = new _TreeNode(next, start, i2, parent2);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent2.type.isAnonymous) return null;
      if (parent2.index >= 0) i2 = parent2.index + dir;
      else i2 = dir < 0 ? -1 : parent2._parent._tree.children.length;
      parent2 = parent2._parent;
      if (!parent2) return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let {
        from,
        to: to2
      } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos)) return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent) val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before2, after2) {
  let cur2 = node.cursor(), result2 = [];
  if (!cur2.firstChild()) return result2;
  if (before2 != null) for (let found = false; !found; ) {
    found = cur2.type.is(before2);
    if (!cur2.nextSibling()) return result2;
  }
  for (; ; ) {
    if (after2 != null && cur2.type.is(after2)) return result2;
    if (cur2.type.is(type)) result2.push(cur2.node);
    if (!cur2.nextSibling()) return after2 == null ? result2 : [];
  }
}
function matchNodeContext(node, context, i2 = context.length - 1) {
  for (let p2 = node; i2 >= 0; p2 = p2.parent) {
    if (!p2) return false;
    if (!p2.type.isAnonymous) {
      if (context[i2] && context[i2] != p2.name) return false;
      i2--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent2, buffer, index2, start) {
    this.parent = parent2;
    this.buffer = buffer;
    this.index = index2;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index2) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  child(dir, pos, side) {
    let {
      buffer
    } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers) return null;
    let {
      buffer
    } = this.context;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new _BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let {
      buffer
    } = this.context;
    let after2 = buffer.buffer[this.index + 3];
    if (after2 < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new _BufferNode(this.context, this._parent, after2);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let {
      buffer
    } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart) return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let {
      buffer
    } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length) return null;
  let pick2 = 0, picked = heads[0];
  for (let i2 = 1; i2 < heads.length; i2++) {
    let node = heads[i2];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick2 = i2;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next) newHeads[pick2] = next;
  else newHeads.splice(pick2, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent2 = scan.parent;
      (layers || (layers = [inner])).push(parent2.resolve(pos, side));
      scan = parent2;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root2 = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root2, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n2 = node._parent; n2; n2 = n2._parent) this.stack.unshift(n2.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node) return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index2, type) {
    this.index = index2;
    let {
      start,
      buffer
    } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index2]];
    this.from = start + buffer.buffer[index2 + 1];
    this.to = start + buffer.buffer[index2 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node) return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let {
      buffer
    } = this.buffer;
    let index2 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0) return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let parent2 = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent2);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let {
      buffer
    } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(
        parentStart,
        this.index,
        -1,
        0,
        4
        /* Side.DontCare */
      ));
    } else {
      let after2 = buffer.buffer[this.index + 3];
      if (after2 < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after2);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent2, {
      buffer
    } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length) return false;
      } else {
        for (let i2 = 0; i2 < this.index; i2++) if (buffer.buffer.buffer[i2 + 3] < this.index) return false;
      }
      ({
        index: index2,
        parent: parent2
      } = buffer);
    } else {
      ({
        index: index2,
        _parent: parent2
      } = this._tree);
    }
    for (; parent2; {
      index: index2,
      _parent: parent2
    } = parent2) {
      if (index2 > -1) for (let i2 = index2 + dir, e2 = dir < 0 ? -1 : parent2._tree.children.length; i2 != e2; i2 += dir) {
        let child = parent2._tree.children[i2];
        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
      }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    )) return true;
    for (; ; ) {
      if (this.sibling(dir)) return true;
      if (this.atLastNode(dir) || !this.parent()) return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer) return this._tree;
    let cache = this.bufferNode, result2 = null, depth2 = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache; c; c = c._parent) if (c.index == index2) {
          if (index2 == this.index) return c;
          result2 = c;
          depth2 = d + 1;
          break scan;
        }
        index2 = this.stack[--d];
      }
    }
    for (let i2 = depth2; i2 < this.stack.length; i2++) result2 = new BufferNode(this.buffer, result2, this.stack[i2]);
    return this.bufferNode = new BufferNode(this.buffer, result2, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth2 = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth2++;
          continue;
        }
        if (!this.type.isAnonymous) mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave) leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth2) return;
        if (this.nextSibling()) break;
        this.parent();
        depth2--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer) return matchNodeContext(this.node.parent, context);
    let {
      buffer
    } = this.buffer, {
      types: types2
    } = buffer.set;
    for (let i2 = context.length - 1, d = this.stack.length - 1; i2 >= 0; d--) {
      if (d < 0) return matchNodeContext(this._tree, context, i2);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i2] && context[i2] != type.name) return false;
        i2--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
}
function buildTree(data) {
  var _a3;
  let {
    buffer,
    nodeSet: nodeSet2,
    maxBufferLength = DefaultBufferLength,
    reused = [],
    minRepeatType = nodeSet2.types.length
  } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet2.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth2) {
    let {
      id: id2,
      start,
      end,
      size: size2
    } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size2 < 0) {
      cursor.next();
      if (size2 == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size2 == -3) {
        contextHash = id2;
        return;
      } else if (size2 == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size2}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index2 = data2.length;
      while (cursor.pos > endPos) index2 = copyToBuffer(buffer2.start, data2, index2);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet2);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size2;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth2 > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth2 + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let {
        id: id2,
        start,
        end,
        size: size2
      } = cursor;
      if (size2 > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0) stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
        buffer2[j++] = nodes[i2];
        buffer2[j++] = nodes[i2 + 1] - start;
        buffer2[j++] = nodes[i2 + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet2));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last3, lookAheadProp;
      if (lastI >= 0 && (last3 = children2[lastI]) instanceof Tree) {
        if (!lastI && last3.type == type && last3.length == length2) return last3;
        if (lookAheadProp = last3.prop(NodeProp.lookAhead)) lookAhead2 = positions2[lastI] + last3.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i2, from, to2, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i2) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet2.types[type], localChildren, localPositions, to2 - from, lookAhead2 - to2, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size2 = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result2 = {
      size: 0,
      start: 0,
      skip: 0
    };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result2.size = size2;
        result2.start = start;
        result2.skip = skip;
        skip += 4;
        size2 += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart) break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3) localSkipped += 4;
          else break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size2 += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size2 == maxSize) {
      result2.size = size2;
      result2.start = start;
      result2.skip = skip;
    }
    return result2.size > 4 ? result2 : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let {
      id: id2,
      start,
      end,
      size: size2
    } = cursor;
    cursor.next();
    if (size2 >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size2 > 4) {
        let endPos = cursor.pos - (size2 - 4);
        while (cursor.pos > endPos) index2 = copyToBuffer(bufferStart, buffer2, index2);
      }
      buffer2[--index2] = startIndex;
      buffer2[--index2] = end - bufferStart;
      buffer2[--index2] = start - bufferStart;
      buffer2[--index2] = id2;
    } else if (size2 == -3) {
      contextHash = id2;
    } else if (size2 == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children = [], positions = [];
  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a3 = data.length) !== null && _a3 !== void 0 ? _a3 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
  let size2 = nodeSizeCache.get(node);
  if (size2 == null) {
    size2 = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size2 = 1;
        break;
      }
      size2 += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size2);
  }
  return size2;
}
function balanceRange(balanceType, children, positions, from, to2, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i2 = from; i2 < to2; i2++) total += nodeSize(balanceType, children[i2]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide2(children2, positions2, from2, to3, offset) {
    for (let i2 = from2; i2 < to3; ) {
      let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
      i2++;
      for (; i2 < to3; i2++) {
        let nextSize = nodeSize(balanceType, children2[i2]);
        if (groupSize + nextSize >= maxChild) break;
        groupSize += nextSize;
      }
      if (i2 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide2(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide2(children, positions, from, to2, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to2, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to2;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial2 = false) {
    let result2 = [new _TreeFragment(0, tree.length, tree, 0, false, partial2)];
    for (let f of fragments) if (f.to > tree.length) result2.push(f);
    return result2;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length) return fragments;
    let result2 = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {
        let cut = nextF;
        if (pos >= cut.from || nextPos <= cut.to || off) {
          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
          cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
        }
        if (cut) result2.push(cut);
        if (nextF.to > nextPos) break;
        nextF = fI < fragments.length ? fragments[fI++] : null;
      }
      if (!nextC) break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result2;
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string") input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r2) => new Range2(r2.from, r2.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done) return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to2) {
    return this.string.slice(from, to2);
  }
};
var stoppedInner = new NodeProp({
  perNode: true
});

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set2, base2, modified) {
    this.name = name2;
    this.set = set2;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let {
      name: name2
    } = this;
    for (let mod of this.modified) if (mod.name) name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent2) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag) parent2 = nameOrParent;
    if (parent2 === null || parent2 === void 0 ? void 0 : parent2.base) throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent2) for (let t3 of parent2.set) tag.set.push(t3);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1) return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a2, b) => a2.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length) return base2;
    let exists = mods[0].instances.find((t3) => t3.base == base2 && sameArray2(mods, t3.modified));
    if (exists) return exists;
    let set2 = [], tag = new Tag(base2.name, set2, base2, mods);
    for (let m of mods) m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent2 of base2.set) if (!parent2.modified.length) for (let config2 of configs) set2.push(_Modifier.get(parent2, config2));
    return tag;
  }
};
function sameArray2(a2, b) {
  return a2.length == b.length && a2.every((x, i2) => x == b[i2]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i2 = 0; i2 < array.length; i2++) {
    for (let j = 0, e2 = sets.length; j < e2; j++) {
      sets.push(sets[j].concat(array[i2]));
    }
  }
  return sets.sort((a2, b) => b.length - a2.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2)) tags2 = [tags2];
    for (let part of prop.split(" ")) if (part) {
      let pieces = [], mode = 2, rest2 = part;
      for (let pos = 0; ; ) {
        if (rest2 == "..." && pos > 0 && pos + 3 == part.length) {
          mode = 1;
          break;
        }
        let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest2);
        if (!m) throw new RangeError("Invalid path: " + part);
        pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
        pos += m[0].length;
        if (pos == part.length) break;
        let next = part[pos++];
        if (pos == part.length && next == "!") {
          mode = 0;
          break;
        }
        if (next != "/") throw new RangeError("Invalid path: " + part);
        rest2 = part.slice(pos);
      }
      let last3 = pieces.length - 1, inner = pieces[last3];
      if (!inner) throw new RangeError("Invalid path: " + part);
      let rule = new Rule(tags2, mode, last3 > 0 ? pieces.slice(0, last3) : null);
      byName[inner] = rule.sort(byName[inner]);
    }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map2 = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag)) map2[style.tag.id] = style.class;
    else for (let tag of style.tag) map2[tag.id] = style.class;
  }
  let {
    scope,
    all = null
  } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map2[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result2 = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value) result2 = result2 ? result2 + " " + value : value;
  }
  return result2;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to2 = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to2, "", builder.highlighters);
  builder.flush(to2);
}
var HighlightBuilder = class {
  constructor(at4, highlighters, span) {
    this.at = at4;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at4, cls) {
    if (cls != this.class) {
      this.flush(at4);
      if (at4 > this.at) this.at = at4;
      this.class = cls;
    }
  }
  flush(to2) {
    if (to2 > this.at && this.class) this.span(this.at, to2, this.class);
  }
  highlightRange(cursor, from, to2, inheritedClass, highlighters) {
    let {
      type,
      from: start,
      to: end
    } = cursor;
    if (start >= to2 || end <= from) return;
    if (type.isTop) highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls) cls += " ";
      cls += tagCls;
      if (rule.mode == 1) inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque) return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i2 = 0, pos = start; ; i2++) {
        let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to2, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor.from < rangeTo2) {
            this.highlightRange(cursor, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling()) break;
          }
        }
        if (!next || nextPos > to2) break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to2, pos), "", innerHighlighters);
          this.startSpan(Math.min(to2, pos), cls);
        }
      }
      if (hasChild2) cursor.parent();
    } else if (cursor.firstChild()) {
      if (mounted) inheritedClass = "";
      do {
        if (cursor.to <= from) continue;
        if (cursor.from >= to2) break;
        this.highlightRange(cursor, from, to2, inheritedClass, highlighters);
        this.startSpan(Math.min(to2, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;
  return rule || null;
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag) val.name = name2;
}
var classHighlighter = tagHighlighter([{
  tag: tags.link,
  class: "tok-link"
}, {
  tag: tags.heading,
  class: "tok-heading"
}, {
  tag: tags.emphasis,
  class: "tok-emphasis"
}, {
  tag: tags.strong,
  class: "tok-strong"
}, {
  tag: tags.keyword,
  class: "tok-keyword"
}, {
  tag: tags.atom,
  class: "tok-atom"
}, {
  tag: tags.bool,
  class: "tok-bool"
}, {
  tag: tags.url,
  class: "tok-url"
}, {
  tag: tags.labelName,
  class: "tok-labelName"
}, {
  tag: tags.inserted,
  class: "tok-inserted"
}, {
  tag: tags.deleted,
  class: "tok-deleted"
}, {
  tag: tags.literal,
  class: "tok-literal"
}, {
  tag: tags.string,
  class: "tok-string"
}, {
  tag: tags.number,
  class: "tok-number"
}, {
  tag: [tags.regexp, tags.escape, tags.special(tags.string)],
  class: "tok-string2"
}, {
  tag: tags.variableName,
  class: "tok-variableName"
}, {
  tag: tags.local(tags.variableName),
  class: "tok-variableName tok-local"
}, {
  tag: tags.definition(tags.variableName),
  class: "tok-variableName tok-definition"
}, {
  tag: tags.special(tags.variableName),
  class: "tok-variableName2"
}, {
  tag: tags.definition(tags.propertyName),
  class: "tok-propertyName tok-definition"
}, {
  tag: tags.typeName,
  class: "tok-typeName"
}, {
  tag: tags.namespace,
  class: "tok-namespace"
}, {
  tag: tags.className,
  class: "tok-className"
}, {
  tag: tags.macroName,
  class: "tok-macroName"
}, {
  tag: tags.propertyName,
  class: "tok-propertyName"
}, {
  tag: tags.operator,
  class: "tok-operator"
}, {
  tag: tags.comment,
  class: "tok-comment"
}, {
  tag: tags.meta,
  class: "tok-meta"
}, {
  tag: tags.invalid,
  class: "tok-invalid"
}, {
  tag: tags.punctuation,
  class: "tok-punctuation"
}]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
var sublanguageProp = new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser2, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree")) Object.defineProperty(EditorState.prototype, "tree", {
      get() {
        return syntaxTree(this);
      }
    });
    this.parser = parser2;
    this.extension = [language.of(this), EditorState.languageData.of((state, pos, side) => {
      let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
      if (!data2) return [];
      let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
      if (sub) {
        let innerNode = top2.resolve(pos - top2.from, side);
        for (let sublang of sub) if (sublang.test(innerNode, state)) {
          let data3 = state.facet(sublang.facet);
          return sublang.type == "replace" ? data3 : data3.concat(base2);
        }
      }
      return base2;
    })].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{
      from: 0,
      to: state.doc.length
    }];
    if (!lang || !lang.allowsNesting) return [];
    let result2 = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result2.push({
          from,
          to: from + tree.length
        });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay) for (let r2 of mount.overlay) result2.push({
            from: r2.from + from,
            to: r2.to + from
          });
          else result2.push({
            from,
            to: from + tree.length
          });
          return;
        } else if (mount.overlay) {
          let size2 = result2.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result2.length > size2) return;
        }
      }
      for (let i2 = 0; i2 < tree.children.length; i2++) {
        let ch2 = tree.children[i2];
        if (ch2 instanceof Tree) explore(ch2, tree.positions[i2] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result2;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers)) if (node.type.isTop) tree = node;
  }
  return tree;
}
var LRLanguage = class _LRLanguage extends Language {
  constructor(data, parser2, name2) {
    super(data, parser2, [], name2);
    this.parser = parser2;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new _LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new _LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to2) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to2 >= this.cursorPos) return this.doc.sliceString(from, to2);
    else return this.string.slice(from - stringStart, to2 - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser2, state, viewport) {
    return new _ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length) upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a3;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse) this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a3 = this.parse.stoppedAt) !== null && _a3 !== void 0 ? _a3 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();
          else return true;
        }
        if (until()) return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; r2 = this.tempSkipped.pop(); ) fragments = cutFragments(fragments, r2.from, r2.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let {
      fragments,
      tree,
      treeLen,
      viewport,
      skipped
    } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({
        fromA,
        toA,
        fromB,
        toB
      }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = {
        from: changes.mapPos(viewport.from, -1),
        to: changes.mapPos(viewport.to, 1)
      };
      if (this.skipped.length) {
        skipped = [];
        for (let r2 of this.skipped) {
          let from = changes.mapPos(r2.from, 1), to2 = changes.mapPos(r2.to, -1);
          if (from < to2) skipped.push({
            from,
            to: to2
          });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i2 = 0; i2 < this.skipped.length; i2++) {
      let {
        from,
        to: to2
      } = this.skipped[i2];
      if (from < viewport.to && to2 > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to2);
        this.skipped.splice(i2--, 1);
      }
    }
    if (this.skipped.length >= startLen) return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to2) {
    this.skipped.push({
      from,
      to: to2
    });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to2 = ranges[ranges.length - 1].to;
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r2 of ranges) cx.tempSkipped.push(r2);
              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to2;
            return new Tree(NodeType.none, [], [], to2 - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to2) {
  return TreeFragment.applyChanges(fragments, [{
    fromA: from,
    toA: to2,
    fromB: from,
    toB: to2
  }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr2) {
    if (!tr2.docChanged && this.tree == this.context.tree) return this;
    let newCx = this.context.changes(tr2.changes, tr2.state);
    let upto = this.context.treeLen == tr2.startState.doc.length ? void 0 : Math.max(tr2.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto)) newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, {
      from: 0,
      to: vpTo
    });
    if (!parseState.work(20, vpTo)) parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = StateField.define({
  create: LanguageState.init,
  update(value, tr2) {
    for (let e2 of tr2.effects) if (e2.is(Language.setState)) return e2.value;
    if (tr2.startState.facet(language) != tr2.state.facet(language)) return LanguageState.init(tr2.state);
    return value.apply(tr2);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined") requestIdle = (callback) => {
  let idle = -1, timeout = setTimeout(
    () => {
      idle = requestIdleCallback(callback, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
};
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update2) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update2.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
    if (update2.docChanged || update2.selectionSet) {
      if (this.view.hasFocus) this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working) return;
    let {
      state
    } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now2 = Date.now();
    if (this.chunkEnd < now2 && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now2 + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0) return;
    let {
      state,
      viewport: {
        to: vpTo
      }
    } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    )) return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now2;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({
        effects: Language.setState.of(new LanguageState(field.context))
      });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working) this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: {
    focus() {
      this.scheduleWork();
    }
  }
});
var language = Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [Language.state, parseWorker, EditorView.contentAttributes.compute([language2], (state) => {
    let lang = state.facet(language2);
    return lang && lang.name ? {
      "data-language": lang.name
    } : {};
  })]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentService = Facet.define();
var indentUnit = Facet.define({
  combine: (values2) => {
    if (!values2.length) return "  ";
    let unit = values2[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e2) => e2 != unit[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result2 = "", ts2 = state.tabSize, ch2 = state.facet(indentUnit)[0];
  if (ch2 == "	") {
    while (cols >= ts2) {
      result2 += "	";
      cols -= ts2;
    }
    ch2 = " ";
  }
  for (let i2 = 0; i2 < cols; i2++) result2 += ch2;
  return result2;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState) context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result2 = service(context, pos);
    if (result2 !== void 0) return result2;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let {
      simulateBreak,
      simulateDoubleBreak
    } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos) return {
        text: "",
        from: pos
      };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
        text: line.text.slice(simulateBreak - line.from),
        from: simulateBreak
      };
      else return {
        text: line.text.slice(0, simulateBreak - line.from),
        from: line.from
      };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let result2 = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1) result2 += override - this.countColumn(text, text.search(/\S|$/));
    return result2;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1) return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add4 = [];
    for (let cur2 = inner; cur2 && !(cur2.from < stack.node.from || cur2.to > stack.node.to || cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent) add4.push(cur2);
    for (let i2 = add4.length - 1; i2 >= 0; i2--) stack = {
      node: add4[i2],
      next: stack
    };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy) return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last3 = tree.lastChild, closed = last3 && close.indexOf(last3.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last3.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;
      if (isParent(atBreak, node)) break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent2, of2) {
  for (let cur2 = of2; cur2; cur2 = cur2.parent) if (parent2 == cur2) return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last3 = tree.lastChild;
  if (!openToken) return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last3) return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd) return null;
      let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return {
        from: openToken.from,
        to: openToken.to + space
      };
    }
    pos = next.to;
  }
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after2 = context.textAfter, space = after2.match(/^\s*/)[0].length;
  let closed = closing2 && after2.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function continuedIndent({
  except,
  units = 1
} = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr2) => {
    if (!tr2.docChanged || !tr2.isUserEvent("input.type") && !tr2.isUserEvent("input.complete")) return tr2;
    let rules = tr2.startState.languageDataAt("indentOnInput", tr2.startState.selection.main.head);
    if (!rules.length) return tr2;
    let doc2 = tr2.newDoc, {
      head: head2
    } = tr2.newSelection.main, line = doc2.lineAt(head2);
    if (head2 > line.from + DontIndentBeyond) return tr2;
    let lineStart = doc2.sliceString(line.from, head2);
    if (!rules.some((r2) => r2.test(lineStart))) return tr2;
    let {
      state
    } = tr2, last3 = -1, changes = [];
    for (let {
      head: head3
    } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head3);
      if (line2.from == last3) continue;
      last3 = line2.from;
      let indent = getIndentation(state, line2.from);
      if (indent == null) continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm) changes.push({
        from: line2.from,
        to: line2.from + cur2.length,
        insert: norm
      });
    }
    return changes.length ? [tr2, {
      changes,
      sequential: true
    }] : tr2;
  });
}
var foldService = Facet.define();
var foldNodeProp = new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last3 = node.lastChild;
  return first && first.to < last3.from ? {
    from: first.to,
    to: last3.type.isError ? node.to : last3.from
  } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end) return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end) continue;
    if (found && cur2.from < start) break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end) found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch2 = node.lastChild;
  return ch2 && ch2.to == node.to && ch2.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result2 = service(state, lineStart, lineEnd);
    if (result2) return result2;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range2, mapping) {
  let from = mapping.mapPos(range2.from, 1), to2 = mapping.mapPos(range2.to, -1);
  return from >= to2 ? void 0 : {
    from,
    to: to2
  };
}
var foldEffect = StateEffect.define({
  map: mapRange
});
var unfoldEffect = StateEffect.define({
  map: mapRange
});
function selectedLines(view) {
  let lines = [];
  for (let {
    head: head2
  } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head2 && l.to >= head2)) continue;
    lines.push(view.lineBlockAt(head2));
  }
  return lines;
}
var foldState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr2) {
    if (tr2.isUserEvent("delete")) tr2.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
    folded = folded.map(tr2.changes);
    for (let e2 of tr2.effects) {
      if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to)) {
        let {
          preparePlaceholder
        } = tr2.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({
          widget: new PreparedFoldWidget(preparePlaceholder(tr2.state, e2.value))
        });
        folded = folded.update({
          add: [widget.range(e2.value.from, e2.value.to)]
        });
      } else if (e2.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to2) => e2.value.from != from || e2.value.to != to2,
          filterFrom: e2.value.from,
          filterTo: e2.value.to
        });
      }
    }
    if (tr2.selection) folded = clearTouchedFolds(folded, tr2.selection.main.head);
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to2) => {
      ranges.push(from, to2);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2) throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i2 = 0; i2 < value.length; ) {
      let from = value[i2++], to2 = value[i2++];
      if (typeof from != "number" || typeof to2 != "number") throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to2));
    }
    return Decoration.set(ranges, true);
  }
});
function clearTouchedFolds(folded, from, to2 = from) {
  let touched = false;
  folded.between(from, to2, (a2, b) => {
    if (a2 < to2 && b > from) touched = true;
  });
  return !touched ? folded : folded.update({
    filterFrom: from,
    filterTo: to2,
    filter: (a2, b) => a2 >= to2 || b <= from
  });
}
function findFold(state, from, to2) {
  var _a3;
  let found = null;
  (_a3 = state.field(foldState, false)) === null || _a3 === void 0 ? void 0 : _a3.between(from, to2, (from2, to3) => {
    if (!found || found.from > from2) found = {
      from: from2,
      to: to3
    };
  });
  return found;
}
function foldExists(folded, from, to2) {
  let found = false;
  folded.between(from, from, (a2, b) => {
    if (a2 == from && b == to2) found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range2 = foldable(view.state, line.from, line.to);
    if (range2) {
      view.dispatch({
        effects: maybeEnable(view.state, [foldEffect.of(range2), announceFold(view, range2)])
      });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false)) return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length) view.dispatch({
    effects
  });
  return effects.length > 0;
};
function announceFold(view, range2, fold = true) {
  let lineFrom = view.state.doc.lineAt(range2.from).number, lineTo = view.state.doc.lineAt(range2.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let {
    state
  } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range2 = foldable(state, line.from, line.to);
    if (range2) effects.push(foldEffect.of(range2));
    pos = (range2 ? view.lineBlockAt(range2.to) : line).to + 1;
  }
  if (effects.length) view.dispatch({
    effects: maybeEnable(view.state, effects)
  });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size) return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to2) => {
    effects.push(unfoldEffect.of({
      from,
      to: to2
    }));
  });
  view.dispatch({
    effects
  });
  return true;
};
var foldKeymap = [{
  key: "Ctrl-Shift-[",
  mac: "Cmd-Alt-[",
  run: foldCode
}, {
  key: "Ctrl-Shift-]",
  mac: "Cmd-Alt-]",
  run: unfoldCode
}, {
  key: "Ctrl-Alt-[",
  run: foldAll
}, {
  key: "Ctrl-Alt-]",
  run: unfoldAll
}];
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
};
var foldConfig = Facet.define({
  combine(values2) {
    return combineConfig(values2, defaultConfig);
  }
});
function codeFolding(config2) {
  let result2 = [foldState, baseTheme$12];
  if (config2) result2.push(foldConfig.of(config2));
  return result2;
}
function widgetToDOM(view, prepared) {
  let {
    state
  } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded) view.dispatch({
      effects: unfoldEffect.of(folded)
    });
    event.preventDefault();
  };
  if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = Decoration.replace({
  widget: new class extends WidgetType {
    toDOM(view) {
      return widgetToDOM(view, null);
    }
  }()
});
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var foldGutterDefaults = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var FoldMarker = class extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
};
function foldGutter(config2 = {}) {
  let fullConfig = __spreadValues(__spreadValues({}, foldGutterDefaults), config2);
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update2) {
      if (update2.docChanged || update2.viewportChanged || update2.startState.facet(language) != update2.state.facet(language) || update2.startState.field(foldState, false) != update2.state.field(foldState, false) || syntaxTree(update2.startState) != syntaxTree(update2.state) || fullConfig.foldingChanged(update2)) this.markers = this.buildMarkers(update2.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark) builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let {
    domEventHandlers
  } = fullConfig;
  return [markers, gutter({
    class: "cm-foldGutter",
    markers(view) {
      var _a3;
      return ((_a3 = view.plugin(markers)) === null || _a3 === void 0 ? void 0 : _a3.markers) || RangeSet.empty;
    },
    initialSpacer() {
      return new FoldMarker(fullConfig, false);
    },
    domEventHandlers: __spreadProps(__spreadValues({}, domEventHandlers), {
      click: (view, line, event) => {
        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({
            effects: unfoldEffect.of(folded)
          });
          return true;
        }
        let range2 = foldable(view.state, line.from, line.to);
        if (range2) {
          view.dispatch({
            effects: foldEffect.of(range2)
          });
          return true;
        }
        return false;
      }
    })
  }), codeFolding()];
}
var baseTheme$12 = EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, {
        tag: null
      }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new _HighlightStyle(specs, options || {});
  }
};
var highlighterFacet = Facet.define();
var fallbackHighlighter = Facet.define({
  combine(values2) {
    return values2.length ? [values2[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module) ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType) ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
    return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
  }));
  else ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update2) {
    let tree = syntaxTree(update2.state), highlighters = getHighlighters(update2.state);
    let styleChange = highlighters != getHighlighters(update2.startState);
    let {
      viewport
    } = update2.view, decoratedToMapped = update2.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update2.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update2.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update2.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length) return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let {
      from,
      to: to2
    } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to3, style) => {
        builder.add(from2, to3, this.markCache[style] || (this.markCache[style] = Decoration.mark({
          class: style
        })));
      }, from, to2);
    }
    return builder.finish();
  }
};
var treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = HighlightStyle.define([{
  tag: tags.meta,
  color: "#404740"
}, {
  tag: tags.link,
  textDecoration: "underline"
}, {
  tag: tags.heading,
  textDecoration: "underline",
  fontWeight: "bold"
}, {
  tag: tags.emphasis,
  fontStyle: "italic"
}, {
  tag: tags.strong,
  fontWeight: "bold"
}, {
  tag: tags.strikethrough,
  textDecoration: "line-through"
}, {
  tag: tags.keyword,
  color: "#708"
}, {
  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
  color: "#219"
}, {
  tag: [tags.literal, tags.inserted],
  color: "#164"
}, {
  tag: [tags.string, tags.deleted],
  color: "#a11"
}, {
  tag: [tags.regexp, tags.escape, tags.special(tags.string)],
  color: "#e40"
}, {
  tag: tags.definition(tags.variableName),
  color: "#00f"
}, {
  tag: tags.local(tags.variableName),
  color: "#30a"
}, {
  tag: [tags.typeName, tags.namespace],
  color: "#085"
}, {
  tag: tags.className,
  color: "#167"
}, {
  tag: [tags.special(tags.variableName), tags.macroName],
  color: "#256"
}, {
  tag: tags.definition(tags.propertyName),
  color: "#00c"
}, {
  tag: tags.comment,
  color: "#940"
}, {
  tag: tags.invalid,
  color: "#f00"
}]);
var baseTheme2 = EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": {
    backgroundColor: "#328c8252"
  },
  "&.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bb555544"
  }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = Decoration.mark({
  class: "cm-matchingBracket"
});
var nonmatchingMark = Decoration.mark({
  class: "cm-nonmatchingBracket"
});
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end) decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
var bracketMatchingState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr2) {
    if (!tr2.docChanged && !tr2.selection) return deco;
    let decorations2 = [];
    let config2 = tr2.state.facet(bracketMatchingConfig);
    for (let range2 of tr2.state.selection.ranges) {
      if (!range2.empty) continue;
      let match = matchBrackets(tr2.state, range2.head, -1, config2) || range2.head > 0 && matchBrackets(tr2.state, range2.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr2.state, range2.head, 1, config2) || range2.head < tr2.state.doc.length && matchBrackets(tr2.state, range2.head + 1, -1, config2));
      if (match) decorations2 = decorations2.concat(config2.renderMatch(match, tr2.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [bracketMatchingState, baseTheme2];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp) return byProp;
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0)) return [brackets[index2 + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches2 = matchingNodes(cur2.type, dir, brackets);
    if (matches2 && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur2, handle, matches2, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent2 = token.parent, firstToken = {
    from: handle.from,
    to: handle.to
  };
  let depth2 = 0, cursor = parent2 === null || parent2 === void 0 ? void 0 : parent2.cursor();
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {
    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
      if (depth2 == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
        let endHandle = findHandle(cursor);
        return {
          start: firstToken,
          end: endHandle ? {
            from: endHandle.from,
            to: endHandle.to
          } : void 0,
          matched: true
        };
      } else if (matchingNodes(cursor.type, dir, brackets)) {
        depth2++;
      } else if (matchingNodes(cursor.type, -dir, brackets)) {
        if (depth2 == 0) {
          let endHandle = findHandle(cursor);
          return {
            start: firstToken,
            end: endHandle && endHandle.from < endHandle.to ? {
              from: endHandle.from,
              to: endHandle.to
            } : void 0,
            matched: false
          };
        }
        depth2--;
      }
    }
  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return {
    start: firstToken,
    matched: false
  };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0) return null;
  let startToken = {
    from: dir < 0 ? pos - 1 : pos,
    to: dir > 0 ? pos + 1 : pos
  };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0) distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType) continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return {
          start: startToken,
          end: {
            from: basePos + pos2,
            to: basePos + pos2 + 1
          },
          matched: found >> 1 == bracket2 >> 1
        };
      } else {
        depth2--;
      }
    }
    if (dir > 0) distance += text.length;
  }
  return iter.done ? {
    start: startToken,
    matched: false
  } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var nodeSet = new NodeSet(typeArray);
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]) defaultTable[legacyName] = createTokenType(noTokens, name2);
var TokenTable = class {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
  }
};
var defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1) return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);
        else found = found.map(value);
      } else {
        if (found.length) warnForPart(part, `Tag ${part} used as modifier`);
        else found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found) tags$1.push(tag);
  }
  if (!tags$1.length) return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t3) => t3.id);
  let known = byTag[key];
  if (known) return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({
      [name2]: tags$1
    })]
  });
  typeArray.push(type);
  return type.id;
}
function buildForLine(line) {
  return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
  for (let i2 = text.iter(); !i2.next().done; ) if (buildForLine(i2.value)) return true;
  return false;
}
function changeAddsRTL(change) {
  let added = false;
  change.iterChanges((fA, tA, fB, tB, ins) => {
    if (!added && textHasRTL(ins)) added = true;
  });
  return added;
}
var alwaysIsolate = Facet.define({
  combine: (values2) => values2.some((x) => x)
});
var isolateMarks = ViewPlugin.fromClass(class {
  constructor(view) {
    this.always = view.state.facet(alwaysIsolate) || view.textDirection != Direction.LTR || view.state.facet(EditorView.perLineTextDirection);
    this.hasRTL = !this.always && textHasRTL(view.state.doc);
    this.tree = syntaxTree(view.state);
    this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : Decoration.none;
  }
  update(update2) {
    let always = update2.state.facet(alwaysIsolate) || update2.view.textDirection != Direction.LTR || update2.state.facet(EditorView.perLineTextDirection);
    if (!always && !this.hasRTL && changeAddsRTL(update2.changes)) this.hasRTL = true;
    if (!always && !this.hasRTL) return;
    let tree = syntaxTree(update2.state);
    if (always != this.always || tree != this.tree || update2.docChanged || update2.viewportChanged) {
      this.tree = tree;
      this.always = always;
      this.decorations = buildDeco(update2.view, tree, always);
    }
  }
}, {
  provide: (plugin3) => {
    function access(view) {
      var _a3, _b;
      return (_b = (_a3 = view.plugin(plugin3)) === null || _a3 === void 0 ? void 0 : _a3.decorations) !== null && _b !== void 0 ? _b : Decoration.none;
    }
    return [EditorView.outerDecorations.of(access), Prec.lowest(EditorView.bidiIsolatedRanges.of(access))];
  }
});
function buildDeco(view, tree, always) {
  let deco = new RangeSetBuilder();
  let ranges = view.visibleRanges;
  if (!always) ranges = clipRTLLines(ranges, view.state.doc);
  for (let {
    from,
    to: to2
  } of ranges) {
    tree.iterate({
      enter: (node) => {
        let iso = node.type.prop(NodeProp.isolate);
        if (iso) deco.add(node.from, node.to, marks[iso]);
      },
      from,
      to: to2
    });
  }
  return deco.finish();
}
function clipRTLLines(ranges, doc2) {
  let cur2 = doc2.iter(), pos = 0, result2 = [], last3 = null;
  for (let {
    from,
    to: to2
  } of ranges) {
    if (last3 && last3.to > from) {
      from = last3.to;
      if (from >= to2) continue;
    }
    if (pos + cur2.value.length < from) {
      cur2.next(from - (pos + cur2.value.length));
      pos = from;
    }
    for (; ; ) {
      let start = pos, end = pos + cur2.value.length;
      if (!cur2.lineBreak && buildForLine(cur2.value)) {
        if (last3 && last3.to > start - 10) last3.to = Math.min(to2, end);
        else result2.push(last3 = {
          from: start,
          to: Math.min(to2, end)
        });
      }
      if (end >= to2) break;
      pos = end;
      cur2.next();
    }
  }
  return result2;
}
var marks = {
  rtl: Decoration.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "rtl"
    },
    bidiIsolate: Direction.RTL
  }),
  ltr: Decoration.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "ltr"
    },
    bidiIsolate: Direction.LTR
  }),
  auto: Decoration.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "auto"
    },
    bidiIsolate: null
  })
};

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let {
    state
  } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({
    state,
    dispatch
  }) => {
    if (state.readOnly) return false;
    let tr2 = f(option, state);
    if (!tr2) return false;
    dispatch(state.update(tr2));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o2, s2) => changeBlockComment(o2, s2, selectedLineRanges(s2)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos, 1);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, {
  open,
  close
}, from, to2) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to2, to2 + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: {
        pos: from - spaceBefore,
        margin: spaceBefore && 1
      },
      close: {
        pos: to2 + spaceAfter,
        margin: spaceAfter && 1
      }
    };
  }
  let startText, endText;
  if (to2 - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to2);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to2 - SearchMargin, to2);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to2 - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from);
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to);
    if (toLine.from > fromLine.from && toLine.from == r2.to) toLine = r2.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r2.to - 1);
    let last3 = ranges.length - 1;
    if (last3 >= 0 && ranges[last3].to > fromLine.from) ranges[last3].to = toLine.to;
    else ranges.push({
      from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
      to: toLine.to
    });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens.every((c) => c)) return null;
  let comments = ranges.map((r2, i2) => findBlockComment(state, tokens[i2], r2.from, r2.to));
  if (option != 2 && !comments.every((c) => c)) {
    return {
      changes: state.changes(ranges.map((range2, i2) => {
        if (comments[i2]) return [];
        return [{
          from: range2.from,
          insert: tokens[i2].open + " "
        }, {
          from: range2.to,
          insert: " " + tokens[i2].close
        }];
      }))
    };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i2 = 0, comment2; i2 < comments.length; i2++) if (comment2 = comments[i2]) {
      let token = tokens[i2], {
        open,
        close
      } = comment2;
      changes.push({
        from: open.pos - token.open.length,
        to: open.pos + open.margin
      }, {
        from: close.pos - close.margin,
        to: close.pos + token.close.length
      });
    }
    return {
      changes
    };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let {
    from,
    to: to2
  } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token) continue;
    for (let pos = from; pos <= to2; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to2 || to2 > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent) minIndent = indent;
        lines.push({
          line,
          comment: comment2,
          token,
          indent,
          empty: empty2,
          single: false
        });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i2 = startI; i2 < lines.length; i2++) if (lines[i2].indent < lines[i2].line.text.length) lines[i2].indent = minIndent;
    }
    if (lines.length == startI + 1) lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let {
      line,
      token,
      indent,
      empty: empty2,
      single
    } of lines) if (single || !empty2) changes.push({
      from: line.from + indent,
      insert: token + " "
    });
    let changeSet = state.changes(changes);
    return {
      changes: changeSet,
      selection: state.selection.map(changeSet, 1)
    };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let {
      line,
      comment: comment2,
      token
    } of lines) if (comment2 >= 0) {
      let from = line.from + comment2, to2 = from + token.length;
      if (line.text[to2 - line.from] == " ") to2++;
      changes.push({
        from,
        to: to2
      });
    }
    return {
      changes
    };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t2, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a2, b) => (tr2, adj) => a2(tr2, adj) || b(tr2, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr2) {
    let config2 = tr2.state.facet(historyConfig);
    let fromHist = tr2.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr2, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item) other = updateBranch(other, other.length, config2.minDepth, item);
      else other = addSelection(other, tr2.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr2.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before") state = state.isolate();
    if (tr2.annotation(Transaction.addToHistory) === false) return !tr2.changes.empty ? state.addMapping(tr2.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr2);
    let time = tr2.annotation(Transaction.time), userEvent = tr2.annotation(Transaction.userEvent);
    if (event) state = state.addChanges(event, time, userEvent, config2, tr2);
    else if (tr2.selection) state = state.addSelection(tr2.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after") state = state.isolate();
    return state;
  },
  toJSON(value) {
    return {
      done: value.done.map((e2) => e2.toJSON()),
      undone: value.undone.map((e2) => e2.toJSON())
    };
  },
  fromJSON(json2) {
    return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
  }
});
function cmd(side, selection) {
  return function({
    state,
    dispatch
  }) {
    if (!selection && state.readOnly) return false;
    let historyState = state.field(historyField_, false);
    if (!historyState) return false;
    let tr2 = historyState.pop(side, state, selection);
    if (!tr2) return false;
    dispatch(tr2);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState) return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after2) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after2);
  }
  toJSON() {
    var _a3, _b, _c2;
    return {
      changes: (_a3 = this.changes) === null || _a3 === void 0 ? void 0 : _a3.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c2 = this.startSelection) === null || _c2 === void 0 ? void 0 : _c2.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json2) {
    return new _HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr2, selection) {
    let effects = none2;
    for (let invert2 of tr2.startState.facet(invertedEffects)) {
      let result2 = invert2(tr2);
      if (result2.length) effects = effects.concat(result2);
    }
    if (!effects.length && tr2.changes.empty) return null;
    return new _HistEvent(tr2.changes.invert(tr2.startState.doc), effects, void 0, selection || tr2.startState.selection, none2);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none2, void 0, void 0, selections);
  }
};
function updateBranch(branch, to2, maxLen, newEvent) {
  let start = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to2);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b) {
  let ranges = [], isAdjacent2 = false;
  a2.iterChangedRanges((f, t3) => ranges.push(f, t3));
  b.iterChangedRanges((_f2, _t2, f, t3) => {
    for (let i2 = 0; i2 < ranges.length; ) {
      let from = ranges[i2++], to2 = ranges[i2++];
      if (t3 >= from && f <= to2) isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b) {
  return a2.ranges.length == b.ranges.length && a2.ranges.filter((r2, i2) => r2.empty != b.ranges[i2].empty).length === 0;
}
function conc(a2, b) {
  return !a2.length ? b : !b.length ? a2 : a2.concat(b);
}
var none2 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last3 = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last3.setSelAfter(last3.selectionsAfter.slice(0, last3.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length) return branch;
  let length = branch.length, selections = none2;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result2 = branch.slice(0, length);
      result2[length - 1] = event;
      return result2;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none2;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none2, extraSelections);
  if (!event.changes) return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before2 = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before2) : before2;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before2), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr2) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr2, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none2, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last3 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
    if (last3.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last3[last3.length - 1], selection)) return this;
    return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0) return null;
    let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({
          side,
          rest: popSelection(branch),
          selection
        }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest2 = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
      if (event.mapped) rest2 = addMappingToBranch(rest2, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({
          side,
          rest: rest2,
          selection
        }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none2, none2);
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({
    selection,
    scrollIntoView: true,
    userEvent: "select"
  });
}
function moveSel({
  state,
  dispatch
}, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection, true)) return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range2, forward) {
  return EditorSelection.cursor(forward ? range2.to : range2.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByChar(range2, forward) : rangeEnd(range2, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByGroup(range2, forward) : rangeEnd(range2, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, {
  granularity: "word"
}) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp)) return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at4 = start.head; ; ) {
    let next = forward ? pos.childAfter(at4) : pos.childBefore(at4);
    if (!next) break;
    if (interestingNode(state, next, bracketProp)) pos = next;
    else at4 = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;
  else newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range2) => {
    if (!range2.empty) return rangeEnd(range2, forward);
    let moved = view.moveVertically(range2, forward);
    return moved.head != range2.head ? moved : view.moveToLineBoundary(range2, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let {
    state
  } = view, selection = updateSel(state.selection, (range2) => {
    return range2.empty ? view.moveVertically(range2, forward, page.height) : rangeEnd(range2, forward);
  });
  if (selection.eq(state.selection)) return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection.main.head, {
      y: "start",
      yMargin: startPos.top - scrollTop
    });
  }
  view.dispatch(setSel(state, selection), {
    effects: effect
  });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection = updateSel(state.selection, (range2) => {
    let matching = matchBrackets(state, range2.head, -1) || matchBrackets(state, range2.head, 1) || range2.head > 0 && matchBrackets(state, range2.head - 1, 1) || range2.head < state.doc.length && matchBrackets(state, range2.head + 1, -1);
    if (!matching || !matching.end) return range2;
    found = true;
    let head2 = matching.start.from == range2.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range2.anchor, head2) : EditorSelection.cursor(head2);
  });
  if (!found) return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({
  state,
  dispatch
}) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection = updateSel(target.state.selection, (range2) => {
    let head2 = how(range2);
    return EditorSelection.range(range2.anchor, head2.head, head2.goalColumn, head2.bidiLevel || void 0);
  });
  if (selection.eq(target.state.selection)) return false;
  target.dispatch(setSel(target.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range2) => view.moveByChar(range2, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range2) => view.moveByGroup(range2, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from));
var selectLineEnd = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to));
var cursorDocStart = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: 0
  }));
  return true;
};
var cursorDocEnd = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.doc.length
  }));
  return true;
};
var selectDocStart = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: 0
  }));
  return true;
};
var selectDocEnd = ({
  state,
  dispatch
}) => {
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: state.doc.length
  }));
  return true;
};
var selectAll = ({
  state,
  dispatch
}) => {
  dispatch(state.update({
    selection: {
      anchor: 0,
      head: state.doc.length
    },
    userEvent: "select"
  }));
  return true;
};
var selectLine = ({
  state,
  dispatch
}) => {
  let ranges = selectedLineBlocks(state).map(({
    from,
    to: to2
  }) => EditorSelection.range(from, Math.min(to2 + 1, state.doc.length)));
  dispatch(state.update({
    selection: EditorSelection.create(ranges),
    userEvent: "select"
  }));
  return true;
};
var selectParentSyntax = ({
  state,
  dispatch
}) => {
  let selection = updateSel(state.selection, (range2) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range2.from, 1);
    if (range2.empty) {
      let stackBefore = tree.resolveStack(range2.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let {
        node
      } = cur2;
      if ((node.from < range2.from && node.to >= range2.to || node.to > range2.to && node.from <= range2.from) && cur2.next) return EditorSelection.range(node.to, node.from);
    }
    return range2;
  });
  if (selection.eq(state.selection)) return false;
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({
  state,
  dispatch
}) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1) selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty) selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection) return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly) return false;
  let event = "delete.selection", {
    state
  } = target;
  let changes = state.changeByRange((range2) => {
    let {
      from,
      to: to2
    } = range2;
    if (from == to2) {
      let towards = by(range2);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to2 = Math.max(to2, towards);
    } else {
      from = skipAtomic(target, from, false);
      to2 = skipAtomic(target, to2, true);
    }
    return from == to2 ? {
      range: range2
    } : {
      changes: {
        from,
        to: to2
      },
      range: EditorSelection.cursor(from, from < range2.head ? -1 : 1)
    };
  });
  if (changes.changes.empty) return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView) for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target))) ranges.between(pos, pos, (from, to2) => {
    if (from < pos && to2 > pos) pos = forward ? to2 : from;
  });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range2) => {
  let pos = range2.from, {
    state
  } = target, line = state.doc.lineAt(pos), before2, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before2 = line.text.slice(0, pos - line.from))) {
    if (before2[before2.length - 1] == "	") return pos - 1;
    let col = countColumn(before2, state.tabSize), drop2 = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i2 = 0; i2 < drop2 && before2[before2.length - 1 - i2] == " "; i2++) pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range2) => {
  let pos = range2.head, {
    state
  } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range2.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat) break;
    if (nextChar2 != " " || pos != range2.head) cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range2) => {
  let lineEnd = view.lineBlockAt(range2.head).to;
  return range2.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range2.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range2) => {
  let lineStart = view.moveToLineBoundary(range2, false).head;
  return range2.head > lineStart ? lineStart : Math.max(0, range2.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range2) => {
  let lineStart = view.moveToLineBoundary(range2, true).head;
  return range2.head < lineStart ? lineStart : Math.min(view.state.doc.length, range2.head + 1);
});
var splitLine = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let changes = state.changeByRange((range2) => {
    return {
      changes: {
        from: range2.from,
        to: range2.to,
        insert: Text2.of(["", ""])
      },
      range: EditorSelection.cursor(range2.from)
    };
  });
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
var transposeChars = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let changes = state.changeByRange((range2) => {
    if (!range2.empty || range2.from == 0 || range2.from == state.doc.length) return {
      range: range2
    };
    let pos = range2.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
    let to2 = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
    return {
      changes: {
        from,
        to: to2,
        insert: state.doc.slice(pos, to2).append(state.doc.slice(from, pos))
      },
      range: EditorSelection.cursor(to2)
    };
  });
  if (changes.changes.empty) return false;
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "move.character"
  }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range2 of state.selection.ranges) {
    let startLine = state.doc.lineAt(range2.from), endLine = state.doc.lineAt(range2.to);
    if (!range2.empty && range2.to == endLine.from) endLine = state.doc.lineAt(range2.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range2);
    } else {
      blocks.push({
        from: startLine.from,
        to: endLine.to,
        ranges: [range2]
      });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0) continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size2 = nextLine.length + 1;
    if (forward) {
      changes.push({
        from: block.to,
        to: nextLine.to
      }, {
        from: block.from,
        insert: nextLine.text + state.lineBreak
      });
      for (let r2 of block.ranges) ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size2), Math.min(state.doc.length, r2.head + size2)));
    } else {
      changes.push({
        from: nextLine.from,
        to: block.from
      }, {
        from: block.to,
        insert: state.lineBreak + nextLine.text
      });
      for (let r2 of block.ranges) ranges.push(EditorSelection.range(r2.anchor - size2, r2.head - size2));
    }
  }
  if (!changes.length) return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({
  state,
  dispatch
}) => moveLine(state, dispatch, false);
var moveLineDown = ({
  state,
  dispatch
}) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward) changes.push({
      from: block.from,
      insert: state.doc.slice(block.from, block.to) + state.lineBreak
    });
    else changes.push({
      from: block.to,
      insert: state.lineBreak + state.doc.slice(block.from, block.to)
    });
  }
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    userEvent: "input.copyline"
  }));
  return true;
}
var copyLineUp = ({
  state,
  dispatch
}) => copyLine(state, dispatch, false);
var copyLineDown = ({
  state,
  dispatch
}) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly) return false;
  let {
    state
  } = view, changes = state.changes(selectedLineBlocks(state).map(({
    from,
    to: to2
  }) => {
    if (from > 0) from--;
    else if (to2 < state.doc.length) to2++;
    return {
      from,
      to: to2
    };
  }));
  let selection = updateSel(state.selection, (range2) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range2.head), pos = view.coordsAtPos(range2.head, range2.assoc || 1);
      if (pos) dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range2, true, dist2);
  }).map(changes);
  view.dispatch({
    changes,
    selection,
    scrollIntoView: true,
    userEvent: "delete.line"
  });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
    from: pos,
    to: pos
  };
  let context = syntaxTree(state).resolveInner(pos);
  let before2 = context.childBefore(pos), after2 = context.childAfter(pos), closedBy;
  if (before2 && after2 && before2.to <= pos && after2.from >= pos && (closedBy = before2.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after2.name) > -1 && state.doc.lineAt(before2.to).from == state.doc.lineAt(after2.from).from && !/\S/.test(state.sliceDoc(before2.to, after2.from))) return {
    from: before2.to,
    to: after2.from
  };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({
    state,
    dispatch
  }) => {
    if (state.readOnly) return false;
    let changes = state.changeByRange((range2) => {
      let {
        from,
        to: to2
      } = range2, line = state.doc.lineAt(from);
      let explode = !atEof && from == to2 && isBetweenBrackets(state, from);
      if (atEof) from = to2 = (to2 <= line.to ? line : state.doc.lineAt(to2)).to;
      let cx = new IndentContext(state, {
        simulateBreak: from,
        simulateDoubleBreak: !!explode
      });
      let indent = getIndentation(cx, from);
      if (indent == null) indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to2 < line.to && /\s/.test(line.text[to2 - line.from])) to2++;
      if (explode) ({
        from,
        to: to2
      } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode) insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: {
          from,
          to: to2,
          insert: Text2.of(insert2)
        },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "input"
    }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range2) => {
    let changes = [];
    for (let pos = range2.from; pos <= range2.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range2.empty || range2.to > line.from)) {
        f(line, changes, range2);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range2.anchor, 1), changeSet.mapPos(range2.head, 1))
    };
  });
}
var indentSelection = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, {
    overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    }
  });
  let changes = changeBySelectedLine(state, (line, changes2, range2) => {
    let indent = getIndentation(context, line.from);
    if (indent == null) return;
    if (!/\S/.test(line.text)) indent = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range2.from < line.from + cur2.length) {
      updated[line.from] = indent;
      changes2.push({
        from: line.from,
        to: line.from + cur2.length,
        insert: norm
      });
    }
  });
  if (!changes.changes.empty) dispatch(state.update(changes, {
    userEvent: "indent"
  }));
  return true;
};
var indentMore = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({
      from: line.from,
      insert: state.facet(indentUnit)
    });
  }), {
    userEvent: "input.indent"
  }));
  return true;
};
var indentLess = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space) return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep)) keep++;
    changes.push({
      from: line.from + keep,
      to: line.from + space.length,
      insert: insert2.slice(keep)
    });
  }), {
    userEvent: "delete.dedent"
  }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [{
  key: "Ctrl-b",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Ctrl-f",
  run: cursorCharRight,
  shift: selectCharRight
}, {
  key: "Ctrl-p",
  run: cursorLineUp,
  shift: selectLineUp
}, {
  key: "Ctrl-n",
  run: cursorLineDown,
  shift: selectLineDown
}, {
  key: "Ctrl-a",
  run: cursorLineStart,
  shift: selectLineStart
}, {
  key: "Ctrl-e",
  run: cursorLineEnd,
  shift: selectLineEnd
}, {
  key: "Ctrl-d",
  run: deleteCharForward
}, {
  key: "Ctrl-h",
  run: deleteCharBackward
}, {
  key: "Ctrl-k",
  run: deleteToLineEnd
}, {
  key: "Ctrl-Alt-h",
  run: deleteGroupBackward
}, {
  key: "Ctrl-o",
  run: splitLine
}, {
  key: "Ctrl-t",
  run: transposeChars
}, {
  key: "Ctrl-v",
  run: cursorPageDown
}];
var standardKeymap = [{
  key: "ArrowLeft",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Mod-ArrowLeft",
  mac: "Alt-ArrowLeft",
  run: cursorGroupLeft,
  shift: selectGroupLeft,
  preventDefault: true
}, {
  mac: "Cmd-ArrowLeft",
  run: cursorLineBoundaryLeft,
  shift: selectLineBoundaryLeft,
  preventDefault: true
}, {
  key: "ArrowRight",
  run: cursorCharRight,
  shift: selectCharRight,
  preventDefault: true
}, {
  key: "Mod-ArrowRight",
  mac: "Alt-ArrowRight",
  run: cursorGroupRight,
  shift: selectGroupRight,
  preventDefault: true
}, {
  mac: "Cmd-ArrowRight",
  run: cursorLineBoundaryRight,
  shift: selectLineBoundaryRight,
  preventDefault: true
}, {
  key: "ArrowUp",
  run: cursorLineUp,
  shift: selectLineUp,
  preventDefault: true
}, {
  mac: "Cmd-ArrowUp",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  mac: "Ctrl-ArrowUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "ArrowDown",
  run: cursorLineDown,
  shift: selectLineDown,
  preventDefault: true
}, {
  mac: "Cmd-ArrowDown",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  mac: "Ctrl-ArrowDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "PageUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "PageDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "Home",
  run: cursorLineBoundaryBackward,
  shift: selectLineBoundaryBackward,
  preventDefault: true
}, {
  key: "Mod-Home",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  key: "End",
  run: cursorLineBoundaryForward,
  shift: selectLineBoundaryForward,
  preventDefault: true
}, {
  key: "Mod-End",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  key: "Enter",
  run: insertNewlineAndIndent,
  shift: insertNewlineAndIndent
}, {
  key: "Mod-a",
  run: selectAll
}, {
  key: "Backspace",
  run: deleteCharBackward,
  shift: deleteCharBackward
}, {
  key: "Delete",
  run: deleteCharForward
}, {
  key: "Mod-Backspace",
  mac: "Alt-Backspace",
  run: deleteGroupBackward
}, {
  key: "Mod-Delete",
  mac: "Alt-Delete",
  run: deleteGroupForward
}, {
  mac: "Mod-Backspace",
  run: deleteLineBoundaryBackward
}, {
  mac: "Mod-Delete",
  run: deleteLineBoundaryForward
}].concat(emacsStyleKeymap.map((b) => ({
  mac: b.key,
  run: b.run,
  shift: b.shift
})));
var defaultKeymap = [{
  key: "Alt-ArrowLeft",
  mac: "Ctrl-ArrowLeft",
  run: cursorSyntaxLeft,
  shift: selectSyntaxLeft
}, {
  key: "Alt-ArrowRight",
  mac: "Ctrl-ArrowRight",
  run: cursorSyntaxRight,
  shift: selectSyntaxRight
}, {
  key: "Alt-ArrowUp",
  run: moveLineUp
}, {
  key: "Shift-Alt-ArrowUp",
  run: copyLineUp
}, {
  key: "Alt-ArrowDown",
  run: moveLineDown
}, {
  key: "Shift-Alt-ArrowDown",
  run: copyLineDown
}, {
  key: "Escape",
  run: simplifySelection
}, {
  key: "Mod-Enter",
  run: insertBlankLine
}, {
  key: "Alt-l",
  mac: "Ctrl-l",
  run: selectLine
}, {
  key: "Mod-i",
  run: selectParentSyntax,
  preventDefault: true
}, {
  key: "Mod-[",
  run: indentLess
}, {
  key: "Mod-]",
  run: indentMore
}, {
  key: "Mod-Alt-\\",
  run: indentSelection
}, {
  key: "Shift-Mod-k",
  run: deleteLine
}, {
  key: "Shift-Mod-\\",
  run: cursorMatchingBracket
}, {
  key: "Mod-/",
  run: toggleComment
}, {
  key: "Alt-A",
  run: toggleBlockComment
}, {
  key: "Ctrl-m",
  mac: "Shift-Alt-m",
  run: toggleTabFocusMode
}].concat(standardKeymap);
var indentWithTab = {
  key: "Tab",
  run: indentMore,
  shift: indentLess
};

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to2, diagnostic) {
    this.from = from;
    this.to = to2;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics, state);
    let sorted = diagnostics.slice().sort((a2, b) => a2.from - b.from || a2.to - b.to);
    let deco = new RangeSetBuilder(), active = [], pos = 0;
    for (let i2 = 0; ; ) {
      let next = i2 == sorted.length ? null : sorted[i2];
      if (!next && !active.length) break;
      let from, to2;
      if (active.length) {
        from = pos;
        to2 = active.reduce((p2, d) => Math.min(p2, d.to), next && next.from > from ? next.from : 1e8);
      } else {
        from = next.from;
        to2 = next.to;
        active.push(next);
        i2++;
      }
      while (i2 < sorted.length) {
        let next2 = sorted[i2];
        if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
          active.push(next2);
          i2++;
          to2 = Math.min(next2.to, to2);
        } else {
          to2 = Math.min(next2.from, to2);
          break;
        }
      }
      let sev = maxSeverity(active);
      if (active.some((d) => d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)) {
        deco.add(from, from, Decoration.widget({
          widget: new DiagnosticWidget(sev),
          diagnostics: active.slice()
        }));
      } else {
        let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
        deco.add(from, to2, Decoration.mark({
          class: "cm-lintRange cm-lintRange-" + sev + markClass,
          diagnostics: active.slice(),
          inclusiveEnd: active.some((a2) => a2.to > to2)
        }));
      }
      pos = to2;
      for (let i3 = 0; i3 < active.length; i3++) if (active[i3].to <= pos) active.splice(i3--, 1);
    }
    let set2 = deco.finish();
    return new _LintState(set2, panel, findDiagnostic(set2));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after2 = 0) {
  let found = null;
  diagnostics.between(after2, 1e9, (from, to2, {
    spec
  }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0) return;
    if (!found) found = new SelectedDiagnostic(from, to2, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0) return false;
    else found = new SelectedDiagnostic(found.from, to2, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr2, tooltip) {
  let from = tooltip.pos, to2 = tooltip.end || from;
  let result2 = tr2.state.facet(lintConfig).hideOn(tr2, from, to2);
  if (result2 != null) return result2;
  let line = tr2.startState.doc.lineAt(tooltip.pos);
  return !!(tr2.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr2.changes.touchesRange(line.from, Math.max(line.to, to2)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr2) {
    if (tr2.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr2.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr2.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr2.state.facet(lintConfig).autoPanel) panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr2.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr2.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr2.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [showPanel.from(f, (val) => val.panel), EditorView.decorations.from(f, (s2) => s2.diagnostics)]
});
var activeMark = Decoration.mark({
  class: "cm-lintRange cm-lintRange-active"
});
function lintTooltip(view, pos, side) {
  let {
    diagnostics
  } = view.state.field(lintState);
  let found, start = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to2, {
    spec
  }) => {
    if (pos >= from && pos <= to2 && (from == to2 || (pos > from || side > 0) && (pos < to2 || side < 0))) {
      found = spec.diagnostics;
      start = from;
      end = to2;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter) found = diagnosticFilter(found, view.state);
  if (!found) return null;
  return {
    pos: start,
    end,
    above: view.state.doc.lineAt(start).to < end,
    create() {
      return {
        dom: diagnosticsTooltip(view, found)
      };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", {
    class: "cm-tooltip-lint"
  }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel) view.dispatch({
    effects: maybeEnableLint(view.state, [togglePanel.of(true)])
  });
  let panel = getPanel(view, LintPanel.open);
  if (panel) panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel) return false;
  view.dispatch({
    effects: togglePanel.of(false)
  });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field) return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to) return false;
  }
  view.dispatch({
    selection: {
      anchor: next.from,
      head: next.to
    },
    scrollIntoView: true
  });
  return true;
};
var lintKeymap = [{
  key: "Mod-Shift-m",
  run: openLintPanel,
  preventDefault: true
}, {
  key: "F8",
  run: nextDiagnostic
}];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let {
      delay: delay2
    } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay2;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay2);
  }
  run() {
    clearTimeout(this.timeout);
    let now2 = Date.now();
    if (now2 < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now2);
    } else {
      this.set = false;
      let {
        state
      } = this.view, {
        sources
      } = state.facet(lintConfig);
      if (sources.length) batchResults(sources.map((s2) => Promise.resolve(s2(this.view))), (annotations) => {
        if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a2, b) => a2.concat(b))));
      }, (error) => {
        logException(this.view.state, error);
      });
    }
  }
  update(update2) {
    let config2 = update2.state.facet(lintConfig);
    if (update2.docChanged || config2 != update2.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update2)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error) {
  let collected = [], timeout = -1;
  for (let p2 of promises) p2.then((value) => {
    collected.push(value);
    clearTimeout(timeout);
    if (collected.length == promises.length) sink(collected);
    else timeout = setTimeout(() => sink(collected), 200);
  }, error);
}
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({
      sources: input.map((i2) => i2.source).filter((x) => x != null)
    }, combineConfig(input.map((i2) => i2.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a2, b) => !a2 ? b : !b ? a2 : (u) => a2(u) || b(u)
    }));
  }
});
function linter(source, config2 = {}) {
  return [lintConfig.of({
    source,
    config: config2
  }), lintPlugin, lintExtensions];
}
function assignKeys(actions) {
  let assigned = [];
  if (actions) actions: for (let {
    name: name2
  } of actions) {
    for (let i2 = 0; i2 < name2.length; i2++) {
      let ch2 = name2[i2];
      if (/[a-zA-Z]/.test(ch2) && !assigned.some((c) => c.toLowerCase() == ch2.toLowerCase())) {
        assigned.push(ch2);
        continue actions;
      }
    }
    assigned.push("");
  }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a3;
  let keys3 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", {
    class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity
  }, crelt("span", {
    class: "cm-diagnosticText"
  }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a3 = diagnostic.actions) === null || _a3 === void 0 ? void 0 : _a3.map((action, i2) => {
    let fired = false, click = (e2) => {
      e2.preventDefault();
      if (fired) return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found) action.apply(view, found.from, found.to);
    };
    let {
      name: name2
    } = action, keyIndex = keys3[i2] ? name2.indexOf(keys3[i2]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [name2.slice(0, keyIndex), crelt("u", name2.slice(keyIndex, keyIndex + 1)), name2.slice(keyIndex + 1)];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys3[i2]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", {
    class: "cm-diagnosticSource"
  }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(sev) {
    super();
    this.sev = sev;
  }
  eq(other) {
    return other.sev == this.sev;
  }
  toDOM() {
    return crelt("span", {
      class: "cm-lintPoint cm-lintPoint-" + this.sev
    });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let {
          diagnostic
        } = this.items[this.selectedIndex], keys3 = assignKeys(diagnostic.actions);
        for (let i2 = 0; i2 < keys3.length; i2++) if (keys3[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
          let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
          if (found) diagnostic.actions[i2].apply(view, found.from, found.to);
        }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].dom.contains(event.target)) this.moveSelection(i2);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", {
      class: "cm-panel-lint"
    }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, ""));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected) return -1;
    for (let i2 = 0; i2 < this.items.length; i2++) if (this.items[i2].diagnostic == selected.diagnostic) return i2;
    return -1;
  }
  update() {
    let {
      diagnostics,
      selected
    } = this.view.state.field(lintState);
    let i2 = 0, needsSync = false, newSelectedItem = null;
    let seen = /* @__PURE__ */ new Set();
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, {
      spec
    }) => {
      for (let diagnostic of spec.diagnostics) {
        if (seen.has(diagnostic)) continue;
        seen.add(diagnostic);
        let found = -1, item;
        for (let j = i2; j < this.items.length; j++) if (this.items[j].diagnostic == diagnostic) {
          found = j;
          break;
        }
        if (found < 0) {
          item = new PanelItem(this.view, diagnostic);
          this.items.splice(i2, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i2) {
            this.items.splice(i2, found - i2);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i2++;
      }
    });
    while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({
          sel: newSelectedItem.dom.getBoundingClientRect(),
          panel: this.list.getBoundingClientRect()
        }),
        write: ({
          sel,
          panel
        }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync) this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm3() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom) rm3();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos) rm3();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0) return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection) return;
    this.view.dispatch({
      selection: {
        anchor: selection.from,
        head: selection.to
      },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme3 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": {
    borderLeft: "5px solid #d11"
  },
  ".cm-diagnostic-warning": {
    borderLeft: "5px solid orange"
  },
  ".cm-diagnostic-info": {
    borderLeft: "5px solid #999"
  },
  ".cm-diagnostic-hint": {
    borderLeft: "5px solid #66d"
  },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": {
    backgroundImage: underline("#d11")
  },
  ".cm-lintRange-warning": {
    backgroundImage: underline("orange")
  },
  ".cm-lintRange-info": {
    backgroundImage: underline("#999")
  },
  ".cm-lintRange-hint": {
    backgroundImage: underline("#66d")
  },
  ".cm-lintRange-active": {
    backgroundColor: "#ffdd9980"
  },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": {
      borderBottomColor: "orange"
    }
  },
  ".cm-lintPoint-info": {
    "&:after": {
      borderBottomColor: "#999"
    }
  },
  ".cm-lintPoint-hint": {
    "&:after": {
      borderBottomColor: "#66d"
    }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": {
          textDecoration: "underline"
        }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": {
        textDecoration: "none"
      },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d of diagnostics) {
    let w = severityWeight(d.severity);
    if (w > weight) {
      weight = w;
      sev = d.severity;
    }
  }
  return sev;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = maxSeverity(diagnostics);
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length) elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10) return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint")) return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip)) view.dispatch({
      effects: setLintGutterTooltip.of(null)
    });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({
        effects: setLintGutterTooltip.of({
          pos: line.from,
          above: false,
          clip: false,
          create() {
            return {
              dom: diagnosticsTooltip(view, diagnostics),
              getCoords: () => marker.getBoundingClientRect()
            };
          }
        })
      });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let {
    hoverTime
  } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc2, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc2.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to2, value) => {
      if (from > block.from && from < block.to) diagnostics.push(...value.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr2) {
    markers = markers.map(tr2.changes);
    let diagnosticFilter = tr2.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr2.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || [], tr2.state);
        markers = markersForDiagnostics(tr2.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr2) {
    if (tooltip && tr2.docChanged) tooltip = hideTooltip(tr2, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {
      pos: tr2.changes.mapPos(tooltip.pos)
    });
    return tr2.effects.reduce((t3, e2) => e2.is(setLintGutterTooltip) ? e2.value : t3, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [lintState, EditorView.decorations.compute([lintState], (state) => {
  let {
    selected,
    panel
  } = state.field(lintState);
  return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);
}), hoverTooltip(lintTooltip, {
  hideOn: hideTooltip
}), baseTheme3];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function lintGutter(config2 = {}) {
  return [lintGutterConfig.of(config2), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}

// node_modules/@lezer/lr/dist/index.js
var Stack2 = class _Stack {
  /**
  @internal
  */
  constructor(p2, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent2) {
    this.p = p2;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent2;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p2, state, pos = 0) {
    let cx = p2.parser.context;
    return new _Stack(p2, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a3;
    let depth2 = action >> 19, type = action & 65535;
    let {
      parser: parser2
    } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord) this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec) this.score += dPrec;
    if (depth2 == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth2 - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size2 = this.reducePos - start;
    if (size2 >= 2e3 && !((_a3 = this.p.parser.nodeSet.types[type]) === null || _a3 === void 0 ? void 0 : _a3.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size2;
      } else if (this.p.lastBigReductionSize < size2) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size2;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2) this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size2 = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end) return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size2);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0) {
        let mustMove = false;
        for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove) while (index2 > 0 && this.buffer[index2 - 2] > end) {
          this.buffer[index2] = this.buffer[index2 - 4];
          this.buffer[index2 + 1] = this.buffer[index2 - 3];
          this.buffer[index2 + 2] = this.buffer[index2 - 2];
          this.buffer[index2 + 3] = this.buffer[index2 - 1];
          index2 -= 4;
          if (size2 > 4) size2 -= 4;
        }
      }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start;
      this.buffer[index2 + 2] = end;
      this.buffer[index2 + 3] = size2;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, {
        parser: parser2
      } = this.p;
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        )) this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode) this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536) this.reduce(action);
    else this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index2,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent2 = this;
    let off = parent2.buffer.length;
    while (off > 0 && parent2.buffer[off - 2] > parent2.reducePos) off -= 4;
    let buffer = parent2.buffer.slice(off), base2 = parent2.bufferBase + off;
    while (parent2 && base2 == parent2.bufferBase) parent2 = parent2.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent2);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0) return false;
      if ((action & 65536) == 0) return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300) return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i2 = 0, s2; i2 < nextStates.length; i2 += 2) {
        if ((s2 = nextStates[i2 + 1]) != this.state && this.p.parser.hasAction(s2, next)) best.push(nextStates[i2], s2);
      }
      if (this.stack.length < 120) for (let i2 = 0; best.length < 4 << 1 && i2 < nextStates.length; i2 += 2) {
        let s2 = nextStates[i2 + 1];
        if (!best.some((v, i3) => i3 & 1 && v == s2)) best.push(nextStates[i2], s2);
      }
      nextStates = best;
    }
    let result2 = [];
    for (let i2 = 0; i2 < nextStates.length && result2.length < 4; i2 += 2) {
      let s2 = nextStates[i2 + 1];
      if (s2 == this.state) continue;
      let stack = this.split();
      stack.pushState(s2, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i2], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result2.push(stack);
    }
    return result2;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let {
      parser: parser2
    } = this.p;
    let reduce2 = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce2 & 65536) == 0) return false;
    if (!parser2.validAction(this.state, reduce2)) {
      let depth2 = reduce2 >> 19, term = reduce2 & 65535;
      let target = this.stack.length - depth2 * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null) return false;
        reduce2 = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce2);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let {
      parser: parser2
    } = this.p, seen = [];
    let explore = (state, depth2) => {
      if (seen.includes(state)) return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth2;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth2 + 1);
          if (found != null) return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3) return false;
    let {
      parser: parser2
    } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length) return false;
    for (let i2 = 0; i2 < this.stack.length; i2 += 3) if (this.stack[i2] != other.stack[i2]) return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last3 = this.buffer.length - 1;
    if (last3 < 0 || this.buffer[last3] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last3 = this.buffer.length - 1;
    if (last3 < 0 || this.buffer[last3] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash) this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict) this.emitContext();
    if (this.lookAhead > 0) this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth2 = action >> 19;
    if (depth2 == 0) {
      if (this.stack == this.start.stack) this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth2 - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack.buffer;
    if (this.index == 0) this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0) this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string") return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92) next--;
      if (next >= 34) next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop) break;
      value *= 46;
    }
    if (array) array[out++] = value;
    else array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range2 = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range2.from) {
      if (!index2) return null;
      let next = this.ranges[--index2];
      pos -= range2.from - next.to;
      range2 = next;
    }
    while (assoc < 0 ? pos > range2.to : pos >= range2.to) {
      if (index2 == this.ranges.length - 1) return null;
      let next = this.ranges[++index2];
      pos += next.from - range2.to;
      range2 = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to) return pos;
    for (let range2 of this.ranges) if (range2.to > pos) return Math.max(pos, range2.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result2;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result2 = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null) return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result2 = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i2 = this.rangeIndex, range2 = this.range;
        while (range2.to <= pos) range2 = this.ranges[++i2];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range2.to) this.chunk2 = this.chunk2.slice(0, range2.to - pos);
        result2 = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;
    return result2;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let {
        chunk: chunk2,
        chunkPos
      } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk2;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length) return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n2 = 1) {
    this.chunkOff += n2;
    while (this.pos + n2 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      n2 -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n2;
    if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to2) {
    if (from >= this.chunkPos && to2 <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to2 - this.chunkPos);
    if (from >= this.chunk2Pos && to2 <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to2 - this.chunk2Pos);
    if (from >= this.range.from && to2 <= this.range.to) return this.input.read(from, to2);
    let result2 = "";
    for (let r2 of this.ranges) {
      if (r2.from >= to2) break;
      if (r2.to > from) result2 += this.input.read(Math.max(r2.from, from), Math.min(r2.to, to2));
    }
    return result2;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let {
      parser: parser2
    } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1) break;
      if (this.elseToken == null) return;
      if (!atEof) skipped++;
      if (nextPos == null) break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, {
    dialect
  } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state]) == 0) break;
    let accEnd = data[state + 1];
    for (let i2 = state + 3; i2 < accEnd; i2 += 2) if ((data[i2 + 1] & groupMask) > 0) {
      let term = data[i2];
      if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
        input.acceptToken(term);
        break;
      }
    }
    let next = input.next, low = 0, high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index2 = accEnd + mid + (mid << 1);
      let from = data[index2], to2 = data[index2 + 1] || 65536;
      if (next < from) high = mid;
      else if (next >= to2) low = mid + 1;
      else {
        state = data[index2 + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i2 = start, next; (next = data[i2]) != 65535; i2++) if (next == term) return i2 - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (; ; ) {
      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(
        cursor.to - 1,
        pos - 25
        /* Lookahead.Margin */
      )) : Math.min(tree.length, Math.max(
        cursor.from + 1,
        pos + 25
        /* Lookahead.Margin */
      ));
      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
      if (!cursor.parent()) return side < 0 ? 0 : tree.length;
    }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet2) {
    this.fragments = fragments;
    this.nodeSet = nodeSet2;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr2 = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr2) {
      this.safeFrom = fr2.openStart ? cutAt(fr2.tree, fr2.from + fr2.offset, 1) - fr2.offset : fr2.from;
      this.safeTo = fr2.openEnd ? cutAt(fr2.tree, fr2.to + fr2.offset, -1) - fr2.offset : fr2.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr2.tree);
      this.start.push(-fr2.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart) return null;
    while (this.fragment && this.safeTo <= pos) this.nextFragment();
    if (!this.fragment) return null;
    for (; ; ) {
      let last3 = this.trees.length - 1;
      if (last3 < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last3], index2 = this.index[last3];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index2];
      let start = this.start[last3] + top2.positions[index2];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom) return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to) return next;
          }
        }
        this.index[last3]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last3]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let {
      parser: parser2
    } = stack.p, {
      tokenizers
    } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i2 = 0; i2 < tokenizers.length; i2++) {
      if ((1 << i2 & mask) == 0) continue;
      let tokenizer = tokenizers[i2], token = this.tokens[i2];
      if (main && !tokenizer.fallback) continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25) lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex) break;
        }
      }
    }
    while (this.actions.length > actionIndex) this.actions.pop();
    if (lookAhead) stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken) return this.mainToken;
    let main = new CachedToken(), {
      pos,
      p: p2
    } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p2.stream.end);
    main.value = pos == p2.stream.end ? p2.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let {
        parser: parser2
      } = stack.p;
      for (let i2 = 0; i2 < parser2.specialized.length; i2++) if (parser2.specialized[i2] == token.value) {
        let result2 = parser2.specializers[i2](this.stream.read(token.start, token.end), stack);
        if (result2 >= 0 && stack.p.parser.dialect.allows(result2 >> 1)) {
          if ((result2 & 1) == 0) token.value = result2 >> 1;
          else token.extended = result2 >> 1;
          break;
        }
      }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index2) {
    for (let i2 = 0; i2 < index2; i2 += 3) if (this.actions[i2] == action) return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token;
    this.actions[index2++] = end;
    return index2;
  }
  addActions(stack, token, end, index2) {
    let {
      state
    } = stack, {
      parser: parser2
    } = stack.p, {
      data
    } = parser2;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i2 = parser2.stateSlot(
        state,
        set2 ? 2 : 1
        /* ParseState.Actions */
      ); ; i2 += 3) {
        if (data[i2] == 65535) {
          if (data[i2 + 1] == 1) {
            i2 = pair(data, i2 + 2);
          } else {
            if (index2 == 0 && data[i2 + 1] == 2) index2 = this.putAction(pair(data, i2 + 2), token, end, index2);
            break;
          }
        }
        if (data[i2] == token) index2 = this.putAction(pair(data, i2 + 1), token, end, index2);
      }
    }
    return index2;
  }
};
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let {
      from
    } = ranges[0];
    this.stacks = [Stack2.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s2] = stacks;
      while (s2.forceReduce() && s2.stack.length && s2.stack[s2.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose) console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering) this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose) console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a2, b) => b.score - a2.score);
        while (newStacks.length > maxRemaining) newStacks.pop();
      }
      if (newStacks.some((s2) => s2.reducePos > pos)) this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i2 = 0; i2 < newStacks.length - 1; i2++) {
        let stack = newStacks[i2];
        for (let j = i2 + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i2--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12) newStacks.splice(
        12,
        newStacks.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i2 = 1; i2 < newStacks.length; i2++) if (newStacks[i2].pos < this.minStackPos) this.minStackPos = newStacks[i2].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split2) {
    let start = stack.pos, {
      parser: parser2
    } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose) console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0) cached = inner;
        else break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose) console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
        defaultReduce & 65535
        /* Action.ValueMask */
      )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i2 = 0; i2 < actions.length; ) {
      let action = actions[i2++], term = actions[i2++], end = actions[i2++];
      let last3 = i2 == actions.length || !split2;
      let localStack = last3 ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose) console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
        action & 65535
        /* Action.ValueMask */
      )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last3) return true;
      else if (localStack.pos > start) stacks.push(localStack);
      else split2.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null)) return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2], token = tokens[i2 << 1], tokenEnd = tokens[(i2 << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted) continue;
        restarted = true;
        stack.restart();
        if (verbose) console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done) continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done) break;
        if (verbose) forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose) console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose) console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2) stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i2 = 0; i2 < newStacks.length; i2++) {
    let other = newStacks[i2];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i2].score < stack.score) newStacks[i2] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i2 = 0; i2 < spec.repeatNodeCount; i2++) nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1]);
    let nodeProps = [];
    for (let i2 = 0; i2 < nodeNames.length; i2++) nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {
      let prop = propSpec[0];
      if (typeof prop == "string") prop = NodeProp[prop];
      for (let i2 = 1; i2 < propSpec.length; ) {
        let next = propSpec[i2++];
        if (next >= 0) {
          setProp(next, prop, propSpec[i2++]);
        } else {
          let value = propSpec[i2 + -next];
          for (let j = -next; j > 0; j--) setProp(propSpec[i2++], prop, value);
          i2++;
        }
      }
    }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i2) => NodeType.define({
      name: i2 >= this.minRepeatTerm ? void 0 : name2,
      id: i2,
      props: nodeProps[i2],
      top: topTerms.indexOf(i2) > -1,
      error: i2 == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i2) > -1
    })));
    if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i2 = 0; i2 < this.specializerSpecs.length; i2++) this.specialized[i2] = this.specializerSpecs[i2].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0]) return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last3 = groupTag & 1;
      let target = table[pos++];
      if (last3 && loose) return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;
      if (last3) return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i2 = this.stateSlot(
        state,
        set2 ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i2 += 3) {
        if ((next = data[i2]) == 65535) {
          if (data[i2 + 1] == 1) next = data[i2 = pair(data, i2 + 2)];
          else if (data[i2 + 1] == 2) return pair(data, i2 + 2);
          else break;
        }
        if (next == terminal || next == 0) return pair(data, i2 + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a2) => a2 == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result2 = deflt ? action(deflt) : void 0;
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result2 == null; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1) i2 = pair(this.data, i2 + 2);
        else break;
      }
      result2 = action(pair(this.data, i2 + 1));
    }
    return result2;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result2 = [];
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1) i2 = pair(this.data, i2 + 2);
        else break;
      }
      if ((this.data[i2 + 2] & 65536 >> 16) == 0) {
        let value = this.data[i2 + 1];
        if (!result2.some((v, i3) => i3 & 1 && v == value)) result2.push(this.data[i2], value);
      }
    }
    return result2;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy2 = Object.assign(Object.create(_LRParser.prototype), this);
    if (config2.props) copy2.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info) throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy2.top = info;
    }
    if (config2.tokenizers) copy2.tokenizers = this.tokenizers.map((t3) => {
      let found = config2.tokenizers.find((r2) => r2.from == t3);
      return found ? found.to : t3;
    });
    if (config2.specializers) {
      copy2.specializers = this.specializers.slice();
      copy2.specializerSpecs = this.specializerSpecs.map((s2, i2) => {
        let found = config2.specializers.find((r2) => r2.from == s2.external);
        if (!found) return s2;
        let spec = Object.assign(Object.assign({}, s2), {
          external: found.to
        });
        copy2.specializers[i2] = getSpecializer(spec);
        return spec;
      });
    }
    if (config2.contextTracker) copy2.context = config2.contextTracker;
    if (config2.dialect) copy2.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null) copy2.strict = config2.strict;
    if (config2.wrap) copy2.wrappers = copy2.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null) copy2.bufferLength = config2.bufferLength;
    return copy2;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
    if (dialect) for (let part of dialect.split(" ")) {
      let id2 = values2.indexOf(part);
      if (id2 >= 0) flags[id2] = true;
    }
    let disabled = null;
    for (let i2 = 0; i2 < values2.length; i2++) if (!flags[i2]) {
      for (let j = this.dialects[values2[i2]], id2; (id2 = this.data[j++]) != 65535; ) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
    }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score)) best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/json/dist/index.js
var jsonHighlighting = styleTags({
  String: tags.string,
  Number: tags.number,
  "True False": tags.bool,
  PropertyName: tags.propertyName,
  Null: tags.null,
  ", :": tags.separator,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
var parser = LRParser.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [["isolate", -2, 6, 11, ""], ["openedBy", 7, "{", 14, "["], ["closedBy", 8, "}", 15, "]"]],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: {
    "JsonText": [0, 1]
  },
  tokenPrec: 0
});

// node_modules/@codemirror/lang-json/dist/index.js
var jsonLanguage = LRLanguage.define({
  name: "json",
  parser: parser.configure({
    props: [indentNodeProp.add({
      Object: continuedIndent({
        except: /^\s*\}/
      }),
      Array: continuedIndent({
        except: /^\s*\]/
      })
    }), foldNodeProp.add({
      "Object Array": foldInside
    })]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["[", "{", '"']
    },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new LanguageSupport(jsonLanguage);
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to2 = text.length, normalize, test2) {
    this.test = test2;
    this.value = {
      from: 0,
      to: 0
    };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to2);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done) return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt2(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length) this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize2(next);
      let norm = this.normalize(str);
      if (norm.length) for (let i2 = 0, pos = start; ; i2++) {
        let code = norm.charCodeAt(i2);
        let match = this.match(code, pos, this.bufferPos + this.bufferStart);
        if (i2 == norm.length - 1) {
          if (match) {
            this.value = match;
            return this;
          }
          break;
        }
        if (pos == start && i2 < str.length && str.charCodeAt(i2) == code) pos++;
      }
    }
  }
  match(code, pos, end) {
    let match = null;
    for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
      let index2 = this.matches[i2], keep = false;
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match = {
            from: this.matches[i2 + 1],
            to: end
          };
        } else {
          this.matches[i2]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i2, 2);
        i2 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1) match = {
        from: pos,
        to: end
      };
      else this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;
    return match;
  }
};
if (typeof Symbol != "undefined") SearchCursor.prototype[Symbol.iterator] = function() {
  return this;
};
var empty = {
  from: -1,
  to: -1,
  match: /.*/.exec("")
};
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to2 = text.length) {
    this.text = text;
    this.to = to2;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to2);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to) this.curLine = "";
    else this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to2 = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length) this.nextLine();
        if ((from < to2 || from > this.value.to) && (!this.test || this.test(from, to2, match))) {
          this.value = {
            from,
            to: to2,
            match
          };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to2) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to2 || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc2.sliceString(from, to2));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to2) return cached;
    let {
      text,
      from: cachedFrom
    } = cached;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to2) text += doc2.sliceString(cached.to, to2);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to2 - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to2) {
    this.text = text;
    this.to = to2;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to2 = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to2, match))) {
          this.value = {
            from,
            to: to2,
            match
          };
          this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a3) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length) return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344) pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", {
    class: "cm-textfield",
    name: "line",
    value: line
  });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({
          effects: dialogEffect.of(false)
        });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go2();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go2();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
    class: "cm-button",
    type: "submit"
  }, view.state.phrase("go")), crelt("button", {
    name: "close",
    onclick: () => {
      view.dispatch({
        effects: dialogEffect.of(false)
      });
      view.focus();
    },
    "aria-label": view.state.phrase("close"),
    type: "button"
  }, [""]));
  function go2() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match) return;
    let {
      state
    } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl2, percent] = match;
    let col = cl2 ? +cl2.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc2 = line2 / 100;
      if (sign) pc2 = pc2 * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc2);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, {
        y: "center"
      })],
      selection
    });
    view.focus();
  }
  return {
    dom
  };
}
var dialogEffect = StateEffect.define();
var dialogField2 = StateField.define({
  create() {
    return true;
  },
  update(value, tr2) {
    for (let e2 of tr2.effects) if (e2.is(dialogEffect)) value = e2.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField2, false) == null) effects.push(StateEffect.appendConfig.of([dialogField2, baseTheme$13]));
    view.dispatch({
      effects
    });
    panel = getPanel(view, createLineDialog);
  }
  if (panel) panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$13 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": {
      fontSize: "80%"
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a2, b) => a2 || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options) ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = Decoration.mark({
  class: "cm-selectionMatch"
});
var mainMatchDeco = Decoration.mark({
  class: "cm-selectionMatch cm-selectionMatch-main"
});
function insideWordBoundaries(check, state, from, to2) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to2 == state.doc.length || check(state.sliceDoc(to2, to2 + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to2) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to2 - 1, to2)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update2) {
    if (update2.selectionSet || update2.docChanged || update2.viewportChanged) this.decorations = this.getDeco(update2.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let {
      state
    } = view, sel = state.selection;
    if (sel.ranges.length > 1) return Decoration.none;
    let range2 = sel.main, query, check = null;
    if (range2.empty) {
      if (!conf.highlightWordAroundCursor) return Decoration.none;
      let word = state.wordAt(range2.head);
      if (!word) return Decoration.none;
      check = state.charCategorizer(range2.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range2.to - range2.from;
      if (len < conf.minSelectionLength || len > 200) return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range2.from, range2.to);
        check = state.charCategorizer(range2.head);
        if (!(insideWordBoundaries(check, state, range2.from, range2.to) && insideWord(check, state, range2.from, range2.to))) return Decoration.none;
      } else {
        query = state.sliceDoc(range2.from, range2.to);
        if (!query) return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.next().done) {
        let {
          from,
          to: to2
        } = cursor.value;
        if (!check || insideWordBoundaries(check, state, from, to2)) {
          if (range2.empty && from <= range2.from && to2 >= range2.to) deco.push(mainMatchDeco.range(from, to2));
          else if (from >= range2.to || to2 <= range2.from) deco.push(matchDeco.range(from, to2));
          if (deco.length > conf.maxMatches) return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": {
    backgroundColor: "#99ff7780"
  },
  ".cm-searchMatch .cm-selectionMatch": {
    backgroundColor: "transparent"
  }
});
var selectWord = ({
  state,
  dispatch
}) => {
  let {
    selection
  } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range2) => state.wordAt(range2.head) || EditorSelection.cursor(range2.head)), selection.mainIndex);
  if (newSel.eq(selection)) return false;
  dispatch(state.update({
    selection: newSel
  }));
  return true;
};
function findNextOccurrence(state, query) {
  let {
    main,
    ranges
  } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor.next();
    if (cursor.done) {
      if (cycled) return null;
      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor.value.from)) continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor.value.from);
        if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to) continue;
      }
      return cursor.value;
    }
  }
}
var selectNextOccurrence = ({
  state,
  dispatch
}) => {
  let {
    ranges
  } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to)) return selectWord({
    state,
    dispatch
  });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText)) return false;
  let range2 = findNextOccurrence(state, searchedText);
  if (!range2) return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range2.from, range2.to), false),
    effects: EditorView.scrollIntoView(range2.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range2) => EditorView.scrollIntoView(range2)
    });
  }
});
function search(config2) {
  return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
}
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch2) => ch2 == "n" ? "\n" : ch2 == "r" ? "\r" : ch2 == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to2) {
    let st3 = state.doc ? state : EditorState.create({
      doc: state
    });
    if (to2 == null) to2 = st3.doc.length;
    return this.regexp ? regexpCursor(this, st3, from, to2) : stringCursor(this, st3, from, to2);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to2) {
  return new SearchCursor(state.doc, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from, to2, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to2) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to2 + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to2) {
    for (let pos = to2; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor = stringCursor(this.spec, state, start, pos), range2 = null;
      while (!cursor.nextOverlapping().done) range2 = cursor.value;
      if (range2) return range2;
      if (start == from) return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit) return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to2, add4) {
    let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state.doc.length));
    while (!cursor.next().done) add4(cursor.value.from, cursor.value.to);
  }
};
function regexpCursor(spec, state, from, to2) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to2);
}
function charBefore(str, index2) {
  return str.slice(findClusterBreak2(str, index2, false), index2);
}
function charAfter(str, index2) {
  return str.slice(index2, findClusterBreak2(str, index2));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(state, from, to2) {
    for (let size2 = 1; ; size2++) {
      let start = Math.max(
        from,
        to2 - size2 * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor = regexpCursor(this.spec, state, start, to2), range2 = null;
      while (!cursor.next().done) range2 = cursor.value;
      if (range2 && (start == from || range2.from > start + 10)) return range2;
      if (start == from) return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result2) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i2) => {
      if (i2 == "&") return result2.match[0];
      if (i2 == "$") return "$";
      for (let l = i2.length; l > 0; l--) {
        let n2 = +i2.slice(0, l);
        if (n2 > 0 && n2 < result2.match.length) return result2.match[n2] + i2.slice(l);
      }
      return m;
    });
  }
  matchAll(state, limit) {
    let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit) return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to2, add4) {
    let cursor = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to2 + 250, state.doc.length));
    while (!cursor.next().done) add4(cursor.value.from, cursor.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel2 = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr2) {
    for (let effect of tr2.effects) {
      if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel2)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({
  class: "cm-searchMatch"
});
var selectedMatchMark = Decoration.mark({
  class: "cm-searchMatch cm-searchMatch-selected"
});
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update2) {
    let state = update2.state.field(searchState);
    if (state != update2.startState.field(searchState) || update2.docChanged || update2.selectionSet || update2.viewportChanged) this.decorations = this.highlight(state);
  }
  highlight({
    query,
    panel
  }) {
    if (!panel || !query.spec.valid) return Decoration.none;
    let {
      view
    } = this;
    let builder = new RangeSetBuilder();
    for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
      let {
        from,
        to: to2
      } = ranges[i2];
      while (i2 < l - 1 && to2 > ranges[i2 + 1].from - 2 * 250) to2 = ranges[++i2].to;
      query.highlight(view.state, from, to2, (from2, to3) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to3);
        builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, {
  query
}) => {
  let {
    to: to2
  } = view.state.selection.main;
  let next = query.nextMatch(view.state, to2, to2);
  if (!next) return false;
  let selection = EditorSelection.single(next.from, next.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, {
  query
}) => {
  let {
    state
  } = view, {
    from
  } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev) return false;
  let selection = EditorSelection.single(prev.from, prev.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, {
  query
}) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length) return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({
  state,
  dispatch
}) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty) return false;
  let {
    from,
    to: to2
  } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to2)); !cur2.next().done; ) {
    if (ranges.length > 1e3) return false;
    if (cur2.value.from == from) main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, {
  query
}) => {
  let {
    state
  } = view, {
    from,
    to: to2
  } = state.selection.main;
  if (state.readOnly) return false;
  let match = query.nextMatch(state, from, from);
  if (!match) return false;
  let next = match;
  let changes = [], selection, replacement;
  let effects = [];
  if (next.from == from && next.to == to2) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({
      from: next.from,
      to: next.to,
      insert: replacement
    });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  let changeSet = view.state.changes(changes);
  if (next) {
    selection = EditorSelection.single(next.from, next.to).map(changeSet);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
  }
  view.dispatch({
    changes: changeSet,
    selection,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, {
  query
}) => {
  if (view.state.readOnly) return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let {
      from,
      to: to2
    } = match;
    return {
      from,
      to: to2,
      insert: query.getReplacement(match)
    };
  });
  if (!changes.length) return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a3, _b, _c2, _d2, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText) return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a3 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a3 !== void 0 ? _a3 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c2 !== void 0 ? _c2 : config2.literal,
    regexp: (_d2 = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d2 !== void 0 ? _d2 : config2.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement) input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid) view.dispatch({
        effects: setSearchQuery.of(query)
      });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({
      effects: [togglePanel2.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)]
    });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel) return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();
  view.dispatch({
    effects: togglePanel2.of(false)
  });
  return true;
};
var searchKeymap = [{
  key: "Mod-f",
  run: openSearchPanel,
  scope: "editor search-panel"
}, {
  key: "F3",
  run: findNext,
  shift: findPrevious,
  scope: "editor search-panel",
  preventDefault: true
}, {
  key: "Mod-g",
  run: findNext,
  shift: findPrevious,
  scope: "editor search-panel",
  preventDefault: true
}, {
  key: "Escape",
  run: closeSearchPanel,
  scope: "editor search-panel"
}, {
  key: "Mod-Shift-l",
  run: selectSelectionMatches
}, {
  key: "Mod-Alt-g",
  run: gotoLine
}, {
  key: "Mod-d",
  run: selectNextOccurrence,
  preventDefault: true
}];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", {
        class: "cm-button",
        name: name2,
        onclick,
        type: "button"
      }, content2);
    }
    this.dom = crelt("div", {
      onkeydown: (e2) => this.keydown(e2),
      class: "cm-search"
    }, [this.searchField, button("next", () => findNext(view), [phrase(view, "next")]), button("prev", () => findPrevious(view), [phrase(view, "previous")]), button("select", () => selectMatches(view), [phrase(view, "all")]), crelt("label", null, [this.caseField, phrase(view, "match case")]), crelt("label", null, [this.reField, phrase(view, "regexp")]), crelt("label", null, [this.wordField, phrase(view, "by word")]), ...view.state.readOnly ? [] : [crelt("br"), this.replaceField, button("replace", () => replaceNext(view), [phrase(view, "replace")]), button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])], crelt("button", {
      name: "close",
      onclick: () => closeSearchPanel(view),
      "aria-label": phrase(view, "close"),
      type: "button"
    }, [""])]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({
        effects: setSearchQuery.of(query)
      });
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, "search-panel")) {
      e2.preventDefault();
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault();
      (e2.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update2) {
    for (let tr2 of update2.transactions) for (let effect of tr2.effects) {
      if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);
    }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, {
  from,
  to: to2
}) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to2).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to2 + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i2 = 0; i2 < AnnounceMargin; i2++) if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
      text = text.slice(i2);
      break;
    }
  }
  if (end != lineEnd) {
    for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--) if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
      text = text.slice(0, i2);
      break;
    }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme4 = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": {
    backgroundColor: "#ffff0054"
  },
  "&dark .cm-searchMatch": {
    backgroundColor: "#00ffff8a"
  },
  "&light .cm-searchMatch-selected": {
    backgroundColor: "#ff6a0054"
  },
  "&dark .cm-searchMatch-selected": {
    backgroundColor: "#ff00ff8a"
  }
});
var searchExtensions = [searchState, Prec.low(searchHighlighter), baseTheme4];

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0) token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : {
      from: start + found,
      to: this.pos,
      text: str.slice(found)
    };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange) this.abortOnDocChange = true;
    }
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words2 = /\w/.test(flat);
  if (words2) flat = flat.replace(/\w/g, "");
  return `[${words2 ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest2 = /* @__PURE__ */ Object.create(null);
  for (let {
    label
  } of options) {
    first[label[0]] = true;
    for (let i2 = 1; i2 < label.length; i2++) rest2[label[i2]] = true;
  }
  let source = toSet(first) + toSet(rest2) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o2) => typeof o2 == "string" ? {
    label: o2
  } : o2);
  let [validFor, match] = options.every((o2) => /^\w+$/.test(o2.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? {
      from: token ? token.from : context.pos,
      options,
      validFor
    } : null;
  };
}
var Option = class {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a3;
  let {
    source
  } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd) return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a3 = expr.flags) !== null && _a3 !== void 0 ? _a3 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = Annotation.define();
function insertCompletionText(state, text, from, to2) {
  let {
    main
  } = state.selection, fromOff = from - main.from, toOff = to2 - main.from;
  return Object.assign(Object.assign({}, state.changeByRange((range2) => {
    if (range2 != main && from != to2 && state.sliceDoc(range2.from + fromOff, range2.from + toOff) != state.sliceDoc(from, to2)) return {
      range: range2
    };
    let lines = state.toText(text);
    return {
      changes: {
        from: range2.from + fromOff,
        to: to2 == main.from ? range2.to : range2.from + toOff,
        insert: lines
      },
      range: EditorSelection.cursor(range2.from + fromOff + lines.length)
    };
  })), {
    scrollIntoView: true,
    userEvent: "input.complete"
  });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source)) return source;
  let known = SourceCache.get(source);
  if (!known) SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = StateEffect.define();
var closeCompletionEffect = StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p2 = 0; p2 < pattern.length; ) {
      let char = codePointAt2(pattern, p2), size2 = codePointSize2(char);
      this.chars.push(char);
      let part = pattern.slice(p2, p2 + size2), upper = part.toUpperCase();
      this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
      p2 += size2;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0) return this.ret(-100, []);
    if (word.length < this.pattern.length) return null;
    let {
      chars,
      folded,
      any,
      precise,
      byWord
    } = this;
    if (chars.length == 1) {
      let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0]) score2 += -200;
      else return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
        let next = codePointAt2(word, i2);
        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i2;
        i2 += codePointSize2(next);
      }
      if (anyTo < len) return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
      let next = codePointAt2(word, i2);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i2;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0) adjacentStart = i2;
            adjacentEnd = i2 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch2, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch2 = fromCodePoint(next)) != ch2.toLowerCase() ? 1 : ch2 != ch2.toUpperCase() ? 2 : 0;
      if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i2;
        else if (byWord.length) wordAdjacent = false;
      }
      prevType = type;
      i2 += codePointSize2(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1) return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len) return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len) return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result2 = [], i2 = 0;
    for (let pos of positions) {
      let to2 = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
      if (i2 && result2[i2 - 1] == pos) result2[i2 - 1] = to2;
      else {
        result2[i2++] = pos;
        result2[i2++] = to2;
      }
    }
    return this.ret(score2 - word.length, result2);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length) return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null) return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a2, b) => a2.label.localeCompare(b.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a2, b) => a2 && b,
      closeOnBlur: (a2, b) => a2 && b,
      icons: (a2, b) => a2 && b,
      tooltipClass: (a2, b) => (c) => joinClass(a2(c), b(c)),
      optionClass: (a2, b) => (c) => joinClass(a2(c), b(c)),
      addToOptions: (a2, b) => a2.concat(b),
      filterStrict: (a2, b) => a2 || b
    });
  }
});
function joinClass(a2, b) {
  return a2 ? b ? a2 + " " + b : a2 : b;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons) content2.push({
    render(completion) {
      let icon = document.createElement("div");
      icon.classList.add("cm-completionIcon");
      if (completion.type) icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
      icon.setAttribute("aria-hidden", "true");
      return icon;
    },
    position: 20
  });
  content2.push({
    render(completion, _s2, _v2, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to2 = match[j++];
        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to2)));
        span.className = "cm-completionMatchedText";
        off = to2;
      }
      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail) return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a2, b) => a2.position - b.position).map((a2) => a2.render);
}
function rangeAroundSelected(total, selected, max2) {
  if (total <= max2) return {
    from: 0,
    to: total
  };
  if (selected < 0) selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max2);
    return {
      from: off2 * max2,
      to: (off2 + 1) * max2
    };
  }
  let off = Math.floor((total - selected) / max2);
  return {
    from: total - (off + 1) * max2,
    to: total - off * max2
  };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let {
      options,
      selected
    } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e2) => {
      let {
        options: options2
      } = view.state.field(stateField).open;
      for (let dom = e2.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          this.applyCompletion(view, options2[+match[1]]);
          e2.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e2) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e2.relatedTarget != view.contentDOM) view.dispatch({
        effects: closeCompletionEffect.of(null)
      });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id2) {
    if (this.list) this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info) this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update2) {
    var _a3;
    let cState = update2.state.field(this.stateField);
    let prevState = update2.startState.field(this.stateField);
    this.updateTooltipClass(update2.state);
    if (cState != prevState) {
      let {
        options,
        selected,
        disabled
      } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update2.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a3 = prevState.open) === null || _a3 === void 0 ? void 0 : _a3.disabled)) this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(" ")) if (c) this.dom.classList.remove(c);
      for (let c of cls.split(" ")) if (c) this.dom.classList.add(c);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info) this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let {
        completion
      } = open.options[open.selected];
      let {
        info
      } = completion;
      if (!info) return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult) return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);
        }).catch((e2) => logException(this.view.state, e2, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap2 = this.info = document.createElement("div");
    wrap2.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap2.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let {
        dom,
        destroy
      } = content2;
      wrap2.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap2);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set2 = null;
    for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i2--;
      } else if (i2 == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set2 = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected")) opt.removeAttribute("aria-selected");
      }
    }
    if (set2) scrollIntoView2(this.list, set2);
    return set2;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info) return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let docElt = this.dom.ownerDocument.documentElement;
      space = {
        left: 0,
        top: 0,
        right: docElt.clientWidth,
        bottom: docElt.clientHeight
      };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style) this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id2, range2) {
    const ul2 = document.createElement("ul");
    ul2.id = id2;
    ul2.setAttribute("role", "listbox");
    ul2.setAttribute("aria-expanded", "true");
    ul2.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul2.addEventListener("mousedown", (e2) => {
      if (e2.target == ul2) e2.preventDefault();
    });
    let curSection = null;
    for (let i2 = range2.from; i2 < range2.to; i2++) {
      let {
        completion,
        match
      } = options[i2], {
        section
      } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i2 > range2.from || range2.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul2.appendChild(section.header(section));
          } else {
            let header = ul2.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li2 = ul2.appendChild(document.createElement("li"));
      li2.id = id2 + "-" + i2;
      li2.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls) li2.className = cls;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match);
        if (node) li2.appendChild(node);
      }
    }
    if (range2.from) ul2.classList.add("cm-completionListIncompleteTop");
    if (range2.to < options.length) ul2.classList.add("cm-completionListIncompleteBottom");
    return ul2;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy) this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent2 = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent2.height / container.offsetHeight;
  if (self2.top < parent2.top) container.scrollTop -= (parent2.top - self2.top) / scaleY;
  else if (self2.bottom > parent2.bottom) container.scrollTop += (self2.bottom - parent2.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null;
  let addOption = (option) => {
    options.push(option);
    let {
      section
    } = option.completion;
    if (section) {
      if (!sections) sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s2) => s2.name == name2)) sections.push(typeof section == "string" ? {
        name: name2
      } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a2 of active) if (a2.hasResult()) {
    let getMatch = a2.result.getMatch;
    if (a2.result.filter === false) {
      for (let option of a2.result.options) {
        addOption(new Option(option, a2.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
      }
    } else {
      let pattern = state.sliceDoc(a2.from, a2.to), match;
      let matcher2 = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
      for (let option of a2.result.options) if (match = matcher2.match(option.label)) {
        let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
        addOption(new Option(option, a2.source, matched, match.score + (option.boost || 0)));
      }
    }
  }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a2, b) => {
      var _a3, _b;
      return ((_a3 = a2.rank) !== null && _a3 !== void 0 ? _a3 : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a2.name < b.name ? -1 : 1);
    };
    for (let s2 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s2.name] = pos;
    }
    for (let option of options) {
      let {
        section
      } = option.completion;
      if (section) option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result2 = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a2, b) => b.score - a2.score || compare2(a2.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost) result2.push(opt);
    else if (score(opt.completion) > score(prev)) result2[result2.length - 1] = opt;
    prev = opt.completion;
  }
  return result2;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id2, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s2) => s2.isPending)) return prev.setDisabled();
    let options = sortOptions(active, state);
    if (!options.length) return prev && active.some((a2) => a2.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i2 = 0; i2 < options.length; i2++) if (options[i2].completion == selectedValue) {
        selected = i2;
        break;
      }
    }
    return new _CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a2, b) => b.hasResult() ? Math.min(a2, b.from) : a2, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
      pos: changes.mapPos(this.tooltip.pos)
    }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr2) {
    let {
      state
    } = tr2, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s2) => s2.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a2) => a2.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr2, conf);
    });
    if (active.length == this.active.length && active.every((a2, i2) => a2 == this.active[i2])) active = this.active;
    let open = this.open, didSet = tr2.effects.some((e2) => e2.is(setActiveEffect));
    if (open && tr2.docChanged) open = open.map(tr2.changes);
    if (tr2.selection || active.some((a2) => a2.hasResult() && tr2.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active) || didSet) open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a2) => a2.isPending)) open = null;
    if (!open && active.every((a2) => !a2.isPending) && active.some((a2) => a2.hasResult())) active = active.map((a2) => a2.hasResult() ? new ActiveSource(
      a2.source,
      0
      /* State.Inactive */
    ) : a2);
    for (let effect of tr2.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
  }
};
function sameResults(a2, b) {
  if (a2 == b) return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a2.length && !a2[iA].hasResult()) iA++;
    while (iB < b.length && !b[iB].hasResult()) iB++;
    let endA = iA == a2.length, endB = iB == b.length;
    if (endA || endB) return endA == endB;
    if (a2[iA++].result != b[iB++].result) return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs2 = {};
function makeAttrs(id2, selected) {
  let result2 = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1) result2["aria-activedescendant"] = id2 + "-" + selected;
  return result2;
}
var none3 = [];
function getUpdateType(tr2, conf) {
  if (tr2.isUserEvent("input.complete")) {
    let completion = tr2.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion)) return 4 | 8;
  }
  let typing = tr2.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr2.isUserEvent("delete.backward") ? 2 : tr2.selection ? 8 : tr2.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr2, conf) {
    let type = getUpdateType(tr2, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr2)) value = new _ActiveSource(
      value.source,
      0
      /* State.Inactive */
    );
    if (type & 4 && value.state == 0) value = new _ActiveSource(
      this.source,
      1
      /* State.Pending */
    );
    value = value.updateFor(tr2, type);
    for (let effect of tr2.effects) {
      if (effect.is(startCompletionEffect)) value = new _ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect)) value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value) if (active.source == value.source) value = active;
      }
    }
    return value;
  }
  updateFor(tr2, type) {
    return this.map(tr2.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr2) {
    return tr2.changes.touchesRange(cur(tr2.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result2, from, to2) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result2;
    this.from = from;
    this.to = to2;
  }
  hasResult() {
    return true;
  }
  updateFor(tr2, type) {
    var _a3;
    if (!(type & 3)) return this.map(tr2.changes);
    let result2 = this.result;
    if (result2.map && !tr2.changes.empty) result2 = result2.map(result2, tr2.changes);
    let from = tr2.changes.mapPos(this.from), to2 = tr2.changes.mapPos(this.to, 1);
    let pos = cur(tr2.state);
    if (pos > to2 || !result2 || type & 2 && (cur(tr2.startState) == this.from || pos < this.limit)) return new ActiveSource(
      this.source,
      type & 4 ? 1 : 0
      /* State.Inactive */
    );
    let limit = tr2.changes.mapPos(this.limit);
    if (checkValid(result2.validFor, tr2.state, from, to2)) return new _ActiveResult(this.source, this.explicit, limit, result2, from, to2);
    if (result2.update && (result2 = result2.update(result2, from, to2, new CompletionContext(tr2.state, pos, false)))) return new _ActiveResult(this.source, this.explicit, limit, result2, result2.from, (_a3 = result2.to) !== null && _a3 !== void 0 ? _a3 : cur(tr2.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty) return this;
    let result2 = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result2) return new ActiveSource(
      this.source,
      0
      /* State.Inactive */
    );
    return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr2) {
    return tr2.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to2) {
  if (!validFor) return false;
  let text = state.sliceDoc(from, to2);
  return typeof validFor == "function" ? validFor(text, from, to2, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = StateEffect.define({
  map(sources, mapping) {
    return sources.map((s2) => s2.map(mapping));
  }
});
var setSelectedEffect = StateEffect.define();
var completionState = StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr2) {
    return value.update(tr2);
  },
  provide: (f) => [showTooltip.from(f, (val) => val.tooltip), EditorView.contentAttributes.from(f, (state) => state.attrs)]
});
function applyCompletion(view, option) {
  const apply2 = option.completion.apply || option.completion.label;
  let result2 = view.state.field(completionState).active.find((a2) => a2.source == option.source);
  if (!(result2 instanceof ActiveResult)) return false;
  if (typeof apply2 == "string") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply2, result2.from, result2.to)), {
    annotations: pickedCompletion.of(option.completion)
  }));
  else apply2(view, option.completion, result2.from, result2.to);
  return true;
}
var createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let {
      length
    } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0) selected = by == "page" ? 0 : length - 1;
    else if (selected >= length) selected = by == "page" ? length - 1 : 0;
    view.dispatch({
      effects: setSelectedEffect.of(selected)
    });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState) return false;
  view.dispatch({
    effects: startCompletionEffect.of(true)
  });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a2) => a2.state != 0
    /* State.Inactive */
  )) return false;
  view.dispatch({
    effects: closeCompletionEffect.of(null)
  });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active) if (active.isPending) this.startQuery(active);
  }
  update(update2) {
    let cState = update2.state.field(completionState);
    let conf = update2.state.facet(completionConfig);
    if (!update2.selectionSet && !update2.docChanged && update2.startState.field(completionState) == cState) return;
    let doesReset = update2.transactions.some((tr2) => {
      let type = getUpdateType(tr2, conf);
      return type & 8 || (tr2.selection || tr2.docChanged) && !(type & 3);
    });
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (doesReset || query.context.abortOnDocChange && update2.docChanged || query.updates.length + update2.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e2) {
            logException(this.view.state, e2);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i2--, 1);
      } else {
        query.updates.push(...update2.transactions);
      }
    }
    if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);
    if (update2.transactions.some((tr2) => tr2.effects.some((e2) => e2.is(startCompletionEffect)))) this.pendingStart = true;
    let delay2 = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a2) => a2.isPending && !this.running.some((q2) => q2.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), delay2) : -1;
    if (this.composing != 0) for (let tr2 of update2.transactions) {
      if (tr2.isUserEvent("input.type")) this.composing = 2;
      else if (this.composing == 2 && tr2.selection) this.composing = 3;
    }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let {
      state
    } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.isPending && !this.running.some((r2) => r2.active.source == active.source)) this.startQuery(active);
    }
    if (this.running.length && cState.open && cState.open.disabled) this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  startQuery(active) {
    let {
      state
    } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result2) => {
      if (!pending.context.aborted) {
        pending.done = result2 || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({
        effects: closeCompletionEffect.of(null)
      });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q2) => q2.done !== void 0)) this.accept();
    else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a3;
    if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (query.done === void 0) continue;
      this.running.splice(i2--, 1);
      if (query.done) {
        let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
        let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
        let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a3 = query.done.to) !== null && _a3 !== void 0 ? _a3 : pos);
        for (let tr2 of query.updates) active = active.update(tr2, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = cState.active.find((a2) => a2.source == query.active.source);
      if (current && current.isPending) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr2 of query.updates) active = active.update(tr2, conf);
          if (!active.isPending) updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length || cState.open && cState.open.disabled) this.view.dispatch({
      effects: setActiveEffect.of(updated)
    });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(() => this.view.dispatch({
          effects: closeCompletionEffect.of(null)
        }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({
          effects: startCompletionEffect.of(false)
        }), 20);
      }
      this.composing = 0;
    }
  }
});
var windows = typeof navigator == "object" && /Win/.test(navigator.platform);
var commitCharacters = Prec.highest(EditorView.domEventHandlers({
  keydown(event, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;
    let option = field.open.options[field.open.selected];
    let result2 = field.active.find((a2) => a2.source == option.source);
    let commitChars = option.completion.commitCharacters || result2.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);
    return false;
  }
}));
var baseTheme5 = EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": {
    right: "100%"
  },
  ".cm-completionInfo.cm-completionInfo-right": {
    left: "100%"
  },
  ".cm-completionInfo.cm-completionInfo-left-narrow": {
    right: `${30}px`
  },
  ".cm-completionInfo.cm-completionInfo-right-narrow": {
    left: `${30}px`
  },
  "&light .cm-snippetField": {
    backgroundColor: "#00000022"
  },
  "&dark .cm-snippetField": {
    backgroundColor: "#ffffff22"
  },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-class": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-interface": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-variable": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-constant": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-type": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-enum": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-property": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-keyword": {
    "&:after": {
      content: "''"
    }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": {
      content: "''"
    }
  },
  ".cm-completionIcon-text": {
    "&:after": {
      content: "'abc'",
      fontSize: "50%",
      verticalAlign: "middle"
    }
  }
});
var fieldMarker = Decoration.widget({
  widget: new class extends WidgetType {
    toDOM() {
      let span = document.createElement("span");
      span.className = "cm-snippetFieldPosition";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  }()
});
var fieldRange = Decoration.mark({
  class: "cm-snippetField"
});
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r2 of this.ranges) {
      let mapped = r2.map(changes);
      if (!mapped) return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range2) => this.ranges.some((r2) => r2.field == this.active && r2.from <= range2.from && r2.to >= range2.to));
  }
};
var setActive = StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = StateEffect.define();
var snippetState = StateField.define({
  create() {
    return null;
  },
  update(value, tr2) {
    for (let effect of tr2.effects) {
      if (effect.is(setActive)) return effect.value;
      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr2.docChanged) value = value.map(tr2.changes);
    if (value && tr2.selection && !value.selectionInsideField(tr2.selection)) value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to)));
}
function moveField(dir) {
  return ({
    state,
    dispatch
  }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0) return false;
    let next = active.active + dir, last3 = dir > 0 && !active.ranges.some((r2) => r2.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last3 ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({
  state,
  dispatch
}) => {
  let active = state.field(snippetState, false);
  if (!active) return false;
  dispatch(state.update({
    effects: setActive.of(null)
  }));
  return true;
};
var nextSnippetField = moveField(1);
var prevSnippetField = moveField(-1);
var defaultSnippetKeymap = [{
  key: "Tab",
  run: nextSnippetField,
  shift: prevSnippetField
}, {
  key: "Escape",
  run: clearSnippet
}];
var snippetKeymap = Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = Prec.highest(keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
var snippetPointerHandler = EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    })) == null) return false;
    let match = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos);
    if (!match || match.field == active.active) return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some((r2) => r2.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults3 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr2) {
    value = value.map(tr2.changes);
    if (tr2.selection) {
      let line = tr2.state.doc.lineAt(tr2.selection.main.head);
      value = value.update({
        filter: (from) => from >= line.from && from <= line.to
      });
    }
    for (let effect of tr2.effects) if (effect.is(closeBracketEffect)) value = value.update({
      add: [closedBracket.range(effect.value, effect.value + 1)]
    });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch2) {
  for (let i2 = 0; i2 < definedClosing.length; i2 += 2) if (definedClosing.charCodeAt(i2) == ch2) return definedClosing.charAt(i2 + 1);
  return fromCodePoint(ch2 < 128 ? ch2 : ch2 + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults3;
}
var android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var inputHandler2 = EditorView.inputHandler.of((view, from, to2, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to2 != sel.to) return false;
  let tr2 = insertBracket(view.state, insert2);
  if (!tr2) return false;
  view.dispatch(tr2);
  return true;
});
var deleteBracketPair = ({
  state,
  dispatch
}) => {
  if (state.readOnly) return false;
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults3.brackets;
  let dont = null, changes = state.changeByRange((range2) => {
    if (range2.empty) {
      let before2 = prevChar(state.doc, range2.head);
      for (let token of tokens) {
        if (token == before2 && nextChar(state.doc, range2.head) == closing(codePointAt2(token, 0))) return {
          changes: {
            from: range2.head - token.length,
            to: range2.head + token.length
          },
          range: EditorSelection.cursor(range2.head - token.length)
        };
      }
    }
    return {
      range: dont = range2
    };
  });
  if (!dont) dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "delete.backward"
  }));
  return !dont;
};
var closeBracketsKeymap = [{
  key: "Backspace",
  run: deleteBracketPair
}];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults3.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults3.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos) found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize2(codePointAt2(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty) return {
      changes: [{
        insert: open,
        from: range2.from
      }, {
        insert: close,
        from: range2.to
      }],
      effects: closeBracketEffect.of(range2.to + open.length),
      range: EditorSelection.range(range2.anchor + open.length, range2.head + open.length)
    };
    let next = nextChar(state.doc, range2.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) return {
      changes: {
        insert: open + close,
        from: range2.head
      },
      effects: closeBracketEffect.of(range2.head + open.length),
      range: EditorSelection.cursor(range2.head + open.length)
    };
    return {
      range: dont = range2
    };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range2) => {
    if (range2.empty && nextChar(state.doc, range2.head) == close) return {
      changes: {
        from: range2.head,
        to: range2.head + close.length,
        insert: close
      },
      range: EditorSelection.cursor(range2.head + close.length)
    };
    return dont = {
      range: range2
    };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults3.stringPrefixes;
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty) return {
      changes: [{
        insert: token,
        from: range2.from
      }, {
        insert: token,
        from: range2.to
      }],
      effects: closeBracketEffect.of(range2.to + token.length),
      range: EditorSelection.range(range2.anchor + token.length, range2.head + token.length)
    };
    let pos = range2.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: {
            insert: token + token,
            from: pos
          },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: {
            from: pos,
            to: pos + content2.length,
            insert: content2
          },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: {
          insert: token + token + token + token,
          from: pos
        },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {
        changes: {
          insert: token + token,
          from: pos
        },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    }
    return {
      range: dont = range2
    };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m, p2) => Math.max(m, p2.length), 0);
  for (let i2 = 0; i2 < 5; i2++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent2 = node.to == pos && node.parent;
    if (!parent2) break;
    node = parent2;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word) return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word) return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [commitCharacters, completionState, completionConfig.of(config2), completionPlugin, completionKeymapExt, baseTheme5];
}
var completionKeymap = [{
  key: "Ctrl-Space",
  run: startCompletion
}, {
  mac: "Alt-`",
  run: startCompletion
}, {
  key: "Escape",
  run: closeCompletion
}, {
  key: "ArrowDown",
  run: moveCompletionSelection(true)
}, {
  key: "ArrowUp",
  run: moveCompletionSelection(false)
}, {
  key: "PageDown",
  run: moveCompletionSelection(true, "page")
}, {
  key: "PageUp",
  run: moveCompletionSelection(false, "page")
}, {
  key: "Enter",
  run: acceptCompletion
}];
var completionKeymapExt = Prec.highest(keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@replit/codemirror-indentation-markers/dist/index.js
function getVisibleLines(view, state = view.state) {
  const lines = /* @__PURE__ */ new Set();
  for (const {
    from,
    to: to2
  } of view.visibleRanges) {
    let pos = from;
    while (pos <= to2) {
      const line = state.doc.lineAt(pos);
      if (!lines.has(line)) {
        lines.add(line);
      }
      pos = line.to + 1;
    }
  }
  return lines;
}
function getCurrentLine(state) {
  const currentPos = state.selection.main.head;
  return state.doc.lineAt(currentPos);
}
function numColumns(str, tabSize) {
  let col = 0;
  loop: for (let i2 = 0; i2 < str.length; i2++) {
    switch (str[i2]) {
      case " ":
      case "": {
        col += 1;
        continue loop;
      }
      case "	": {
        col += tabSize - col % tabSize;
        continue loop;
      }
      case "\r": {
        continue loop;
      }
      default: {
        break loop;
      }
    }
  }
  return col;
}
var indentationMarkerConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      highlightActiveBlock: true,
      hideFirstIndent: false,
      markerType: "fullScope",
      thickness: 1
    });
  }
});
var IndentationMap = class {
  /**
   * @param lines - The set of lines to get the indentation map for.
   * @param state - The {@link EditorState} to derive the indentation map from.
   * @param unitWidth - The width of the editor's indent unit.
   * @param markerType - The type of indentation to use (terminate at end of scope vs last line of code in scope)
   */
  constructor(lines, state, unitWidth, markerType) {
    this.lines = lines;
    this.state = state;
    this.map = /* @__PURE__ */ new Map();
    this.unitWidth = unitWidth;
    this.markerType = markerType;
    for (const line of this.lines) {
      this.add(line);
    }
    if (this.state.facet(indentationMarkerConfig).highlightActiveBlock) {
      this.findAndSetActiveLines();
    }
  }
  /**
   * Checks if the indentation map has an entry for the given line.
   *
   * @param line - The {@link Line} or line number to check for.
   */
  has(line) {
    return this.map.has(typeof line === "number" ? line : line.number);
  }
  /**
   * Returns the {@link IndentEntry} for the given line.
   *
   * Note that this function will throw an error if the line does not exist in the map.
   *
   * @param line - The {@link Line} or line number to get the entry for.
   */
  get(line) {
    const entry = this.map.get(typeof line === "number" ? line : line.number);
    if (!entry) {
      throw new Error("Line not found in indentation map");
    }
    return entry;
  }
  /**
   * Sets the {@link IndentEntry} for the given line.
   *
   * @param line - The {@link Line} to set the entry for.
   * @param col - The visual beginning whitespace width of the line.
   * @param level - The indentation level of the line.
   */
  set(line, col, level) {
    const empty2 = !line.text.trim().length;
    const entry = {
      line,
      col,
      level,
      empty: empty2
    };
    this.map.set(entry.line.number, entry);
    return entry;
  }
  /**
   * Adds a line to the indentation map.
   *
   * @param line - The {@link Line} to add to the map.
   */
  add(line) {
    if (this.has(line)) {
      return this.get(line);
    }
    if (!line.length || !line.text.trim().length) {
      if (line.number === 1) {
        return this.set(line, 0, 0);
      }
      if (line.number === this.state.doc.lines) {
        const prev2 = this.closestNonEmpty(line, -1);
        return this.set(line, 0, prev2.level);
      }
      const prev = this.closestNonEmpty(line, -1);
      const next = this.closestNonEmpty(line, 1);
      if (prev.level >= next.level && this.markerType !== "codeOnly") {
        return this.set(line, 0, prev.level);
      }
      if (prev.empty && prev.level === 0 && next.level !== 0) {
        return this.set(line, 0, 0);
      }
      if (next.level > prev.level) {
        return this.set(line, 0, prev.level + 1);
      }
      return this.set(line, 0, next.level);
    }
    const col = numColumns(line.text, this.state.tabSize);
    const level = Math.floor(col / this.unitWidth);
    return this.set(line, col, level);
  }
  /**
   * Finds the closest non-empty line, starting from the given line.
   *
   * @param from - The {@link Line} to start from.
   * @param dir - The direction to search in. Either `1` or `-1`.
   */
  closestNonEmpty(from, dir) {
    let lineNo = from.number + dir;
    while (dir === -1 ? lineNo >= 1 : lineNo <= this.state.doc.lines) {
      if (this.has(lineNo)) {
        const entry = this.get(lineNo);
        if (!entry.empty) {
          return entry;
        }
      }
      const line2 = this.state.doc.line(lineNo);
      if (line2.text.trim().length) {
        const col = numColumns(line2.text, this.state.tabSize);
        const level = Math.floor(col / this.unitWidth);
        return this.set(line2, col, level);
      }
      lineNo += dir;
    }
    const line = this.state.doc.line(dir === -1 ? 1 : this.state.doc.lines);
    return this.set(line, 0, 0);
  }
  /**
   * Finds the state's active block (via the current selection) and sets all
   * the active indent level for the lines in the block.
   */
  findAndSetActiveLines() {
    const currentLine = getCurrentLine(this.state);
    if (!this.has(currentLine)) {
      return;
    }
    let current = this.get(currentLine);
    if (this.has(current.line.number + 1)) {
      const next = this.get(current.line.number + 1);
      if (next.level > current.level) {
        current = next;
      }
    }
    if (this.has(current.line.number - 1)) {
      const prev = this.get(current.line.number - 1);
      if (prev.level > current.level) {
        current = prev;
      }
    }
    if (current.level === 0) {
      return;
    }
    current.active = current.level;
    let start;
    let end;
    for (start = current.line.number; start > 1; start--) {
      if (!this.has(start - 1)) {
        continue;
      }
      const prev = this.get(start - 1);
      if (prev.level < current.level) {
        break;
      }
      prev.active = current.level;
    }
    for (end = current.line.number; end < this.state.doc.lines; end++) {
      if (!this.has(end + 1)) {
        continue;
      }
      const next = this.get(end + 1);
      if (next.level < current.level) {
        break;
      }
      next.active = current.level;
    }
  }
};
function indentTheme(colorOptions) {
  const defaultColors = {
    light: "#F0F1F2",
    dark: "#2B3245",
    activeLight: "#E4E5E6",
    activeDark: "#3C445C"
  };
  let colors = defaultColors;
  if (colorOptions) {
    colors = Object.assign(Object.assign({}, defaultColors), colorOptions);
  }
  return EditorView.baseTheme({
    "&light": {
      "--indent-marker-bg-color": colors.light,
      "--indent-marker-active-bg-color": colors.activeLight
    },
    "&dark": {
      "--indent-marker-bg-color": colors.dark,
      "--indent-marker-active-bg-color": colors.activeDark
    },
    ".cm-line": {
      position: "relative"
    },
    // this pseudo-element is used to draw the indent markers,
    // while still allowing the line to have its own background.
    ".cm-indent-markers::before": {
      content: '""',
      position: "absolute",
      top: 0,
      // .cm-line has a padding of 2px 
      // https://github.com/codemirror/view/blob/1c0a0880fc904714339f059658f3ba3a88bb8e6e/src/theme.ts#L85
      left: `2px`,
      right: 0,
      bottom: 0,
      background: "var(--indent-markers)",
      pointerEvents: "none",
      zIndex: "-1"
    }
  });
}
function createGradient(markerCssProperty, thickness, indentWidth, startOffset, columns) {
  const gradient = `repeating-linear-gradient(to right, var(${markerCssProperty}) 0 ${thickness}px, transparent ${thickness}px ${indentWidth}ch)`;
  return `${gradient} ${startOffset * indentWidth}.5ch/calc(${indentWidth * columns}ch - 1px) no-repeat`;
}
function makeBackgroundCSS(entry, indentWidth, hideFirstIndent, thickness, activeThickness) {
  const {
    level,
    active
  } = entry;
  activeThickness = activeThickness !== null && activeThickness !== void 0 ? activeThickness : thickness;
  if (hideFirstIndent && level === 0) {
    return [];
  }
  const startAt = hideFirstIndent ? 1 : 0;
  const backgrounds = [];
  if (active !== void 0) {
    const markersBeforeActive = active - startAt - 1;
    if (markersBeforeActive > 0) {
      backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, markersBeforeActive));
    }
    backgrounds.push(createGradient("--indent-marker-active-bg-color", activeThickness, indentWidth, active - 1, 1));
    if (active !== level) {
      backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, active, level - active));
    }
  } else {
    backgrounds.push(createGradient("--indent-marker-bg-color", thickness, indentWidth, startAt, level - startAt));
  }
  return backgrounds.join(",");
}
var IndentMarkersClass = class {
  constructor(view) {
    this.view = view;
    this.unitWidth = getIndentUnit(view.state);
    this.currentLineNumber = getCurrentLine(view.state).number;
    this.generate(view.state);
  }
  update(update2) {
    const unitWidth = getIndentUnit(update2.state);
    const unitWidthChanged = unitWidth !== this.unitWidth;
    if (unitWidthChanged) {
      this.unitWidth = unitWidth;
    }
    const lineNumber = getCurrentLine(update2.state).number;
    const lineNumberChanged = lineNumber !== this.currentLineNumber;
    this.currentLineNumber = lineNumber;
    const activeBlockUpdateRequired = update2.state.facet(indentationMarkerConfig).highlightActiveBlock && lineNumberChanged;
    if (update2.docChanged || update2.viewportChanged || unitWidthChanged || activeBlockUpdateRequired) {
      this.generate(update2.state);
    }
  }
  generate(state) {
    const builder = new RangeSetBuilder();
    const lines = getVisibleLines(this.view, state);
    const {
      hideFirstIndent,
      markerType,
      thickness,
      activeThickness
    } = state.facet(indentationMarkerConfig);
    const map2 = new IndentationMap(lines, state, this.unitWidth, markerType);
    for (const line of lines) {
      const entry = map2.get(line.number);
      if (!(entry === null || entry === void 0 ? void 0 : entry.level)) {
        continue;
      }
      const backgrounds = makeBackgroundCSS(entry, this.unitWidth, hideFirstIndent, thickness, activeThickness);
      builder.add(line.from, line.from, Decoration.line({
        class: "cm-indent-markers",
        attributes: {
          style: `--indent-markers: ${backgrounds}`
        }
      }));
    }
    this.decorations = builder.finish();
  }
};
function indentationMarkers(config2 = {}) {
  return [indentationMarkerConfig.of(config2), indentTheme(config2.colors), ViewPlugin.fromClass(IndentMarkersClass, {
    decorations: (v) => v.decorations
  })];
}

// node_modules/vanilla-jsoneditor/index.js
var e = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"];
var n = ["mainAxis", "crossAxis", "limiter"];
function t2(e2, n2) {
  if (null == e2) return {};
  var t3, o2, r2 = function(e3, n3) {
    if (null == e3) return {};
    var t4 = {};
    for (var o3 in e3) if ({}.hasOwnProperty.call(e3, o3)) {
      if (-1 !== n3.indexOf(o3)) continue;
      t4[o3] = e3[o3];
    }
    return t4;
  }(e2, n2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e2);
    for (o2 = 0; o2 < a2.length; o2++) t3 = a2[o2], -1 === n2.indexOf(t3) && {}.propertyIsEnumerable.call(e2, t3) && (r2[t3] = e2[t3]);
  }
  return r2;
}
function o(e2, n2) {
  var t3 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    n2 && (o2 = o2.filter(function(n3) {
      return Object.getOwnPropertyDescriptor(e2, n3).enumerable;
    })), t3.push.apply(t3, o2);
  }
  return t3;
}
function r(e2) {
  for (var n2 = 1; n2 < arguments.length; n2++) {
    var t3 = null != arguments[n2] ? arguments[n2] : {};
    n2 % 2 ? o(Object(t3), true).forEach(function(n3) {
      s(e2, n3, t3[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : o(Object(t3)).forEach(function(n3) {
      Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t3, n3));
    });
  }
  return e2;
}
function a(e2, n2, t3, o2, r2, a2, i2) {
  try {
    var s2 = e2[a2](i2), l = s2.value;
  } catch (e3) {
    return void t3(e3);
  }
  s2.done ? n2(l) : Promise.resolve(l).then(o2, r2);
}
function i(e2) {
  return function() {
    var n2 = this, t3 = arguments;
    return new Promise(function(o2, r2) {
      var i2 = e2.apply(n2, t3);
      function s2(e3) {
        a(i2, o2, r2, s2, l, "next", e3);
      }
      function l(e3) {
        a(i2, o2, r2, s2, l, "throw", e3);
      }
      s2(void 0);
    });
  };
}
function s(e2, n2, t3) {
  return (n2 = function(e3) {
    var n3 = function(e4, n4) {
      if ("object" != typeof e4 || !e4) return e4;
      var t4 = e4[Symbol.toPrimitive];
      if (void 0 !== t4) {
        var o2 = t4.call(e4, n4 || "default");
        if ("object" != typeof o2) return o2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === n4 ? String : Number)(e4);
    }(e3, "string");
    return "symbol" == typeof n3 ? n3 : n3 + "";
  }(n2)) in e2 ? Object.defineProperty(e2, n2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[n2] = t3, e2;
}
var Fn;
var Ln;
var Wn;
var Vn;
"undefined" != typeof window && (null !== (Ln = (Fn = null !== (Vn = (Wn = window).__svelte) && void 0 !== Vn ? Vn : Wn.__svelte = {}).v) && void 0 !== Ln ? Ln : Fn.v = /* @__PURE__ */ new Set()).add("5");
var $n = false;
$n = true;
var Hn = Symbol();
var Qn = Array.isArray;
var Yn = Array.prototype.indexOf;
var Kn = Array.from;
var Zn = Object.defineProperty;
var Xn = Object.getOwnPropertyDescriptor;
var Gn = Object.getOwnPropertyDescriptors;
var et2 = Object.prototype;
var nt2 = Array.prototype;
var tt2 = Object.getPrototypeOf;
var ot2 = Object.isExtensible;
function rt2(e2) {
  return "function" == typeof e2;
}
var at3 = () => {
};
function it2(e2) {
  return e2();
}
function st2(e2) {
  for (var n2 = 0; n2 < e2.length; n2++) e2[n2]();
}
var lt3 = 32;
var ct2 = 64;
var dt2 = 256;
var ut2 = 512;
var vt = 1024;
var ft2 = 2048;
var pt2 = 4096;
var ht2 = 8192;
var gt3 = 16384;
var mt2 = 65536;
var bt = 1 << 17;
var jt = 1 << 19;
var xt = 1 << 20;
var yt = 1 << 21;
var wt = Symbol("$state");
var kt = Symbol("legacy props");
var St = Symbol("");
var Ct = new class extends Error {
  constructor() {
    super(...arguments), s(this, "name", "StaleReactionError"), s(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
function zt(e2) {
  return e2 === this.v;
}
function Ot(e2, n2) {
  return e2 != e2 ? n2 == n2 : e2 !== n2 || null !== e2 && "object" == typeof e2 || "function" == typeof e2;
}
function Mt(e2, n2) {
  return e2 !== n2;
}
function Et(e2) {
  return !Ot(e2, this.v);
}
function At(e2) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
var Rt = null;
function qt(e2) {
  Rt = e2;
}
function Pt(e2) {
  return Ut().get(e2);
}
function Tt(e2) {
  Rt = {
    p: Rt,
    c: null,
    e: null,
    s: e2,
    x: null,
    l: null
  }, $n && !(arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) && (Rt.l = {
    s: null,
    u: null,
    r1: [],
    r2: Qt(false)
  });
}
function Nt(e2) {
  var n2 = Rt, t3 = n2.e;
  if (null !== t3) for (var o2 of (n2.e = null, t3)) bo(o2);
  return void 0 !== e2 && (n2.x = e2), Rt = n2.p, null != e2 ? e2 : {};
}
function It() {
  return !$n || null !== Rt && null === Rt.l;
}
function Ut(e2) {
  var n2, t3;
  return null === Rt && At(), null !== (t3 = (n2 = Rt).c) && void 0 !== t3 ? t3 : n2.c = new Map(function(e3) {
    var n3 = e3.p;
    for (; null !== n3; ) {
      var t4 = n3.c;
      if (null !== t4) return t4;
      n3 = n3.p;
    }
    return null;
  }(Rt) || void 0);
}
function Dt(e2) {
  if ("object" != typeof e2 || null === e2 || wt in e2) return e2;
  var n2 = tt2(e2);
  if (n2 !== et2 && n2 !== nt2) return e2;
  var t3 = /* @__PURE__ */ new Map(), o2 = Qn(e2), r2 = Yt(0), a2 = ir, i2 = (e3) => {
    if (ir === a2) return e3();
    var n3 = Qo, t4 = ir;
    Ko(null), sr(a2);
    var o3 = e3();
    return Ko(n3), sr(t4), o3;
  };
  return o2 && t3.set("length", Yt(e2.length)), new Proxy(e2, {
    defineProperty(e3, n3, o3) {
      "value" in o3 && false !== o3.configurable && false !== o3.enumerable && false !== o3.writable || function() {
        throw new Error("https://svelte.dev/e/state_descriptors_fixed");
      }();
      var r3 = t3.get(n3);
      return void 0 === r3 ? r3 = i2(() => {
        var e4 = Yt(o3.value);
        return t3.set(n3, e4), e4;
      }) : Xt(r3, o3.value, true), true;
    },
    deleteProperty(e3, n3) {
      var a3 = t3.get(n3);
      if (void 0 === a3) {
        if (n3 in e3) {
          var s2 = i2(() => Yt(Hn));
          t3.set(n3, s2), no(r2);
        }
      } else {
        if (o2 && "string" == typeof n3) {
          var l = t3.get("length"), c = Number(n3);
          Number.isInteger(c) && c < l.v && Xt(l, c);
        }
        Xt(a3, Hn), no(r2);
      }
      return true;
    },
    get(n3, o3, r3) {
      var a3;
      if (o3 === wt) return e2;
      var s2 = t3.get(o3), l = o3 in n3;
      if (void 0 === s2 && (!l || null !== (a3 = Xn(n3, o3)) && void 0 !== a3 && a3.writable) && (s2 = i2(() => Yt(Dt(l ? n3[o3] : Hn))), t3.set(o3, s2)), void 0 !== s2) {
        var c = Sr(s2);
        return c === Hn ? void 0 : c;
      }
      return Reflect.get(n3, o3, r3);
    },
    getOwnPropertyDescriptor(e3, n3) {
      var o3 = Reflect.getOwnPropertyDescriptor(e3, n3);
      if (o3 && "value" in o3) {
        var r3 = t3.get(n3);
        r3 && (o3.value = Sr(r3));
      } else if (void 0 === o3) {
        var a3 = t3.get(n3), i3 = null == a3 ? void 0 : a3.v;
        if (void 0 !== a3 && i3 !== Hn) return {
          enumerable: true,
          configurable: true,
          value: i3,
          writable: true
        };
      }
      return o3;
    },
    has(e3, n3) {
      var o3;
      if (n3 === wt) return true;
      var r3 = t3.get(n3), a3 = void 0 !== r3 && r3.v !== Hn || Reflect.has(e3, n3);
      if ((void 0 !== r3 || null !== Zo && (!a3 || null !== (o3 = Xn(e3, n3)) && void 0 !== o3 && o3.writable)) && (void 0 === r3 && (r3 = i2(() => Yt(a3 ? Dt(e3[n3]) : Hn)), t3.set(n3, r3)), Sr(r3) === Hn)) return false;
      return a3;
    },
    set(e3, n3, a3, s2) {
      var l, c = t3.get(n3), d = n3 in e3;
      if (o2 && "length" === n3) for (var u = a3; u < c.v; u += 1) {
        var v = t3.get(u + "");
        void 0 !== v ? Xt(v, Hn) : u in e3 && (v = i2(() => Yt(Hn)), t3.set(u + "", v));
      }
      void 0 === c ? (!d || null !== (l = Xn(e3, n3)) && void 0 !== l && l.writable) && (Xt(c = i2(() => Yt(void 0)), Dt(a3)), t3.set(n3, c)) : (d = c.v !== Hn, Xt(c, i2(() => Dt(a3))));
      var f = Reflect.getOwnPropertyDescriptor(e3, n3);
      if (null != f && f.set && f.set.call(s2, a3), !d) {
        if (o2 && "string" == typeof n3) {
          var p2 = t3.get("length"), h2 = Number(n3);
          Number.isInteger(h2) && h2 >= p2.v && Xt(p2, h2 + 1);
        }
        no(r2);
      }
      return true;
    },
    ownKeys(e3) {
      Sr(r2);
      var n3 = Reflect.ownKeys(e3).filter((e4) => {
        var n4 = t3.get(e4);
        return void 0 === n4 || n4.v !== Hn;
      });
      for (var [o3, a3] of t3) a3.v === Hn || o3 in e3 || n3.push(o3);
      return n3;
    },
    setPrototypeOf() {
      !function() {
        throw new Error("https://svelte.dev/e/state_prototype_fixed");
      }();
    }
  });
}
function Jt(e2) {
  try {
    if (null !== e2 && "object" == typeof e2 && wt in e2) return e2[wt];
  } catch (e3) {
  }
  return e2;
}
function Bt(e2, n2) {
  return Object.is(Jt(e2), Jt(n2));
}
function _t(e2) {
  var n2 = 2050, t3 = null !== Qo && 2 & Qo.f ? Qo : null;
  return null === Zo || null !== t3 && 0 !== (t3.f & dt2) ? n2 |= dt2 : Zo.f |= jt, {
    ctx: Rt,
    deps: null,
    effects: null,
    equals: zt,
    f: n2,
    fn: e2,
    reactions: null,
    rv: 0,
    v: Hn,
    wv: 0,
    parent: null != t3 ? t3 : Zo,
    ac: null
  };
}
function Ft(e2) {
  var n2 = _t(e2);
  return er(n2), n2;
}
function Lt(e2) {
  var n2 = _t(e2);
  return n2.equals = Et, n2;
}
function Wt(e2) {
  var n2 = e2.effects;
  if (null !== n2) {
    e2.effects = null;
    for (var t3 = 0; t3 < n2.length; t3 += 1) Mo(n2[t3]);
  }
}
function Vt(e2) {
  var n2, t3 = Zo;
  Xo(function(e3) {
    for (var n3 = e3.parent; null !== n3; ) {
      if (!(2 & n3.f)) return n3;
      n3 = n3.parent;
    }
    return null;
  }(e2));
  try {
    Wt(e2), n2 = fr(e2);
  } finally {
    Xo(t3);
  }
  return n2;
}
function $t(e2) {
  var n2 = Vt(e2);
  (e2.equals(n2) || (e2.v = n2, e2.wv = dr()), Vo) || Er(e2, !lr && 0 === (e2.f & dt2) || null === e2.deps ? vt : pt2);
}
var Ht = /* @__PURE__ */ new Map();
function Qt(e2, n2) {
  return {
    f: 0,
    v: e2,
    reactions: null,
    equals: zt,
    rv: 0,
    wv: 0
  };
}
function Yt(e2, n2) {
  var t3 = Qt(e2);
  return er(t3), t3;
}
function Kt(e2) {
  var n2, t3, o2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = Qt(e2);
  (o2 || (a2.equals = Et), $n && r2 && null !== Rt && null !== Rt.l) && (null !== (t3 = (n2 = Rt.l).s) && void 0 !== t3 ? t3 : n2.s = []).push(a2);
  return a2;
}
function Zt(e2, n2) {
  return Xt(e2, Or(() => Sr(e2))), n2;
}
function Xt(e2, n2) {
  var t3, o2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  return null === Qo || Yo && 0 === (Qo.f & bt) || !It() || !(131090 & Qo.f) || null !== (t3 = Go) && void 0 !== t3 && t3.includes(e2) || function() {
    throw new Error("https://svelte.dev/e/state_unsafe_mutation");
  }(), Gt(e2, o2 ? Dt(n2) : n2);
}
function Gt(e2, n2) {
  if (!e2.equals(n2)) {
    var t3 = e2.v;
    Vo ? Ht.set(e2, n2) : Ht.set(e2, t3), e2.v = n2, 2 & e2.f && (0 !== (e2.f & ft2) && Vt(e2), Er(e2, 0 === (e2.f & dt2) ? vt : pt2)), e2.wv = dr(), to(e2, ft2), !It() || null === Zo || 0 === (Zo.f & vt) || 96 & Zo.f || (null === or ? function(e3) {
      or = e3;
    }([e2]) : or.push(e2));
  }
  return n2;
}
function eo(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, t3 = Sr(e2), o2 = 1 === n2 ? t3++ : t3--;
  return Xt(e2, t3), o2;
}
function no(e2) {
  Xt(e2, e2.v + 1);
}
function to(e2, n2) {
  var t3 = e2.reactions;
  if (null !== t3) for (var o2 = It(), r2 = t3.length, a2 = 0; a2 < r2; a2++) {
    var i2 = t3[a2], s2 = i2.f;
    0 === (s2 & ft2) && (o2 || i2 !== Zo) && (Er(i2, n2), 1280 & s2 && (2 & s2 ? to(i2, pt2) : xr(i2)));
  }
}
var oo;
var ro;
var ao;
var io;
function so() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
  return document.createTextNode(e2);
}
function lo(e2) {
  return ao.call(e2);
}
function co(e2) {
  return io.call(e2);
}
function uo(e2, n2) {
  return lo(e2);
}
function vo(e2, n2) {
  var t3 = lo(e2);
  return t3 instanceof Comment && "" === t3.data ? co(t3) : t3;
}
function fo(e2) {
  for (var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, t3 = e2; n2--; ) t3 = co(t3);
  return t3;
}
function po(e2) {
  null === Zo && null === Qo && function() {
    throw new Error("https://svelte.dev/e/effect_orphan");
  }(), null !== Qo && 0 !== (Qo.f & dt2) && null === Zo && function() {
    throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
  }(), Vo && function() {
    throw new Error("https://svelte.dev/e/effect_in_teardown");
  }();
}
function ho(e2, n2, t3) {
  var o2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = Zo, a2 = {
    ctx: Rt,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: e2 | ft2,
    first: null,
    fn: n2,
    last: null,
    next: null,
    parent: r2,
    b: r2 && r2.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (t3) try {
    gr(a2), a2.f |= 32768;
  } catch (e3) {
    throw Mo(a2), e3;
  }
  else null !== n2 && xr(a2);
  if (!(t3 && null === a2.deps && null === a2.first && null === a2.nodes_start && null === a2.teardown && !(524416 & a2.f)) && o2 && (null !== r2 && function(e3, n3) {
    var t4 = n3.last;
    null === t4 ? n3.last = n3.first = e3 : (t4.next = e3, e3.prev = t4, n3.last = e3);
  }(a2, r2), null !== Qo && 2 & Qo.f)) {
    var i2, s2 = Qo;
    (null !== (i2 = s2.effects) && void 0 !== i2 ? i2 : s2.effects = []).push(a2);
  }
  return a2;
}
function go(e2) {
  var n2 = ho(8, null, false);
  return Er(n2, vt), n2.teardown = e2, n2;
}
function mo(e2) {
  if (po(), Qo || !Zo || 0 === (Zo.f & lt3)) return bo(e2);
  var n2, t3 = Rt;
  (null !== (n2 = t3.e) && void 0 !== n2 ? n2 : t3.e = []).push(e2);
}
function bo(e2) {
  return ho(2097156, e2, false);
}
function jo(e2) {
  return ho(4, e2, false);
}
function xo(e2, n2) {
  var t3 = Rt, o2 = {
    effect: null,
    ran: false
  };
  t3.l.r1.push(o2), o2.effect = wo(() => {
    e2(), o2.ran || (o2.ran = true, Xt(t3.l.r2, true), Or(n2));
  });
}
function yo() {
  var e2 = Rt;
  wo(() => {
    if (Sr(e2.l.r2)) {
      for (var n2 of e2.l.r1) {
        var t3 = n2.effect;
        0 !== (t3.f & vt) && Er(t3, pt2), ur(t3) && gr(t3), n2.ran = false;
      }
      e2.l.r2.v = false;
    }
  });
}
function wo(e2) {
  return ho(8, e2, true);
}
function ko(e2) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : _t, t3 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).map(n2);
  return So(() => e2(...t3.map(Sr)));
}
function So(e2) {
  return ho(24 | (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0), e2, true);
}
function Co(e2) {
  return ho(40, e2, true, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]);
}
function zo(e2) {
  var n2 = e2.teardown;
  if (null !== n2) {
    var t3 = Vo, o2 = Qo;
    $o(true), Ko(null);
    try {
      n2.call(null);
    } finally {
      $o(t3), Ko(o2);
    }
  }
}
function Oo(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], t3 = e2.first;
  for (e2.first = e2.last = null; null !== t3; ) {
    var o2;
    null === (o2 = t3.ac) || void 0 === o2 || o2.abort(Ct);
    var r2 = t3.next;
    0 !== (t3.f & ct2) ? t3.parent = null : Mo(t3, n2), t3 = r2;
  }
}
function Mo(e2) {
  var n2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], t3 = false;
  (n2 || 262144 & e2.f) && null !== e2.nodes_start && null !== e2.nodes_end && (Eo(e2.nodes_start, e2.nodes_end), t3 = true), Oo(e2, n2 && !t3), hr(e2, 0), Er(e2, gt3);
  var o2 = e2.transitions;
  if (null !== o2) for (var r2 of o2) r2.stop();
  zo(e2);
  var a2 = e2.parent;
  null !== a2 && null !== a2.first && Ao(e2), e2.next = e2.prev = e2.teardown = e2.ctx = e2.deps = e2.fn = e2.nodes_start = e2.nodes_end = e2.ac = null;
}
function Eo(e2, n2) {
  for (; null !== e2; ) {
    var t3 = e2 === n2 ? null : co(e2);
    e2.remove(), e2 = t3;
  }
}
function Ao(e2) {
  var n2 = e2.parent, t3 = e2.prev, o2 = e2.next;
  null !== t3 && (t3.next = o2), null !== o2 && (o2.prev = t3), null !== n2 && (n2.first === e2 && (n2.first = o2), n2.last === e2 && (n2.last = t3));
}
function Ro(e2, n2) {
  var t3 = [];
  Po(e2, t3, true), qo(t3, () => {
    Mo(e2), n2 && n2();
  });
}
function qo(e2, n2) {
  var t3 = e2.length;
  if (t3 > 0) {
    var o2 = () => --t3 || n2();
    for (var r2 of e2) r2.out(o2);
  } else n2();
}
function Po(e2, n2, t3) {
  if (0 === (e2.f & ht2)) {
    if (e2.f ^= ht2, null !== e2.transitions) for (var o2 of e2.transitions) (o2.is_global || t3) && n2.push(o2);
    for (var r2 = e2.first; null !== r2; ) {
      var a2 = r2.next;
      Po(r2, n2, !!(0 !== (r2.f & mt2) || 0 !== (r2.f & lt3)) && t3), r2 = a2;
    }
  }
}
function To(e2) {
  No(e2, true);
}
function No(e2, n2) {
  if (0 !== (e2.f & ht2)) {
    e2.f ^= ht2;
    for (var t3 = e2.first; null !== t3; ) {
      var o2 = t3.next;
      No(t3, !!(0 !== (t3.f & mt2) || 0 !== (t3.f & lt3)) && n2), t3 = o2;
    }
    if (null !== e2.transitions) for (var r2 of e2.transitions) (r2.is_global || n2) && r2.in();
  }
}
var Io = [];
var Uo = [];
function Do() {
  var e2 = Io;
  Io = [], st2(e2);
}
function Jo(e2) {
  0 === Io.length && queueMicrotask(Do), Io.push(e2);
}
function Bo() {
  var e2;
  Io.length > 0 && Do(), Uo.length > 0 && (e2 = Uo, Uo = [], st2(e2));
}
function _o(e2, n2) {
  for (; null !== n2; ) {
    if (128 & n2.f) try {
      return void n2.b.error(e2);
    } catch (e3) {
    }
    n2 = n2.parent;
  }
  throw e2;
}
var Fo = false;
var Lo = null;
var Wo = false;
var Vo = false;
function $o(e2) {
  Vo = e2;
}
var Ho = [];
var Qo = null;
var Yo = false;
function Ko(e2) {
  Qo = e2;
}
var Zo = null;
function Xo(e2) {
  Zo = e2;
}
var Go = null;
function er(e2) {
  null !== Qo && Qo.f & xt && (null === Go ? Go = [e2] : Go.push(e2));
}
var nr = null;
var tr = 0;
var or = null;
var rr = 1;
var ar = 0;
var ir = ar;
function sr(e2) {
  ir = e2;
}
var lr = false;
var cr = null;
function dr() {
  return ++rr;
}
function ur(e2) {
  var n2 = e2.f;
  if (0 !== (n2 & ft2)) return true;
  if (0 !== (n2 & pt2)) {
    var t3 = e2.deps, o2 = 0 !== (n2 & dt2);
    if (null !== t3) {
      var r2, a2, i2 = 0 !== (n2 & ut2), s2 = o2 && null !== Zo && !lr, l = t3.length;
      if (i2 || s2) {
        var c = e2, d = c.parent;
        for (r2 = 0; r2 < l; r2++) {
          var u, v, f;
          if (a2 = t3[r2], i2 || null === (u = a2) || void 0 === u || null === (u = u.reactions) || void 0 === u || !u.includes(c)) (null !== (f = (v = a2).reactions) && void 0 !== f ? f : v.reactions = []).push(c);
        }
        i2 && (c.f ^= ut2), s2 && null !== d && 0 === (d.f & dt2) && (c.f ^= dt2);
      }
      for (r2 = 0; r2 < l; r2++) if (ur(a2 = t3[r2]) && $t(a2), a2.wv > e2.wv) return true;
    }
    o2 && (null === Zo || lr) || Er(e2, vt);
  }
  return false;
}
function vr(e2, n2) {
  var t3, o2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = e2.reactions;
  if (null !== r2 && (null === (t3 = Go) || void 0 === t3 || !t3.includes(e2))) for (var a2 = 0; a2 < r2.length; a2++) {
    var i2 = r2[a2];
    2 & i2.f ? vr(i2, n2, false) : n2 === i2 && (o2 ? Er(i2, ft2) : 0 !== (i2.f & vt) && Er(i2, pt2), xr(i2));
  }
}
function fr(e2) {
  var n2 = nr, t3 = tr, o2 = or, r2 = Qo, a2 = lr, i2 = Go, s2 = Rt, l = Yo, c = ir, d = e2.f;
  nr = null, tr = 0, or = null, lr = 0 !== (d & dt2) && (Yo || !Wo || null === Qo), Qo = 96 & d ? null : e2, Go = null, qt(e2.ctx), Yo = false, ir = ++ar, e2.f |= xt, null !== e2.ac && (e2.ac.abort(Ct), e2.ac = null);
  try {
    var u = (0, e2.fn)(), v = e2.deps;
    if (null !== nr) {
      var f;
      if (hr(e2, tr), null !== v && tr > 0) for (v.length = tr + nr.length, f = 0; f < nr.length; f++) v[tr + f] = nr[f];
      else e2.deps = v = nr;
      if (!lr || 2 & d && null !== e2.reactions) for (f = tr; f < v.length; f++) {
        var p2, h2;
        (null !== (h2 = (p2 = v[f]).reactions) && void 0 !== h2 ? h2 : p2.reactions = []).push(e2);
      }
    } else null !== v && tr < v.length && (hr(e2, tr), v.length = tr);
    if (It() && null !== or && !Yo && null !== v && !(6146 & e2.f)) for (f = 0; f < or.length; f++) vr(or[f], e2);
    return null !== r2 && r2 !== e2 && (ar++, null !== or && (null === o2 ? o2 = or : o2.push(...or))), u;
  } catch (e3) {
    !function(e4) {
      var n3 = Zo;
      if (32768 & n3.f) _o(e4, n3);
      else {
        if (!(128 & n3.f)) throw e4;
        n3.fn(e4);
      }
    }(e3);
  } finally {
    nr = n2, tr = t3, or = o2, Qo = r2, lr = a2, Go = i2, qt(s2), Yo = l, ir = c, e2.f ^= xt;
  }
}
function pr(e2, n2) {
  var t3 = n2.reactions;
  if (null !== t3) {
    var o2 = Yn.call(t3, e2);
    if (-1 !== o2) {
      var r2 = t3.length - 1;
      0 === r2 ? t3 = n2.reactions = null : (t3[o2] = t3[r2], t3.pop());
    }
  }
  null === t3 && 2 & n2.f && (null === nr || !nr.includes(n2)) && (Er(n2, pt2), 768 & n2.f || (n2.f ^= ut2), Wt(n2), hr(n2, 0));
}
function hr(e2, n2) {
  var t3 = e2.deps;
  if (null !== t3) for (var o2 = n2; o2 < t3.length; o2++) pr(e2, t3[o2]);
}
function gr(e2) {
  var n2 = e2.f;
  if (0 === (n2 & gt3)) {
    Er(e2, vt);
    var t3 = Zo, o2 = Wo;
    Zo = e2, Wo = true;
    try {
      16 & n2 ? function(e3) {
        for (var n3 = e3.first; null !== n3; ) {
          var t4 = n3.next;
          0 === (n3.f & lt3) && Mo(n3), n3 = t4;
        }
      }(e2) : Oo(e2), zo(e2);
      var r2 = fr(e2);
      e2.teardown = "function" == typeof r2 ? r2 : null, e2.wv = rr;
    } finally {
      Wo = o2, Zo = t3;
    }
  }
}
function mr() {
  try {
    !function() {
      throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
    }();
  } catch (e2) {
    if (null === Lo) throw e2;
    _o(e2, Lo);
  }
}
function br() {
  var e2 = Wo;
  try {
    var n2 = 0;
    for (Wo = true; Ho.length > 0; ) {
      n2++ > 1e3 && mr();
      var t3 = Ho, o2 = t3.length;
      Ho = [];
      for (var r2 = 0; r2 < o2; r2++) {
        jr(yr(t3[r2]));
      }
      Ht.clear();
    }
  } finally {
    Fo = false, Wo = e2, Lo = null;
  }
}
function jr(e2) {
  var n2 = e2.length;
  if (0 !== n2) {
    for (var t3 = 0; t3 < n2; t3++) {
      var o2 = e2[t3];
      if (!(24576 & o2.f) && ur(o2)) {
        var r2 = rr;
        if (gr(o2), null === o2.deps && null === o2.first && null === o2.nodes_start && (null === o2.teardown ? Ao(o2) : o2.fn = null), rr > r2 && 0 !== (o2.f & yt)) break;
      }
    }
    for (; t3 < n2; t3 += 1) xr(e2[t3]);
  }
}
function xr(e2) {
  Fo || (Fo = true, queueMicrotask(br));
  for (var n2 = Lo = e2; null !== n2.parent; ) {
    var t3 = (n2 = n2.parent).f;
    if (96 & t3) {
      if (0 === (t3 & vt)) return;
      n2.f ^= vt;
    }
  }
  Ho.push(n2);
}
function yr(e2) {
  for (var n2 = [], t3 = e2; null !== t3; ) {
    var o2 = t3.f, r2 = !!(96 & o2);
    if (!(r2 && 0 !== (o2 & vt)) && 0 === (o2 & ht2)) {
      4 & o2 ? n2.push(t3) : r2 ? t3.f ^= vt : ur(t3) && gr(t3);
      var a2 = t3.first;
      if (null !== a2) {
        t3 = a2;
        continue;
      }
    }
    var i2 = t3.parent;
    for (t3 = t3.next; null === t3 && null !== i2; ) t3 = i2.next, i2 = i2.parent;
  }
  return n2;
}
function wr(e2) {
  for (; ; ) {
    if (Bo(), 0 === Ho.length) return Fo = false, void (Lo = null);
    Fo = true, br();
  }
}
function kr() {
  return (kr = i(function* () {
    yield Promise.resolve(), wr();
  })).apply(this, arguments);
}
function Sr(e2) {
  var n2, t3 = !!(2 & e2.f);
  if (null !== cr && cr.add(e2), null === Qo || Yo) {
    if (t3 && null === e2.deps && null === e2.effects) {
      var o2 = e2, r2 = o2.parent;
      null !== r2 && 0 === (r2.f & dt2) && (o2.f ^= dt2);
    }
  } else if (null === (n2 = Go) || void 0 === n2 || !n2.includes(e2)) {
    var a2 = Qo.deps;
    e2.rv < ar && (e2.rv = ar, null === nr && null !== a2 && a2[tr] === e2 ? tr++ : null === nr ? nr = [e2] : lr && nr.includes(e2) || nr.push(e2));
  }
  if (t3 && !Vo && ur(o2 = e2) && $t(o2), Vo) {
    if (Ht.has(e2)) return Ht.get(e2);
    if (t3) {
      var i2 = (o2 = e2).v;
      return (0 !== (o2.f & vt) || Cr(o2)) && (i2 = Vt(o2)), Ht.set(o2, i2), i2;
    }
  }
  return e2.v;
}
function Cr(e2) {
  if (e2.v === Hn) return true;
  if (null === e2.deps) return false;
  for (var n2 of e2.deps) {
    if (Ht.has(n2)) return true;
    if (2 & n2.f && Cr(n2)) return true;
  }
  return false;
}
function zr(e2) {
  var n2 = function(e3) {
    var n3, t4 = cr, o2 = cr = /* @__PURE__ */ new Set();
    try {
      if (Or(e3), null !== t4) for (n3 of cr) t4.add(n3);
    } finally {
      cr = t4;
    }
    return o2;
  }(() => Or(e2));
  for (var t3 of n2) Gt(t3, t3.v);
}
function Or(e2) {
  var n2 = Yo;
  try {
    return Yo = true, e2();
  } finally {
    Yo = n2;
  }
}
var Mr = -7169;
function Er(e2, n2) {
  e2.f = e2.f & Mr | n2;
}
function Ar(e2) {
  if ("object" == typeof e2 && e2 && !(e2 instanceof EventTarget)) {
    if (wt in e2) Rr(e2);
    else if (!Array.isArray(e2)) for (var n2 in e2) {
      var t3 = e2[n2];
      "object" == typeof t3 && t3 && wt in t3 && Rr(t3);
    }
  }
}
function Rr(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Set();
  if (!("object" != typeof e2 || null === e2 || e2 instanceof EventTarget || n2.has(e2))) {
    for (var t3 in n2.add(e2), e2 instanceof Date && e2.getTime(), e2) try {
      Rr(e2[t3], n2);
    } catch (e3) {
    }
    var o2 = tt2(e2);
    if (o2 !== Object.prototype && o2 !== Array.prototype && o2 !== Map.prototype && o2 !== Set.prototype && o2 !== Date.prototype) {
      var r2 = Gn(o2);
      for (var a2 in r2) {
        var i2 = r2[a2].get;
        if (i2) try {
          i2.call(e2);
        } catch (e3) {
        }
      }
    }
  }
}
var qr = false;
function Pr(e2) {
  var n2 = Qo, t3 = Zo;
  Ko(null), Xo(null);
  try {
    return e2();
  } finally {
    Ko(n2), Xo(t3);
  }
}
function Tr(e2, n2, t3) {
  var o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t3;
  e2.addEventListener(n2, () => Pr(t3));
  var r2 = e2.__on_r;
  e2.__on_r = r2 ? () => {
    r2(), o2(true);
  } : () => o2(true), qr || (qr = true, document.addEventListener("reset", (e3) => {
    Promise.resolve().then(() => {
      if (!e3.defaultPrevented) for (var n3 of e3.target.elements) {
        var t4;
        null === (t4 = n3.__on_r) || void 0 === t4 || t4.call(n3);
      }
    });
  }, {
    capture: true
  }));
}
var Nr = /* @__PURE__ */ new Set();
var Ir = /* @__PURE__ */ new Set();
function Ur(e2, n2, t3) {
  var o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
  function r2(e3) {
    if (o2.capture || Br.call(n2, e3), !e3.cancelBubble) return Pr(() => null == t3 ? void 0 : t3.call(this, e3));
  }
  return e2.startsWith("pointer") || e2.startsWith("touch") || "wheel" === e2 ? Jo(() => {
    n2.addEventListener(e2, r2, o2);
  }) : n2.addEventListener(e2, r2, o2), r2;
}
function Dr(e2, n2, t3, o2, r2) {
  var a2 = {
    capture: o2,
    passive: r2
  }, i2 = Ur(e2, n2, t3, a2);
  (n2 === document.body || n2 === window || n2 === document || n2 instanceof HTMLMediaElement) && go(() => {
    n2.removeEventListener(e2, i2, a2);
  });
}
function Jr(e2) {
  for (var n2 = 0; n2 < e2.length; n2++) Nr.add(e2[n2]);
  for (var t3 of Ir) t3(e2);
}
function Br(e2) {
  var n2, t3 = this, o2 = t3.ownerDocument, r2 = e2.type, a2 = (null === (n2 = e2.composedPath) || void 0 === n2 ? void 0 : n2.call(e2)) || [], i2 = a2[0] || e2.target, s2 = 0, l = e2.__root;
  if (l) {
    var c = a2.indexOf(l);
    if (-1 !== c && (t3 === document || t3 === window)) return void (e2.__root = t3);
    var d = a2.indexOf(t3);
    if (-1 === d) return;
    c <= d && (s2 = c);
  }
  if ((i2 = a2[s2] || e2.target) !== t3) {
    Zn(e2, "currentTarget", {
      configurable: true,
      get: () => i2 || o2
    });
    var u = Qo, v = Zo;
    Ko(null), Xo(null);
    try {
      for (var f, p2 = []; null !== i2; ) {
        var h2 = i2.assignedSlot || i2.parentNode || i2.host || null;
        try {
          var g = i2["__" + r2];
          if (null != g && (!i2.disabled || e2.target === i2)) if (Qn(g)) {
            var [m, ...b] = g;
            m.apply(i2, [e2, ...b]);
          } else g.call(i2, e2);
        } catch (x2) {
          f ? p2.push(x2) : f = x2;
        }
        if (e2.cancelBubble || h2 === t3 || null === h2) break;
        i2 = h2;
      }
      if (f) {
        var j = function(e3) {
          queueMicrotask(() => {
            throw e3;
          });
        };
        for (var x of p2) j(x);
        throw f;
      }
    } finally {
      e2.__root = t3, delete e2.currentTarget, Ko(u), Xo(v);
    }
  }
}
function _r(e2) {
  var n2 = document.createElement("template");
  return n2.innerHTML = e2.replaceAll("<!>", "<!---->"), n2.content;
}
function Fr(e2, n2) {
  var t3 = Zo;
  null === t3.nodes_start && (t3.nodes_start = e2, t3.nodes_end = n2);
}
function Lr(e2, n2) {
  var t3, o2 = !!(1 & n2), r2 = !!(2 & n2), a2 = !e2.startsWith("<!>");
  return () => {
    void 0 === t3 && (t3 = _r(a2 ? e2 : "<!>" + e2), o2 || (t3 = lo(t3)));
    var n3 = r2 || ro ? document.importNode(t3, true) : t3.cloneNode(true);
    o2 ? Fr(lo(n3), n3.lastChild) : Fr(n3, n3);
    return n3;
  };
}
function Wr(e2, n2) {
  return function(e3, n3) {
    var t3, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "svg", r2 = !e3.startsWith("<!>"), a2 = !!(1 & n3), i2 = "<".concat(o2, ">").concat(r2 ? e3 : "<!>" + e3, "</").concat(o2, ">");
    return () => {
      if (!t3) {
        var e4 = lo(_r(i2));
        if (a2) for (t3 = document.createDocumentFragment(); lo(e4); ) t3.appendChild(lo(e4));
        else t3 = lo(e4);
      }
      var n4 = t3.cloneNode(true);
      return a2 ? Fr(lo(n4), n4.lastChild) : Fr(n4, n4), n4;
    };
  }(e2, n2, "svg");
}
function Vr() {
  var e2 = so((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "") + "");
  return Fr(e2, e2), e2;
}
function $r() {
  var e2 = document.createDocumentFragment(), n2 = document.createComment(""), t3 = so();
  return e2.append(n2, t3), Fr(n2, t3), e2;
}
function Hr(e2, n2) {
  null !== e2 && e2.before(n2);
}
var Qr = ["beforeinput", "click", "change", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"];
var Yr = {
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
var Kr = ["touchstart", "touchmove"];
function Zr(e2) {
  return Kr.includes(e2);
}
function Xr(e2, n2) {
  var t3, o2 = null == n2 ? "" : "object" == typeof n2 ? n2 + "" : n2;
  o2 !== (null !== (t3 = e2.__t) && void 0 !== t3 ? t3 : e2.__t = e2.nodeValue) && (e2.__t = o2, e2.nodeValue = o2 + "");
}
function Gr(e2, n2) {
  return function(e3, n3) {
    var {
      target: t3,
      anchor: o2,
      props: r2 = {},
      events: a2,
      context: i2,
      intro: s2 = true
    } = n3;
    !function() {
      if (void 0 === oo) {
        oo = window, ro = /Firefox/.test(navigator.userAgent);
        var e4 = Element.prototype, n4 = Node.prototype, t4 = Text.prototype;
        ao = Xn(n4, "firstChild").get, io = Xn(n4, "nextSibling").get, ot2(e4) && (e4.__click = void 0, e4.__className = void 0, e4.__attributes = null, e4.__style = void 0, e4.__e = void 0), ot2(t4) && (t4.__t = void 0);
      }
    }();
    var l = /* @__PURE__ */ new Set(), c = (e4) => {
      for (var n4 = 0; n4 < e4.length; n4++) {
        var o3 = e4[n4];
        if (!l.has(o3)) {
          l.add(o3);
          var r3 = Zr(o3);
          t3.addEventListener(o3, Br, {
            passive: r3
          });
          var a3 = ea.get(o3);
          void 0 === a3 ? (document.addEventListener(o3, Br, {
            passive: r3
          }), ea.set(o3, 1)) : ea.set(o3, a3 + 1);
        }
      }
    };
    c(Kn(Nr)), Ir.add(c);
    var d = void 0, u = function(e4) {
      var n4 = ho(ct2, e4, true);
      return function() {
        var e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return new Promise((t4) => {
          e5.outro ? Ro(n4, () => {
            Mo(n4), t4(void 0);
          }) : (Mo(n4), t4(void 0));
        });
      };
    }(() => {
      var n4 = null != o2 ? o2 : t3.appendChild(so());
      return Co(() => {
        i2 && (Tt({}), Rt.c = i2);
        a2 && (r2.$$events = a2), d = e3(n4, r2) || {}, i2 && Nt();
      }), () => {
        for (var e4 of l) {
          t3.removeEventListener(e4, Br);
          var r3 = ea.get(e4);
          0 === --r3 ? (document.removeEventListener(e4, Br), ea.delete(e4)) : ea.set(e4, r3);
        }
        var a3;
        (Ir.delete(c), n4 !== o2) && (null === (a3 = n4.parentNode) || void 0 === a3 || a3.removeChild(n4));
      };
    });
    return na.set(d, u), d;
  }(e2, n2);
}
var ea = /* @__PURE__ */ new Map();
var na = /* @__PURE__ */ new WeakMap();
function ta(e2) {
  null === Rt && At(), $n && null !== Rt.l ? ia(Rt).m.push(e2) : mo(() => {
    var n2 = Or(e2);
    if ("function" == typeof n2) return n2;
  });
}
function oa(e2) {
  null === Rt && At(), ta(() => () => Or(e2));
}
function ra() {
  var e2 = Rt;
  return null === e2 && At(), (n2, t3, o2) => {
    var r2, a2 = null === (r2 = e2.s.$$events) || void 0 === r2 ? void 0 : r2[n2];
    if (a2) {
      var i2 = Qn(a2) ? a2.slice() : [a2], s2 = function(e3, n3) {
        var {
          bubbles: t4 = false,
          cancelable: o3 = false
        } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return new CustomEvent(e3, {
          detail: n3,
          bubbles: t4,
          cancelable: o3
        });
      }(n2, t3, o2);
      for (var l of i2) l.call(e2.x, s2);
      return !s2.defaultPrevented;
    }
    return true;
  };
}
function aa(e2) {
  null === Rt && At(), null === Rt.l && function() {
    throw new Error("https://svelte.dev/e/lifecycle_legacy_only");
  }(), ia(Rt).b.push(e2);
}
function ia(e2) {
  var n2, t3 = e2.l;
  return null !== (n2 = t3.u) && void 0 !== n2 ? n2 : t3.u = {
    a: [],
    b: [],
    m: []
  };
}
function sa(e2, n2) {
  var [t3, o2] = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0], r2 = e2, a2 = null, i2 = null, s2 = Hn, l = false, c = function(e3) {
    l = true, d(!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], e3);
  }, d = (e3, n3) => {
    s2 !== (s2 = e3) && (s2 ? (a2 ? To(a2) : n3 && (a2 = Co(() => n3(r2))), i2 && Ro(i2, () => {
      i2 = null;
    })) : (i2 ? To(i2) : n3 && (i2 = Co(() => n3(r2, [t3 + 1, o2]))), a2 && Ro(a2, () => {
      a2 = null;
    })));
  };
  So(() => {
    l = false, n2(c), l || d(null, null);
  }, t3 > 0 ? mt2 : 0);
}
function la(e2, n2, t3) {
  var o2, r2 = e2, a2 = Hn, i2 = It() ? Mt : Ot;
  So(() => {
    i2(a2, a2 = n2()) && (o2 && Ro(o2), o2 = Co(() => t3(r2)));
  });
}
function ca(e2, n2) {
  return n2;
}
function da(e2, n2, t3, o2, r2) {
  var a2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, i2 = e2, s2 = {
    flags: n2,
    items: /* @__PURE__ */ new Map(),
    first: null
  };
  !(4 & n2) || (i2 = e2.appendChild(so()));
  var l = null, c = false, d = Lt(() => {
    var e3 = t3();
    return Qn(e3) ? e3 : null == e3 ? [] : Kn(e3);
  });
  So(() => {
    var e3 = Sr(d), u = e3.length;
    c && 0 === u || (c = 0 === u, function(e4, n3, t4, o3, r3, a3, i3) {
      var s3, l2, c2, d2, u2, v, f = !!(8 & r3), p2 = !!(3 & r3), h2 = e4.length, g = n3.items, m = n3.first, b = m, j = null, x = [], y = [];
      if (f) for (v = 0; v < h2; v += 1) {
        var w;
        if (d2 = a3(c2 = e4[v], v), void 0 !== (u2 = g.get(d2))) null === (w = u2.a) || void 0 === w || w.measure(), (null != l2 ? l2 : l2 = /* @__PURE__ */ new Set()).add(u2);
      }
      for (v = 0; v < h2; v += 1) if (d2 = a3(c2 = e4[v], v), void 0 !== (u2 = g.get(d2))) {
        var k;
        if (p2 && ua(u2, c2, v, r3), 0 !== (u2.e.f & ht2)) {
          if (To(u2.e), f) null === (k = u2.a) || void 0 === k || k.unfix(), (null != l2 ? l2 : l2 = /* @__PURE__ */ new Set()).delete(u2);
        }
        if (u2 !== b) {
          if (void 0 !== s3 && s3.has(u2)) {
            if (x.length < y.length) {
              var S, C3 = y[0];
              j = C3.prev;
              var z3 = x[0], O = x[x.length - 1];
              for (S = 0; S < x.length; S += 1) fa(x[S], C3, t4);
              for (S = 0; S < y.length; S += 1) s3.delete(y[S]);
              pa(n3, z3.prev, O.next), pa(n3, j, z3), pa(n3, O, C3), b = C3, j = O, v -= 1, x = [], y = [];
            } else s3.delete(u2), fa(u2, b, t4), pa(n3, u2.prev, u2.next), pa(n3, u2, null === j ? n3.first : j.next), pa(n3, j, u2), j = u2;
            continue;
          }
          for (x = [], y = []; null !== b && b.k !== d2; ) 0 === (b.e.f & ht2) && (null != s3 ? s3 : s3 = /* @__PURE__ */ new Set()).add(b), y.push(b), b = b.next;
          if (null === b) continue;
          u2 = b;
        }
        x.push(u2), j = u2, b = u2.next;
      } else {
        j = va(b ? b.e.nodes_start : t4, n3, j, null === j ? n3.first : j.next, c2, d2, v, o3, r3, i3), g.set(d2, j), x = [], y = [], b = j.next;
      }
      if (null !== b || void 0 !== s3) {
        for (var M2 = void 0 === s3 ? [] : Kn(s3); null !== b; ) 0 === (b.e.f & ht2) && M2.push(b), b = b.next;
        var E = M2.length;
        if (E > 0) {
          var A2 = 4 & r3 && 0 === h2 ? t4 : null;
          if (f) {
            for (v = 0; v < E; v += 1) {
              var R;
              null === (R = M2[v].a) || void 0 === R || R.measure();
            }
            for (v = 0; v < E; v += 1) {
              var q2;
              null === (q2 = M2[v].a) || void 0 === q2 || q2.fix();
            }
          }
          !function(e5, n4, t5, o4) {
            for (var r4 = [], a4 = n4.length, i4 = 0; i4 < a4; i4++) Po(n4[i4].e, r4, true);
            var s4 = a4 > 0 && 0 === r4.length && null !== t5;
            if (s4) {
              var l3 = t5.parentNode;
              l3.textContent = "", l3.append(t5), o4.clear(), pa(e5, n4[0].prev, n4[a4 - 1].next);
            }
            qo(r4, () => {
              for (var t6 = 0; t6 < a4; t6++) {
                var r5 = n4[t6];
                s4 || (o4.delete(r5.k), pa(e5, r5.prev, r5.next)), Mo(r5.e, !s4);
              }
            });
          }(n3, M2, A2, g);
        }
      }
      f && Jo(() => {
        if (void 0 !== l2) for (u2 of l2) {
          var e5;
          null === (e5 = u2.a) || void 0 === e5 || e5.apply();
        }
      });
      Zo.first = n3.first && n3.first.e, Zo.last = j && j.e;
    }(e3, s2, i2, r2, n2, o2, t3), null !== a2 && (0 === u ? l ? To(l) : l = Co(() => a2(i2)) : null !== l && Ro(l, () => {
      l = null;
    })), Sr(d));
  });
}
function ua(e2, n2, t3, o2) {
  1 & o2 && Gt(e2.v, n2), 2 & o2 ? Gt(e2.i, t3) : e2.i = t3;
}
function va(e2, n2, t3, o2, r2, a2, i2, s2, l, c) {
  var d = !!(1 & l) ? !(16 & l) ? Kt(r2, false, false) : Qt(r2) : r2, u = 2 & l ? Qt(i2) : i2, v = {
    i: u,
    v: d,
    k: a2,
    a: null,
    e: null,
    prev: t3,
    next: o2
  };
  try {
    return v.e = Co(() => s2(e2, d, u, c), false), v.e.prev = t3 && t3.e, v.e.next = o2 && o2.e, null === t3 ? n2.first = v : (t3.next = v, t3.e.next = v.e), null !== o2 && (o2.prev = v, o2.e.prev = v.e), v;
  } finally {
  }
}
function fa(e2, n2, t3) {
  for (var o2 = e2.next ? e2.next.e.nodes_start : t3, r2 = n2 ? n2.e.nodes_start : t3, a2 = e2.e.nodes_start; a2 !== o2; ) {
    var i2 = co(a2);
    r2.before(a2), a2 = i2;
  }
}
function pa(e2, n2, t3) {
  null === n2 ? e2.first = t3 : (n2.next = t3, n2.e.next = t3 && t3.e), null !== t3 && (t3.prev = n2, t3.e.prev = n2 && n2.e);
}
function ha(e2, n2) {
  var t3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = e2, a2 = "";
  ko(() => {
    var e3, i2 = Zo;
    if (a2 !== (a2 = null !== (e3 = n2()) && void 0 !== e3 ? e3 : "") && (null !== i2.nodes_start && (Eo(i2.nodes_start, i2.nodes_end), i2.nodes_start = i2.nodes_end = null), "" !== a2)) {
      var s2 = a2 + "";
      t3 ? s2 = "<svg>".concat(s2, "</svg>") : o2 && (s2 = "<math>".concat(s2, "</math>"));
      var l = _r(s2);
      if ((t3 || o2) && (l = lo(l)), Fr(lo(l), l.lastChild), t3 || o2) for (; lo(l); ) r2.before(lo(l));
      else r2.before(l);
    }
  });
}
function ga(e2, n2, t3, o2, r2) {
  var a2, i2 = null === (a2 = n2.$$slots) || void 0 === a2 ? void 0 : a2[t3], s2 = false;
  true === i2 && (i2 = n2["default" === t3 ? "children" : t3], s2 = true), void 0 === i2 ? null !== r2 && r2(e2) : i2(e2, s2 ? () => o2 : o2);
}
function ma(e2, n2, t3) {
  var o2, r2, a2 = e2;
  So(() => {
    o2 !== (o2 = n2()) && (r2 && (Ro(r2), r2 = null), o2 && (r2 = Co(() => t3(a2, o2))));
  }, mt2);
}
function ba(e2, n2, t3) {
  jo(() => {
    var o2 = Or(() => n2(e2, null == t3 ? void 0 : t3()) || {});
    if (t3 && null != o2 && o2.update) {
      var r2 = false, a2 = {};
      wo(() => {
        var e3 = t3();
        Ar(e3), r2 && Ot(a2, e3) && (a2 = e3, o2.update(e3));
      }), r2 = true;
    }
    if (null != o2 && o2.destroy) return () => o2.destroy();
  });
}
function ja(e2, n2) {
  var t3, o2 = void 0;
  So(() => {
    o2 !== (o2 = n2()) && (t3 && (Mo(t3), t3 = null), o2 && (t3 = Co(() => {
      jo(() => o2(e2));
    })));
  });
}
function xa(e2) {
  var n2, t3, o2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) o2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var r2 = e2.length;
    for (n2 = 0; n2 < r2; n2++) e2[n2] && (t3 = xa(e2[n2])) && (o2 && (o2 += " "), o2 += t3);
  } else for (t3 in e2) e2[t3] && (o2 && (o2 += " "), o2 += t3);
  return o2;
}
function ya(e2) {
  return "object" == typeof e2 ? function() {
    for (var e3, n2, t3 = 0, o2 = "", r2 = arguments.length; t3 < r2; t3++) (e3 = arguments[t3]) && (n2 = xa(e3)) && (o2 && (o2 += " "), o2 += n2);
    return o2;
  }(e2) : null != e2 ? e2 : "";
}
var wa = [..." 	\n\r\f\v\uFEFF"];
function ka(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? " !important;" : ";", t3 = "";
  for (var o2 in e2) {
    var r2 = e2[o2];
    null != r2 && "" !== r2 && (t3 += " " + o2 + ": " + r2 + n2);
  }
  return t3;
}
function Sa(e2) {
  return "-" !== e2[0] || "-" !== e2[1] ? e2.toLowerCase() : e2;
}
function Ca(e2, n2, t3, o2, r2, a2) {
  var i2 = e2.__className;
  if (i2 !== t3 || void 0 === i2) {
    var s2 = function(e3, n3, t4) {
      var o3 = null == e3 ? "" : "" + e3;
      if (n3 && (o3 = o3 ? o3 + " " + n3 : n3), t4) {
        for (var r3 in t4) if (t4[r3]) o3 = o3 ? o3 + " " + r3 : r3;
        else if (o3.length) for (var a3 = r3.length, i3 = 0; (i3 = o3.indexOf(r3, i3)) >= 0; ) {
          var s3 = i3 + a3;
          0 !== i3 && !wa.includes(o3[i3 - 1]) || s3 !== o3.length && !wa.includes(o3[s3]) ? i3 = s3 : o3 = (0 === i3 ? "" : o3.substring(0, i3)) + o3.substring(s3 + 1);
        }
      }
      return "" === o3 ? null : o3;
    }(t3, o2, a2);
    null == s2 ? e2.removeAttribute("class") : n2 ? e2.className = s2 : e2.setAttribute("class", s2), e2.__className = t3;
  } else if (a2 && r2 !== a2) for (var l in a2) {
    var c = !!a2[l];
    null != r2 && c === !!r2[l] || e2.classList.toggle(l, c);
  }
  return a2;
}
function za(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t3 = arguments.length > 2 ? arguments[2] : void 0, o2 = arguments.length > 3 ? arguments[3] : void 0;
  for (var r2 in t3) {
    var a2 = t3[r2];
    n2[r2] !== a2 && (null == t3[r2] ? e2.style.removeProperty(r2) : e2.style.setProperty(r2, a2, o2));
  }
}
function Oa(e2, n2, t3, o2) {
  if (e2.__style !== n2) {
    var r2 = function(e3, n3) {
      if (n3) {
        var t4, o3, r3 = "";
        if (Array.isArray(n3) ? (t4 = n3[0], o3 = n3[1]) : t4 = n3, e3) {
          e3 = String(e3).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
          var a2 = false, i2 = 0, s2 = false, l = [];
          t4 && l.push(...Object.keys(t4).map(Sa)), o3 && l.push(...Object.keys(o3).map(Sa));
          for (var c = 0, d = -1, u = e3.length, v = 0; v < u; v++) {
            var f = e3[v];
            if (s2 ? "/" === f && "*" === e3[v - 1] && (s2 = false) : a2 ? a2 === f && (a2 = false) : "/" === f && "*" === e3[v + 1] ? s2 = true : '"' === f || "'" === f ? a2 = f : "(" === f ? i2++ : ")" === f && i2--, !s2 && false === a2 && 0 === i2) {
              if (":" === f && -1 === d) d = v;
              else if (";" === f || v === u - 1) {
                if (-1 !== d) {
                  var p2 = Sa(e3.substring(c, d).trim());
                  l.includes(p2) || (";" !== f && v++, r3 += " " + e3.substring(c, v).trim() + ";");
                }
                c = v + 1, d = -1;
              }
            }
          }
        }
        return t4 && (r3 += ka(t4)), o3 && (r3 += ka(o3, true)), "" === (r3 = r3.trim()) ? null : r3;
      }
      return null == e3 ? null : String(e3);
    }(n2, o2);
    null == r2 ? e2.removeAttribute("style") : e2.style.cssText = r2, e2.__style = n2;
  } else o2 && (Array.isArray(o2) ? (za(e2, null == t3 ? void 0 : t3[0], o2[0]), za(e2, null == t3 ? void 0 : t3[1], o2[1], "important")) : za(e2, t3, o2));
  return o2;
}
function Ma(e2, n2) {
  var t3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  if (e2.multiple) {
    if (null == n2) return;
    if (!Qn(n2)) return void console.warn("https://svelte.dev/e/select_multiple_invalid_value");
    for (var o2 of e2.options) o2.selected = n2.includes(Aa(o2));
  } else {
    for (o2 of e2.options) {
      if (Bt(Aa(o2), n2)) return void (o2.selected = true);
    }
    t3 && void 0 === n2 || (e2.selectedIndex = -1);
  }
}
function Ea(e2) {
  var n2 = new MutationObserver(() => {
    Ma(e2, e2.__value);
  });
  n2.observe(e2, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ["value"]
  }), go(() => {
    n2.disconnect();
  });
}
function Aa(e2) {
  return "__value" in e2 ? e2.__value : e2.value;
}
var Ra = Symbol("class");
var qa = Symbol("style");
var Pa = Symbol("is custom element");
var Ta = Symbol("is html");
function Na(e2, n2) {
  var t3 = Ja(e2);
  t3.value !== (t3.value = null != n2 ? n2 : void 0) && (e2.value !== n2 || 0 === n2 && "PROGRESS" === e2.nodeName) && (e2.value = null != n2 ? n2 : "");
}
function Ia(e2, n2, t3, o2) {
  var r2 = Ja(e2);
  r2[n2] !== (r2[n2] = t3) && ("loading" === n2 && (e2[St] = t3), null == t3 ? e2.removeAttribute(n2) : "string" != typeof t3 && _a2(e2).includes(n2) ? e2[n2] = t3 : e2.setAttribute(n2, t3));
}
function Ua(e2, n2, t3, o2) {
  var r2, a2 = Ja(e2), i2 = a2[Pa], s2 = !a2[Ta], l = n2 || {}, c = "OPTION" === e2.tagName;
  for (var d in n2) d in t3 || (t3[d] = null);
  (t3.class ? t3.class = ya(t3.class) : (o2 || t3[Ra]) && (t3.class = null), t3[qa]) && (null !== (r2 = t3.style) && void 0 !== r2 || (t3.style = null));
  var u, v, f, p2, h2, g, m = _a2(e2), b = function(r3) {
    var d2 = t3[r3];
    if (c && "value" === r3 && null == d2) return e2.value = e2.__value = "", l[r3] = d2, 0;
    if ("class" === r3) return u = "http://www.w3.org/1999/xhtml" === e2.namespaceURI, Ca(e2, u, d2, o2, null == n2 ? void 0 : n2[Ra], t3[Ra]), l[r3] = d2, l[Ra] = t3[Ra], 0;
    if ("style" === r3) return Oa(e2, d2, null == n2 ? void 0 : n2[qa], t3[qa]), l[r3] = d2, l[qa] = t3[qa], 0;
    if (d2 === (v = l[r3]) && (void 0 !== d2 || !e2.hasAttribute(r3))) return 0;
    if (l[r3] = d2, "$$" === (f = r3[0] + r3[1])) return 0;
    if ("on" === f) {
      var b2 = {}, j2 = "$$" + r3, x = r3.slice(2);
      if (p2 = function(e3) {
        return Qr.includes(e3);
      }(x), function(e3) {
        return e3.endsWith("capture") && "gotpointercapture" !== e3 && "lostpointercapture" !== e3;
      }(x) && (x = x.slice(0, -7), b2.capture = true), !p2 && v) {
        if (null != d2) return 0;
        e2.removeEventListener(x, l[j2], b2), l[j2] = null;
      }
      if (null != d2) {
        if (p2) e2["__".concat(x)] = d2, Jr([x]);
        else {
          let C3 = function(e3) {
            l[r3].call(this, e3);
          };
          l[j2] = Ur(x, e2, C3, b2);
        }
      } else p2 && (e2["__".concat(x)] = void 0);
    } else if ("style" === r3) Ia(e2, r3, d2);
    else if ("autofocus" === r3) !function(e3, n3) {
      if (n3) {
        var t4 = document.body;
        e3.autofocus = true, Jo(() => {
          document.activeElement === t4 && e3.focus();
        });
      }
    }(e2, Boolean(d2));
    else if (i2 || "__value" !== r3 && ("value" !== r3 || null == d2)) {
      if ("selected" === r3 && c) !function(e3, n3) {
        n3 ? e3.hasAttribute("selected") || e3.setAttribute("selected", "") : e3.removeAttribute("selected");
      }(e2, d2);
      else if (h2 = r3, s2 || (h2 = function(e3) {
        var n3;
        return e3 = e3.toLowerCase(), null !== (n3 = Yr[e3]) && void 0 !== n3 ? n3 : e3;
      }(h2)), g = "defaultValue" === h2 || "defaultChecked" === h2, null != d2 || i2 || g) g || m.includes(h2) && (i2 || "string" != typeof d2) ? e2[h2] = d2 : "function" != typeof d2 && Ia(e2, h2, d2);
      else if (a2[r3] = null, "value" === h2 || "checked" === h2) {
        var y = e2, w = void 0 === n2;
        if ("value" === h2) {
          var k = y.defaultValue;
          y.removeAttribute(h2), y.defaultValue = k, y.value = y.__value = w ? k : null;
        } else {
          var S = y.defaultChecked;
          y.removeAttribute(h2), y.defaultChecked = S, y.checked = !!w && S;
        }
      } else e2.removeAttribute(r3);
    } else e2.value = e2.__value = d2;
  };
  for (var j in t3) b(j);
  return l;
}
function Da(e2, n2) {
  var t3 = arguments.length > 3 ? arguments[3] : void 0, o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _t, a2 = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []).map(r2), i2 = void 0, s2 = {}, l = "SELECT" === e2.nodeName, c = false;
  if (So(() => {
    var r3 = n2(...a2.map(Sr)), d2 = Ua(e2, i2, r3, t3, o2);
    for (var u of (c && l && "value" in r3 && Ma(e2, r3.value), Object.getOwnPropertySymbols(s2))) r3[u] || Mo(s2[u]);
    for (var v of Object.getOwnPropertySymbols(r3)) {
      var f = r3[v];
      "@attach" !== v.description || i2 && f === i2[v] || (s2[v] && Mo(s2[v]), s2[v] = Co(() => ja(e2, () => f))), d2[v] = f;
    }
    i2 = d2;
  }), l) {
    var d = e2;
    jo(() => {
      Ma(d, i2.value, true), Ea(d);
    });
  }
  c = true;
}
function Ja(e2) {
  var n2;
  return null !== (n2 = e2.__attributes) && void 0 !== n2 ? n2 : e2.__attributes = {
    [Pa]: e2.nodeName.includes("-"),
    [Ta]: "http://www.w3.org/1999/xhtml" === e2.namespaceURI
  };
}
var Ba = /* @__PURE__ */ new Map();
function _a2(e2) {
  var n2, t3 = Ba.get(e2.nodeName);
  if (t3) return t3;
  Ba.set(e2.nodeName, t3 = []);
  for (var o2 = e2, r2 = Element.prototype; r2 !== o2; ) {
    for (var a2 in n2 = Gn(o2)) n2[a2].set && t3.push(a2);
    o2 = tt2(o2);
  }
  return t3;
}
function Fa(e2, n2) {
  var t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : n2, o2 = It();
  Tr(e2, "input", (r2) => {
    var a2 = r2 ? e2.defaultValue : e2.value;
    if (a2 = La(e2) ? Wa(a2) : a2, t3(a2), o2 && a2 !== (a2 = n2())) {
      var i2 = e2.selectionStart, s2 = e2.selectionEnd;
      e2.value = null != a2 ? a2 : "", null !== s2 && (e2.selectionStart = i2, e2.selectionEnd = Math.min(s2, e2.value.length));
    }
  }), null == Or(n2) && e2.value && t3(La(e2) ? Wa(e2.value) : e2.value), wo(() => {
    var t4 = n2();
    La(e2) && t4 === Wa(e2.value) || ("date" !== e2.type || t4 || e2.value) && t4 !== e2.value && (e2.value = null != t4 ? t4 : "");
  });
}
function La(e2) {
  var n2 = e2.type;
  return "number" === n2 || "range" === n2;
}
function Wa(e2) {
  return "" === e2 ? null : +e2;
}
function Va(e2, n2, t3) {
  var o2 = Xn(e2, n2);
  o2 && o2.set && (e2[n2] = t3, go(() => {
    e2[n2] = null;
  }));
}
function $a(e2, n2) {
  return e2 === n2 || (null == e2 ? void 0 : e2[wt]) === n2;
}
function Ha() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 ? arguments[1] : void 0, t3 = arguments.length > 2 ? arguments[2] : void 0;
  return jo(() => {
    var o2, r2;
    return wo(() => {
      o2 = r2, r2 = [], Or(() => {
        e2 !== t3(...r2) && (n2(e2, ...r2), o2 && $a(t3(...o2), e2) && n2(null, ...o2));
      });
    }), () => {
      Jo(() => {
        r2 && $a(t3(...r2), e2) && n2(null, ...r2);
      });
    };
  }), e2;
}
function Qa(e2) {
  return function() {
    for (var n2 = arguments.length, t3 = new Array(n2), o2 = 0; o2 < n2; o2++) t3[o2] = arguments[o2];
    return t3[0].stopPropagation(), null == e2 ? void 0 : e2.apply(this, t3);
  };
}
function Ya(e2) {
  return function() {
    for (var n2 = arguments.length, t3 = new Array(n2), o2 = 0; o2 < n2; o2++) t3[o2] = arguments[o2];
    return t3[0].preventDefault(), null == e2 ? void 0 : e2.apply(this, t3);
  };
}
function Ka() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], n2 = Rt, t3 = n2.l.u;
  if (t3) {
    var o2, r2 = () => Ar(n2.s);
    if (e2) {
      var a2 = 0, i2 = {}, s2 = _t(() => {
        var e3 = false, t4 = n2.s;
        for (var o3 in t4) t4[o3] !== i2[o3] && (i2[o3] = t4[o3], e3 = true);
        return e3 && a2++, a2;
      });
      r2 = () => Sr(s2);
    }
    t3.b.length && (o2 = () => {
      Za(n2, r2), st2(t3.b);
    }, po(), ho(2097160, o2, true)), mo(() => {
      var e3 = Or(() => t3.m.map(it2));
      return () => {
        for (var n3 of e3) "function" == typeof n3 && n3();
      };
    }), t3.a.length && mo(() => {
      Za(n2, r2), st2(t3.a);
    });
  }
}
function Za(e2, n2) {
  if (e2.l.s) for (var t3 of e2.l.s) Sr(t3);
  n2();
}
function Xa(e2) {
  var n2 = Qt(0);
  return function() {
    return 1 === arguments.length ? (Xt(n2, Sr(n2) + 1), arguments[0]) : (Sr(n2), e2());
  };
}
function Ga(e2, n2) {
  var t3, o2 = null === (t3 = e2.$$events) || void 0 === t3 ? void 0 : t3[n2.type], r2 = Qn(o2) ? o2.slice() : null == o2 ? [] : [o2];
  for (var a2 of r2) a2.call(this, n2);
}
var ei = false;
var ni = {
  get(e2, n2) {
    if (!e2.exclude.includes(n2)) return Sr(e2.version), n2 in e2.special ? e2.special[n2]() : e2.props[n2];
  },
  set(e2, n2, t3) {
    if (!(n2 in e2.special)) {
      var o2 = Zo;
      try {
        Xo(e2.parent_effect), e2.special[n2] = ai({
          get [n2]() {
            return e2.props[n2];
          }
        }, n2, 4);
      } finally {
        Xo(o2);
      }
    }
    return e2.special[n2](t3), eo(e2.version), true;
  },
  getOwnPropertyDescriptor(e2, n2) {
    if (!e2.exclude.includes(n2)) return n2 in e2.props ? {
      enumerable: true,
      configurable: true,
      value: e2.props[n2]
    } : void 0;
  },
  deleteProperty: (e2, n2) => (e2.exclude.includes(n2) || (e2.exclude.push(n2), eo(e2.version)), true),
  has: (e2, n2) => !e2.exclude.includes(n2) && n2 in e2.props,
  ownKeys: (e2) => Reflect.ownKeys(e2.props).filter((n2) => !e2.exclude.includes(n2))
};
function ti(e2, n2) {
  return new Proxy({
    props: e2,
    exclude: n2,
    special: {},
    version: Qt(0),
    parent_effect: Zo
  }, ni);
}
var oi = {
  get(e2, n2) {
    for (var t3 = e2.props.length; t3--; ) {
      var o2 = e2.props[t3];
      if (rt2(o2) && (o2 = o2()), "object" == typeof o2 && null !== o2 && n2 in o2) return o2[n2];
    }
  },
  set(e2, n2, t3) {
    for (var o2 = e2.props.length; o2--; ) {
      var r2 = e2.props[o2];
      rt2(r2) && (r2 = r2());
      var a2 = Xn(r2, n2);
      if (a2 && a2.set) return a2.set(t3), true;
    }
    return false;
  },
  getOwnPropertyDescriptor(e2, n2) {
    for (var t3 = e2.props.length; t3--; ) {
      var o2 = e2.props[t3];
      if (rt2(o2) && (o2 = o2()), "object" == typeof o2 && null !== o2 && n2 in o2) {
        var r2 = Xn(o2, n2);
        return r2 && !r2.configurable && (r2.configurable = true), r2;
      }
    }
  },
  has(e2, n2) {
    if (n2 === wt || n2 === kt) return false;
    for (var t3 of e2.props) if (rt2(t3) && (t3 = t3()), null != t3 && n2 in t3) return true;
    return false;
  },
  ownKeys(e2) {
    var n2 = [];
    for (var t3 of e2.props) if (rt2(t3) && (t3 = t3()), t3) {
      for (var o2 in t3) n2.includes(o2) || n2.push(o2);
      for (var r2 of Object.getOwnPropertySymbols(t3)) n2.includes(r2) || n2.push(r2);
    }
    return n2;
  }
};
function ri() {
  for (var e2 = arguments.length, n2 = new Array(e2), t3 = 0; t3 < e2; t3++) n2[t3] = arguments[t3];
  return new Proxy({
    props: n2
  }, oi);
}
function ai(e2, n2, t3, o2) {
  var r2, a2, i2 = !$n || !!(2 & t3), s2 = !!(8 & t3), l = !!(16 & t3), c = o2, d = true, u = () => (d && (d = false, c = l ? Or(o2) : o2), c);
  if (s2) {
    var v, f, p2 = wt in e2 || kt in e2;
    r2 = null !== (v = null === (f = Xn(e2, n2)) || void 0 === f ? void 0 : f.set) && void 0 !== v ? v : p2 && n2 in e2 ? (t4) => e2[n2] = t4 : void 0;
  }
  var h2, g = false;
  if (s2 ? [a2, g] = function(e3) {
    var n3 = ei;
    try {
      return ei = false, [e3(), ei];
    } finally {
      ei = n3;
    }
  }(() => e2[n2]) : a2 = e2[n2], void 0 === a2 && void 0 !== o2 && (a2 = u(), r2 && (i2 && function() {
    throw new Error("https://svelte.dev/e/props_invalid_value");
  }(), r2(a2))), h2 = i2 ? () => {
    var t4 = e2[n2];
    return void 0 === t4 ? u() : (d = true, t4);
  } : () => {
    var t4 = e2[n2];
    return void 0 !== t4 && (c = void 0), void 0 === t4 ? c : t4;
  }, i2 && !(4 & t3)) return h2;
  if (r2) {
    var m = e2.$$legacy;
    return function(e3, n3) {
      return arguments.length > 0 ? (i2 && n3 && !m && !g || r2(n3 ? h2() : e3), e3) : h2();
    };
  }
  var b = false, j = (1 & t3 ? _t : Lt)(() => (b = false, h2()));
  s2 && Sr(j);
  var x = Zo;
  return function(e3, n3) {
    if (arguments.length > 0) {
      var t4 = n3 ? Sr(j) : i2 && s2 ? Dt(e3) : e3;
      return Xt(j, t4), b = true, void 0 !== c && (c = t4), e3;
    }
    return Vo && b || 0 !== (x.f & gt3) ? j.v : Sr(j);
  };
}
function ii(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e3) {
    var n3 = function(e4) {
      try {
        if ("undefined" != typeof window && void 0 !== window.localStorage) return window.localStorage[e4];
      } catch (e5) {
      }
      return;
    }("debug");
    return null != n3 && n3.endsWith("*") ? e3.startsWith(n3.slice(0, -1)) : e3 === n3;
  }(e2);
  if (!n2) return si;
  var t3 = function(e3) {
    for (var n3 = 0, t4 = 0; t4 < e3.length; t4++) n3 = (n3 << 5) - n3 + e3.charCodeAt(t4), n3 |= 0;
    return li[Math.abs(n3) % li.length];
  }(e2);
  return function() {
    for (var n3 = arguments.length, o2 = new Array(n3), r2 = 0; r2 < n3; r2++) o2[r2] = arguments[r2];
    console.log("%c".concat(e2), "color:".concat(t3), ...o2);
  };
}
function si() {
}
var li = ["#0000CC", "#0099FF", "#009400", "#8dd200", "#CCCC00", "#CC9933", "#ae04e7", "#ff35d7", "#FF3333", "#FF6600", "#FF9933", "#FFCC33"];
var ci = 0;
function di() {
  return ++ci;
}
function ui(e2) {
  return parseInt(e2, 10);
}
function vi(e2) {
  return fi.test(e2);
}
var fi = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;
function pi(e2) {
  return "object" == typeof e2 && null !== e2 && (void 0 === e2.constructor || "Object" === e2.constructor.name);
}
function hi(e2) {
  return "object" == typeof e2 && null !== e2 && (void 0 === e2.constructor || "Object" === e2.constructor.name || "Array" === e2.constructor.name);
}
function gi(e2) {
  return true === e2 || false === e2;
}
function mi(e2) {
  if ("number" == typeof e2) return e2 > 9466848e5 && isFinite(e2) && Math.floor(e2) === e2 && !isNaN(new Date(e2).valueOf());
  if ("bigint" == typeof e2) return mi(Number(e2));
  try {
    var n2 = e2 ? e2.valueOf() : e2;
    if (n2 !== e2) return mi(n2);
  } catch (e3) {
    return false;
  }
  return false;
}
function bi(e2) {
  (ji = ji || window.document.createElement("div")).style.color = "", ji.style.color = e2;
  var n2 = ji.style.color;
  return "" !== n2 ? n2.replace(/\s+/g, "").toLowerCase() : void 0;
}
var ji = void 0;
function xi(e2) {
  return "string" == typeof e2 && e2.length < 99 && !!bi(e2);
}
function yi(e2, n2) {
  if ("number" == typeof e2 || "string" == typeof e2 || "boolean" == typeof e2 || void 0 === e2) return typeof e2;
  if ("bigint" == typeof e2) return "number";
  if (null === e2) return "null";
  if (Array.isArray(e2)) return "array";
  if (pi(e2)) return "object";
  var t3 = n2.stringify(e2);
  return t3 && vi(t3) ? "number" : "true" === t3 || "false" === t3 ? "boolean" : "null" === t3 ? "null" : "unknown";
}
var wi = /^https?:\/\/\S+$/;
function ki(e2) {
  return "string" == typeof e2 && wi.test(e2);
}
function Si(e2, n2) {
  if ("" === e2) return "";
  var t3 = e2.trim();
  return "null" === t3 ? null : "true" === t3 || "false" !== t3 && (vi(t3) ? n2.parse(t3) : e2);
}
function Ci(e2) {
  return zi.test(e2);
}
var zi = /^-?[0-9]+$/;
var Oi = [];
function Mi(e2, n2) {
  if (e2.length !== n2.length) return false;
  for (var t3 = 0; t3 < e2.length; t3++) if (e2[t3] !== n2[t3]) return false;
  return true;
}
function Ei(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], t3 = {};
  if (!Array.isArray(e2)) throw new TypeError("Array expected");
  function o2(e3, r3) {
    (!Array.isArray(e3) && !pi(e3) || n2 && r3.length > 0) && (t3[compileJSONPointer(r3)] = true), pi(e3) && Object.keys(e3).forEach((n3) => {
      o2(e3[n3], r3.concat(n3));
    });
  }
  for (var r2 = Math.min(e2.length, 1e4), a2 = 0; a2 < r2; a2++) {
    o2(e2[a2], Oi);
  }
  return Object.keys(t3).sort().map(parseJSONPointer);
}
function Ai(e2, n2, t3) {
  if (!(n2 <= e2)) for (var o2 = e2; o2 < n2; o2++) t3(o2);
}
function Ri(e2, n2) {
  return e2.length > n2 ? e2.slice(0, n2) : e2;
}
function qi(e2) {
  return r({}, e2);
}
function Pi(e2) {
  return Object.values(e2);
}
function Ti(e2, n2, t3, o2) {
  var r2 = e2.slice(0), a2 = r2.splice(n2, t3);
  return r2.splice.apply(r2, [n2 + o2, 0, ...a2]), r2;
}
function Ni(e2, n2, t3) {
  return e2.slice(0, n2).concat(t3).concat(e2.slice(n2));
}
function Ii(e2, n2) {
  try {
    return n2.parse(e2);
  } catch (t3) {
    return n2.parse(jsonrepair(e2));
  }
}
function Ui(e2, n2) {
  try {
    return Ii(e2, n2);
  } catch (e3) {
    return;
  }
}
function Di(e2, n2) {
  e2 = e2.replace(Bi, "");
  try {
    return n2(e2);
  } catch (e3) {
  }
  try {
    return n2("{" + e2 + "}");
  } catch (e3) {
  }
  try {
    return n2("[" + e2 + "]");
  } catch (e3) {
  }
  throw new Error("Failed to parse partial JSON");
}
function Ji(e2) {
  e2 = e2.replace(Bi, "");
  try {
    return jsonrepair(e2);
  } catch (e3) {
  }
  try {
    var n2 = jsonrepair("[" + e2 + "]");
    return n2.substring(1, n2.length - 1);
  } catch (e3) {
  }
  try {
    var t3 = jsonrepair("{" + e2 + "}");
    return t3.substring(1, t3.length - 1);
  } catch (e3) {
  }
  throw new Error("Failed to repair partial JSON");
}
var Bi = /,\s*$/;
function _i(e2, n2) {
  var t3 = Xi.exec(n2);
  if (t3) {
    var o2 = ui(t3[2]), r2 = function(e3, n3) {
      for (var t4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e3.length, r3 = 0, a3 = t4; a3 < o3; a3++) e3.charAt(a3) === n3 && r3++;
      return r3;
    }(e2, "\n", 0, o2), a2 = o2 - e2.lastIndexOf("\n", o2) - 1;
    return {
      position: o2,
      line: r2,
      column: a2,
      message: n2.replace(Xi, () => "line ".concat(r2 + 1, " column ").concat(a2 + 1))
    };
  }
  var i2 = Gi.exec(n2), s2 = i2 ? ui(i2[1]) : void 0, l = void 0 !== s2 ? s2 - 1 : void 0, c = es.exec(n2), d = c ? ui(c[1]) : void 0, u = void 0 !== d ? d - 1 : void 0, v = void 0 !== l && void 0 !== u ? function(e3, n3, t4) {
    var o3 = e3.indexOf("\n"), r3 = 1;
    for (; r3 < n3 && -1 !== o3; ) o3 = e3.indexOf("\n", o3 + 1), r3++;
    return -1 !== o3 ? o3 + t4 + 1 : void 0;
  }(e2, l, u) : void 0;
  return {
    position: v,
    line: l,
    column: u,
    message: n2.replace(/^JSON.parse: /, "").replace(/ of the JSON data$/, "")
  };
}
function Fi(e2, n2) {
  try {
    var t3 = import_json_source_map.default.parse(e2), o2 = compileJSONPointer(n2), r2 = t3.pointers[o2];
    if (r2) return {
      path: n2,
      line: r2.key ? r2.key.line : r2.value ? r2.value.line : 0,
      column: r2.key ? r2.key.column : r2.value ? r2.value.column : 0,
      from: r2.key ? r2.key.pos : r2.value ? r2.value.pos : 0,
      to: r2.keyEnd ? r2.keyEnd.pos : r2.valueEnd ? r2.valueEnd.pos : 0
    };
  } catch (e3) {
    console.error(e3);
  }
  return {
    path: n2,
    line: 0,
    column: 0,
    from: 0,
    to: 0
  };
}
function Li(e2) {
  return pi(e2) ? void 0 !== e2.json ? void 0 !== e2.text ? 'Content must contain either a property "json" or a property "text" but not both' : void 0 : void 0 === e2.text ? 'Content must contain either a property "json" or a property "text"' : "string" != typeof e2.text ? 'Content "text" property must be a string containing a JSON document. Did you mean to use the "json" property instead?' : void 0 : "Content must be an object";
}
function Wi(e2) {
  return pi(e2) && (void 0 !== e2.json || "string" == typeof e2.text);
}
function Vi(e2) {
  return pi(e2) && "string" == typeof e2.text;
}
function $i(e2) {
  return pi(e2) && void 0 !== e2.json;
}
function Hi(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : JSON;
  return Vi(e2) ? e2 : {
    text: t3.stringify(e2.json, null, n2)
  };
}
function Qi(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : JSON;
  return $i(e2) ? e2 : {
    json: n2.parse(e2.text)
  };
}
function Yi(e2, n2, t3) {
  return Hi(e2, n2, t3).text;
}
function Ki(e2, n2) {
  return Zi(e2, n2) > n2;
}
function Zi(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1 / 0;
  if (Vi(e2)) return e2.text.length;
  var t3 = e2.json, o2 = 0;
  return function e3(t4) {
    if (Array.isArray(t4)) {
      if ((o2 += t4.length - 1 + 2) > n2) return;
      for (var r2 = 0; r2 < t4.length; r2++) {
        if (e3(t4[r2]), o2 > n2) return;
      }
    } else if (pi(t4)) {
      var a2 = Object.keys(t4);
      o2 += 2 + a2.length + (a2.length - 1);
      for (var i2 = 0; i2 < a2.length; i2++) {
        var s2 = a2[i2], l = t4[s2];
        o2 += s2.length + 2, e3(l);
      }
    } else o2 += "string" == typeof t4 ? t4.length + 2 : String(t4).length;
  }(t3), o2;
}
var Xi = /(position|char) (\d+)/;
var Gi = /line (\d+)/;
var es = /column (\d+)/;
function ns(e2, n2) {
  return e2.parse === n2.parse && e2.stringify === n2.stringify;
}
function ts(e2) {
  var n2 = e2.substring(0, 999).trim();
  return !n2.includes("\n") && ds.test(n2);
}
var os;
var rs;
var as;
var is;
var ss;
var ls;
var cs;
var ds = /[,:]\S/;
function us(e2) {
  var {
    escapeControlCharacters: n2,
    escapeUnicodeCharacters: t3
  } = e2;
  return n2 ? t3 ? vs : fs : t3 ? ps : hs;
}
!function(e2) {
  e2.text = "text", e2.tree = "tree", e2.table = "table";
}(os || (os = {})), function(e2) {
  e2.after = "after", e2.inside = "inside", e2.key = "key", e2.value = "value", e2.multi = "multi", e2.text = "text";
}(rs || (rs = {})), function(e2) {
  e2.after = "after", e2.key = "key", e2.value = "value", e2.inside = "inside";
}(as || (as = {})), function(e2) {
  e2.info = "info", e2.warning = "warning", e2.error = "error";
}(is || (is = {})), function(e2) {
  e2.key = "key", e2.value = "value";
}(ss || (ss = {})), function(e2) {
  e2.asc = "asc", e2.desc = "desc";
}(ls || (ls = {})), function(e2) {
  e2.no = "no", e2.self = "self", e2.nextInside = "nextInside";
}(cs || (cs = {}));
var vs = {
  escapeValue: (e2) => gs(xs(String(e2))),
  unescapeValue: (e2) => ys(ms(e2))
};
var fs = {
  escapeValue: (e2) => xs(String(e2)),
  unescapeValue: (e2) => ys(e2)
};
var ps = {
  escapeValue: (e2) => gs(String(e2)),
  unescapeValue: (e2) => ms(e2)
};
var hs = {
  escapeValue: (e2) => String(e2),
  unescapeValue: (e2) => e2
};
function gs(e2) {
  return e2.replace(/[^\x20-\x7F]/g, (e3) => {
    var n2;
    return "\b" === e3 || "\f" === e3 || "\n" === e3 || "\r" === e3 || "	" === e3 ? e3 : "\\u" + ("000" + (null === (n2 = e3.codePointAt(0)) || void 0 === n2 ? void 0 : n2.toString(16))).slice(-4);
  });
}
function ms(e2) {
  return e2.replace(/\\u[a-fA-F0-9]{4}/g, (e3) => {
    try {
      var n2 = JSON.parse('"' + e3 + '"');
      return bs[n2] || n2;
    } catch (n3) {
      return e3;
    }
  });
}
var bs = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var js = {
  '\\"': '"',
  "\\\\": "\\",
  "\\/": "/",
  "\\b": "\b",
  "\\f": "\f",
  "\\n": "\n",
  "\\r": "\r",
  "\\t": "	"
};
function xs(e2) {
  return e2.replace(/["\b\f\n\r\t\\]/g, (e3) => bs[e3] || e3);
}
function ys(e2) {
  return e2.replace(/\\["bfnrt\\]/g, (e3) => js[e3] || e3);
}
function ws(e2) {
  return "string" != typeof e2 ? String(e2) : e2.endsWith("\n") ? e2 + "\n" : e2;
}
function ks(e2, n2) {
  return Cs(e2, (e3) => e3.nodeName.toUpperCase() === n2.toUpperCase());
}
function Ss(e2, n2, t3) {
  return Cs(e2, (e3) => function(e4, n3, t4) {
    return "function" == typeof e4.getAttribute && e4.getAttribute(n3) === t4;
  }(e3, n2, t3));
}
function Cs(e2, n2) {
  return !!zs(e2, n2);
}
function zs(e2, n2) {
  for (var t3 = e2; t3 && !n2(t3); ) t3 = t3.parentNode;
  return t3;
}
function Os(e2) {
  var n2, t3;
  return null !== (n2 = null == e2 || null === (t3 = e2.ownerDocument) || void 0 === t3 ? void 0 : t3.defaultView) && void 0 !== n2 ? n2 : void 0;
}
function Ms(e2) {
  var n2 = Os(e2), t3 = null == n2 ? void 0 : n2.document.activeElement;
  return !!t3 && Cs(t3, (n3) => n3 === e2);
}
function Es(e2, n2) {
  return zs(e2, (e3) => e3.nodeName === n2);
}
function As(e2) {
  return Ss(e2, "data-type", "selectable-key") ? rs.key : Ss(e2, "data-type", "selectable-value") ? rs.value : Ss(e2, "data-type", "insert-selection-area-inside") ? rs.inside : Ss(e2, "data-type", "insert-selection-area-after") ? rs.after : rs.multi;
}
function Rs(e2) {
  return encodeURIComponent(compileJSONPointer(e2));
}
function qs(e2) {
  var n2, t3 = zs(e2, (e3) => !(null == e3 || !e3.hasAttribute) && e3.hasAttribute("data-path")), o2 = null !== (n2 = null == t3 ? void 0 : t3.getAttribute("data-path")) && void 0 !== n2 ? n2 : void 0;
  return o2 ? parseJSONPointer(decodeURIComponent(o2)) : void 0;
}
function Ps(e2) {
  var {
    allElements: n2,
    currentElement: t3,
    direction: o2,
    hasPrio: r2 = () => true,
    margin: a2 = 10
  } = e2, i2 = map_default(n2.filter(function(e3) {
    var n3 = e3.getBoundingClientRect();
    return n3.width > 0 && n3.height > 0;
  }), l), s2 = l(t3);
  function l(e3) {
    var n3 = e3.getBoundingClientRect();
    return {
      x: n3.left + n3.width / 2,
      y: n3.top + n3.height / 2,
      rect: n3,
      element: e3
    };
  }
  function c(e3, n3) {
    var t4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o3 = e3.x - n3.x, r3 = (e3.y - n3.y) * t4;
    return Math.sqrt(o3 * o3 + r3 * r3);
  }
  var d = (e3) => c(e3, s2);
  if ("Left" === o2 || "Right" === o2) {
    var u = "Left" === o2 ? i2.filter((e3) => {
      return n3 = s2, e3.rect.left + a2 < n3.rect.left;
      var n3;
    }) : i2.filter((e3) => {
      return n3 = s2, e3.rect.right > n3.rect.right + a2;
      var n3;
    }), v = u.filter((e3) => {
      return n3 = e3, t4 = s2, Math.abs(n3.y - t4.y) < a2;
      var n3, t4;
    }), f = minBy_default(v, d) || minBy_default(u, (e3) => c(e3, s2, 10));
    return null == f ? void 0 : f.element;
  }
  if ("Up" === o2 || "Down" === o2) {
    var p2 = "Up" === o2 ? i2.filter((e3) => {
      return n3 = s2, e3.y + a2 < n3.y;
      var n3;
    }) : i2.filter((e3) => {
      return n3 = s2, e3.y > n3.y + a2;
      var n3;
    }), h2 = p2.filter((e3) => r2(e3.element)), g = minBy_default(h2, d) || minBy_default(p2, d);
    return null == g ? void 0 : g.element;
  }
}
function Ts() {
  var e2, n2, t3, o2;
  return "undefined" != typeof navigator && null !== (e2 = null !== (n2 = null === (t3 = navigator) || void 0 === t3 || null === (t3 = t3.platform) || void 0 === t3 ? void 0 : t3.toUpperCase().includes("MAC")) && void 0 !== n2 ? n2 : null === (o2 = navigator) || void 0 === o2 || null === (o2 = o2.userAgentData) || void 0 === o2 || null === (o2 = o2.platform) || void 0 === o2 ? void 0 : o2.toUpperCase().includes("MAC")) && void 0 !== e2 && e2;
}
function Ns(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "+", t3 = [];
  Is(e2, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ts) && t3.push("Ctrl"), e2.altKey && t3.push("Alt"), e2.shiftKey && t3.push("Shift");
  var o2 = 1 === e2.key.length ? e2.key.toUpperCase() : e2.key;
  return o2 in Us || t3.push(o2), t3.join(n2);
}
function Is(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ts;
  return e2.ctrlKey || e2.metaKey && n2();
}
var Us = {
  Ctrl: true,
  Command: true,
  Control: true,
  Alt: true,
  Option: true,
  Shift: true
};
function Ds(e2, n2) {
  void 0 === n2 && (n2 = {});
  var t3 = n2.insertAt;
  if (e2 && "undefined" != typeof document) {
    var o2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
    r2.type = "text/css", "top" === t3 && o2.firstChild ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = e2 : r2.appendChild(document.createTextNode(e2));
  }
}
Ds(".jse-absolute-popup.svelte-1r8q3m8 {\n  position: relative;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  z-index: 1001;\n}\n.jse-absolute-popup.svelte-1r8q3m8 .jse-hidden-input:where(.svelte-1r8q3m8) {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  padding: 0;\n  margin: 0;\n  border: none;\n  outline: none;\n  overflow: hidden;\n}\n.jse-absolute-popup.svelte-1r8q3m8 .jse-absolute-popup-content:where(.svelte-1r8q3m8) {\n  position: absolute;\n}");
var Js = Lr('<div class="jse-absolute-popup-content svelte-1r8q3m8"><input type="text" readonly="" tabindex="-1" class="jse-hidden-input svelte-1r8q3m8"/> <!></div>');
var Bs = Lr('<div role="none" class="jse-absolute-popup svelte-1r8q3m8"><!></div>');
function _s(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "popup", 8), o2 = ai(n2, "closeAbsolutePopup", 8), r2 = Kt(), a2 = Kt();
  function i2(e3) {
    t3().options && t3().options.closeOnOuterClick && !Cs(e3.target, (e4) => e4 === Sr(r2)) && o2()(t3().id);
  }
  function s2(e3) {
    "Escape" === Ns(e3) && (e3.preventDefault(), e3.stopPropagation(), o2()(t3().id));
  }
  ta(function() {
    Sr(a2) && Sr(a2).focus();
  }), Ka();
  var l = Bs();
  Dr("mousedown", oo, function(e3) {
    i2(e3);
  }, true), Dr("keydown", oo, s2, true), Dr("wheel", oo, function(e3) {
    i2(e3);
  }, true);
  var c = uo(l), d = (e3) => {
    var n3 = Js(), o3 = uo(n3);
    Ha(o3, (e4) => Xt(a2, e4), () => Sr(a2)), ma(fo(o3, 2), () => t3().component, (e4, n4) => {
      n4(e4, ri(() => t3().props));
    }), ko((e4) => Oa(n3, e4), [() => (Sr(r2), Ar(t3()), Or(() => function(e4, n4) {
      var t4 = e4.getBoundingClientRect(), {
        left: o4,
        top: r3,
        positionAbove: a3,
        positionLeft: i3
      } = function() {
        if (n4.anchor) {
          var {
            anchor: e5,
            width: t5 = 0,
            height: o5 = 0,
            offsetTop: r4 = 0,
            offsetLeft: a4 = 0,
            position: i4
          } = n4, {
            left: s3,
            top: l2,
            bottom: c2,
            right: d2
          } = e5.getBoundingClientRect(), u = "top" === i4 || l2 + o5 > window.innerHeight && l2 > o5, v = "left" === i4 || s3 + t5 > window.innerWidth && s3 > t5;
          return {
            left: v ? d2 - a4 : s3 + a4,
            top: u ? l2 - r4 : c2 + r4,
            positionAbove: u,
            positionLeft: v
          };
        }
        if ("number" == typeof n4.left && "number" == typeof n4.top) {
          var {
            left: f,
            top: p2,
            width: h2 = 0,
            height: g = 0
          } = n4;
          return {
            left: f,
            top: p2,
            positionAbove: p2 + g > window.innerHeight && p2 > g,
            positionLeft: f + h2 > window.innerWidth && f > h2
          };
        }
        throw new Error('Invalid config: pass either "left" and "top", or pass "anchor"');
      }();
      return (a3 ? "bottom: ".concat(t4.top - r3, "px;") : "top: ".concat(r3 - t4.top, "px;")) + (i3 ? "right: ".concat(t4.left - o4, "px;") : "left: ".concat(o4 - t4.left, "px;"));
    }(Sr(r2), t3().options)))], Lt), Hr(e3, n3);
  };
  sa(c, (e3) => {
    Sr(r2) && e3(d);
  }), Ha(l, (e3) => Xt(r2, e3), () => Sr(r2)), Dr("mousedown", l, function(e3) {
    e3.stopPropagation();
  }), Dr("keydown", l, s2), Hr(e2, l), Nt();
}
var Fs = Lr("<!> <!>", 1);
function Ls(e2, n2) {
  Tt(n2, false);
  var t3, o2, r2 = ii("jsoneditor:AbsolutePopup"), a2 = Kt([], true);
  function i2(e3) {
    var n3 = Sr(a2).findIndex((n4) => n4.id === e3);
    if (-1 !== n3) {
      var t4 = Sr(a2)[n3];
      t4.options.onClose && t4.options.onClose(), Xt(a2, Sr(a2).filter((n4) => n4.id !== e3));
    }
  }
  t3 = "absolute-popup", o2 = {
    openAbsolutePopup: function(e3, n3, t4) {
      r2("open...", n3, t4);
      var o3 = {
        id: di(),
        component: e3,
        props: n3 || {},
        options: t4 || {}
      };
      return Xt(a2, [...Sr(a2), o3]), o3.id;
    },
    closeAbsolutePopup: i2
  }, Ut().set(t3, o2), xo(() => Sr(a2), () => {
    r2("popups", Sr(a2));
  }), yo(), Ka(true);
  var s2 = Fs(), l = vo(s2);
  da(l, 1, () => Sr(a2), ca, (e3, n3) => {
    _s(e3, {
      get popup() {
        return Sr(n3);
      },
      closeAbsolutePopup: i2
    });
  }), ga(fo(l, 2), n2, "default", {}, null), Hr(e2, s2), Nt();
}
function Ws(e2, n2) {
  for (var t3 = new Set(n2), o2 = e2.replace(/ \(copy( \d+)?\)$/, ""), r2 = e2, a2 = 1; t3.has(r2); ) {
    var i2 = "copy" + (a2 > 1 ? " " + a2 : "");
    r2 = "".concat(o2, " (").concat(i2, ")"), a2++;
  }
  return r2;
}
function Vs(e2, n2) {
  var t3 = n2 - 3;
  return e2.length > n2 ? e2.substring(0, t3) + "..." : e2;
}
function $s(e2) {
  if ("" === e2) return "";
  var n2 = e2.toLowerCase();
  if ("null" === n2) return null;
  if ("true" === n2) return true;
  if ("false" === n2) return false;
  if ("undefined" !== n2) {
    var t3 = Number(e2), o2 = parseFloat(e2);
    return isNaN(t3) || isNaN(o2) ? e2 : t3;
  }
}
var Hs = {
  id: "jsonquery",
  name: "JSONQuery",
  description: '\n<p>\n  Enter a <a href="https://jsonquerylang.org" target="_blank" \n  rel="noopener noreferrer">JSON Query</a> function to filter, sort, or transform the data.\n  You can use functions like <code>get</code>, <code>filter</code>,\n  <code>sort</code>, <code>pick</code>, <code>groupBy</code>, <code>uniq</code>, etcetera. \n  Example query: <code>filter(.age >= 18)</code>\n</p>\n',
  createQuery: function(e2, n2) {
    var {
      filter: t3,
      sort: o2,
      projection: r2
    } = n2, a2 = [];
    t3 && t3.path && t3.relation && t3.value && a2.push(["filter", [(i2 = t3.relation, pt("1 ".concat(i2, " 1"))[0]), Qs(t3.path), $s(t3.value)]]);
    var i2;
    o2 && o2.path && o2.direction && a2.push(["sort", Qs(o2.path), "desc" === o2.direction ? "desc" : "asc"]);
    r2 && r2.paths && (r2.paths.length > 1 ? a2.push(["pick", ...r2.paths.map(Qs)]) : a2.push(["map", Qs(r2.paths[0])]));
    return mt(["pipe", ...a2]);
  },
  executeQuery: function(e2, n2, t3) {
    var o2 = ns(t3, JSON) ? e2 : function(e3) {
      var n3 = t3.stringify(e3);
      return void 0 !== n3 ? JSON.parse(n3) : void 0;
    }(e2);
    return "" !== n2.trim() ? dt(o2, n2) : o2;
  }
};
function Qs(e2) {
  return ["get", ...e2];
}
var Ys = Wr("<g><!></g>");
function Ks(e2, n2) {
  Tt(n2, false);
  var t3 = 870711;
  var o2 = Kt(""), r2 = ai(n2, "data", 8);
  function a2(e3) {
    if (!e3 || !e3.raw) return "";
    var n3 = e3.raw, o3 = {};
    return n3 = n3.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (e4, n4) => {
      var r3 = "fa-".concat((t3 += 1).toString(16));
      return o3[n4] = r3, ' id="'.concat(r3, '"');
    }), n3 = n3.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (e4, n4, t4, r3) => {
      var a3 = n4 || r3;
      return a3 && o3[a3] ? "#".concat(o3[a3]) : e4;
    }), n3;
  }
  xo(() => Ar(r2()), () => {
    Xt(o2, a2(r2()));
  }), yo();
  var i2 = Ys();
  ha(uo(i2), () => Sr(o2), true), Hr(e2, i2), Nt();
}
Ds("\n  .fa-icon.svelte-1mc5hvj {\n    display: inline-block;\n    fill: currentColor;\n  }\n  .fa-flip-horizontal.svelte-1mc5hvj {\n    transform: scale(-1, 1);\n  }\n  .fa-flip-vertical.svelte-1mc5hvj {\n    transform: scale(1, -1);\n  }\n  .fa-spin.svelte-1mc5hvj {\n    animation: svelte-1mc5hvj-fa-spin 1s 0s infinite linear;\n  }\n  .fa-inverse.svelte-1mc5hvj {\n    color: #fff;\n  }\n  .fa-pulse.svelte-1mc5hvj {\n    animation: svelte-1mc5hvj-fa-spin 1s infinite steps(8);\n  }\n  @keyframes svelte-1mc5hvj-fa-spin {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n");
var Zs = Wr("<svg><!></svg>");
var Xs = Wr("<path></path>");
var Gs = Wr("<polygon></polygon>");
var el = Wr("<!><!><!>", 1);
function nl(e2, n2) {
  var t3 = ti(n2, ["children", "$$slots", "$$events", "$$legacy"]), o2 = ti(t3, ["class", "data", "scale", "spin", "inverse", "pulse", "flip", "label", "style"]);
  Tt(n2, false);
  var a2 = ai(n2, "class", 8, ""), i2 = ai(n2, "data", 8), s2 = Kt(), l = ai(n2, "scale", 8, 1), c = ai(n2, "spin", 8, false), d = ai(n2, "inverse", 8, false), u = ai(n2, "pulse", 8, false), v = ai(n2, "flip", 8, void 0), f = ai(n2, "label", 8, ""), p2 = ai(n2, "style", 8, ""), h2 = Kt(10), g = Kt(10), m = Kt(), b = Kt();
  function j() {
    var e3 = 1;
    return void 0 !== l() && (e3 = Number(l())), isNaN(e3) || e3 <= 0 ? (console.warn('Invalid prop: prop "scale" should be a number over 0.'), 1) : 1 * e3;
  }
  function x() {
    return Sr(s2) ? Math.max(Sr(s2).width, Sr(s2).height) / 16 : 1;
  }
  xo(() => (Ar(i2()), Ar(p2()), Ar(l())), () => {
    Xt(s2, function(e3) {
      var n3;
      if (e3) {
        if (!("definition" in e3)) {
          if ("iconName" in e3 && "icon" in e3) {
            e3.iconName;
            var [t4, o3, , , r2] = e3.icon;
            n3 = {
              width: t4,
              height: o3,
              paths: (Array.isArray(r2) ? r2 : [r2]).map((e4) => ({
                d: e4
              }))
            };
          } else n3 = e3[Object.keys(e3)[0]];
          return n3;
        }
        console.error("`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead");
      }
    }(i2())), p2(), l(), Xt(h2, Sr(s2) ? Sr(s2).width / x() * j() : 0), Xt(g, Sr(s2) ? Sr(s2).height / x() * j() : 0), Xt(m, function() {
      var e3 = "";
      null !== p2() && (e3 += p2());
      var n3 = j();
      return 1 === n3 ? 0 === e3.length ? "" : e3 : ("" === e3 || e3.endsWith(";") || (e3 += "; "), "".concat(e3, "font-size: ").concat(n3, "em"));
    }()), Xt(b, Sr(s2) ? "0 0 ".concat(Sr(s2).width, " ").concat(Sr(s2).height) : "0 0 ".concat(Sr(h2), " ").concat(Sr(g)));
  }), yo(), Ka(), function(e3, n3) {
    var t4 = ti(n3, ["children", "$$slots", "$$events", "$$legacy"]), o3 = ti(t4, ["class", "width", "height", "box", "spin", "inverse", "pulse", "flip", "style", "label"]), a3 = ai(n3, "class", 8, ""), i3 = ai(n3, "width", 8), s3 = ai(n3, "height", 8), l2 = ai(n3, "box", 8, "0 0 0 0"), c2 = ai(n3, "spin", 8, false), d2 = ai(n3, "inverse", 8, false), u2 = ai(n3, "pulse", 8, false), v2 = ai(n3, "flip", 8, "none"), f2 = ai(n3, "style", 8, ""), p3 = ai(n3, "label", 8, ""), h3 = Zs();
    Da(h3, (e4) => {
      var n4;
      return r(r({
        version: "1.1",
        class: "fa-icon ".concat(null !== (n4 = a3()) && void 0 !== n4 ? n4 : ""),
        width: i3(),
        height: s3(),
        "aria-label": p3(),
        role: p3() ? "img" : "presentation",
        viewBox: l2(),
        style: f2()
      }, o3), {}, {
        [Ra]: e4
      });
    }, [() => ({
      "fa-spin": c2(),
      "fa-pulse": u2(),
      "fa-inverse": d2(),
      "fa-flip-horizontal": "horizontal" === v2(),
      "fa-flip-vertical": "vertical" === v2()
    })], "svelte-1mc5hvj"), ga(uo(h3), n3, "default", {}, null), Hr(e3, h3);
  }(e2, ri({
    get label() {
      return f();
    },
    get width() {
      return Sr(h2);
    },
    get height() {
      return Sr(g);
    },
    get box() {
      return Sr(b);
    },
    get style() {
      return Sr(m);
    },
    get spin() {
      return c();
    },
    get flip() {
      return v();
    },
    get inverse() {
      return d();
    },
    get pulse() {
      return u();
    },
    get class() {
      return a2();
    }
  }, () => o2, {
    children: (e3, t4) => {
      var o3 = $r();
      ga(vo(o3), n2, "default", {}, (e4) => {
        var n3 = el(), t5 = vo(n3);
        da(t5, 1, () => (Sr(s2), Or(() => {
          var e5;
          return (null === (e5 = Sr(s2)) || void 0 === e5 ? void 0 : e5.paths) || [];
        })), ca, (e5, n4) => {
          var t6 = Xs();
          Da(t6, () => r({}, Sr(n4))), Hr(e5, t6);
        });
        var o4 = fo(t5);
        da(o4, 1, () => (Sr(s2), Or(() => {
          var e5;
          return (null === (e5 = Sr(s2)) || void 0 === e5 ? void 0 : e5.polygons) || [];
        })), ca, (e5, n4) => {
          var t6 = Gs();
          Da(t6, () => r({}, Sr(n4))), Hr(e5, t6);
        });
        var a3 = fo(o4), i3 = (e5) => {
          Ks(e5, {
            get data() {
              return Sr(s2);
            },
            set data(e6) {
              Xt(s2, e6);
            },
            $$legacy: true
          });
        };
        sa(a3, (e5) => {
          Sr(s2), Or(() => {
            var e6;
            return null === (e6 = Sr(s2)) || void 0 === e6 ? void 0 : e6.raw;
          }) && e5(i3);
        }), Hr(e4, n3);
      }), Hr(e3, o3);
    },
    $$slots: {
      default: true
    }
  })), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-boolean-toggle.svelte-1ryp01u {\n  padding: 0;\n  margin: 1px 0 0;\n  vertical-align: top;\n  display: inline-flex;\n  color: var(--jse-value-color-boolean, #ff8c00);\n}\n\n.jse-boolean-toggle.svelte-1ryp01u:not(.jse-readonly) {\n  cursor: pointer;\n}');
var tl = Lr('<div role="checkbox" tabindex="-1"><!></div>');
function ol(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "path", 9), o2 = ai(n2, "value", 9), r2 = ai(n2, "readOnly", 9), a2 = ai(n2, "onPatch", 9), i2 = ai(n2, "focus", 9);
  Ka(true);
  var s2, l = tl(), d = uo(l), u = Lt(() => true === o2() ? faCheckSquare : faSquare);
  nl(d, {
    get data() {
      return Sr(u);
    }
  }), ko((e3) => {
    Ia(l, "aria-checked", true === o2()), s2 = Ca(l, 1, "jse-boolean-toggle svelte-1ryp01u", null, s2, e3), Ia(l, "title", r2() ? "Boolean value ".concat(o2()) : "Click to toggle this boolean value");
  }, [() => ({
    "jse-readonly": r2()
  })], Lt), Dr("mousedown", l, function(e3) {
    e3.stopPropagation(), r2() || (a2()([{
      op: "replace",
      path: compileJSONPointer(t3()),
      value: !o2()
    }]), i2()());
  }), Hr(e2, l), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup,\n.jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup .picker_arrow::before,\n.jse-color-picker-popup.svelte-s1wu8v .picker_wrapper.popup .picker_arrow::after {\n  background: var(--jse-color-picker-background, var(--jse-panel-background, #ebebeb));\n  line-height: normal;\n}\n.jse-color-picker-popup.svelte-s1wu8v .picker_slider,\n.jse-color-picker-popup.svelte-s1wu8v .picker_sl,\n.jse-color-picker-popup.svelte-s1wu8v .picker_editor input,\n.jse-color-picker-popup.svelte-s1wu8v .picker_sample,\n.jse-color-picker-popup.svelte-s1wu8v .picker_done button {\n  box-shadow: var(--jse-color-picker-border-box-shadow, #cbcbcb 0 0 0 1px);\n}\n.jse-color-picker-popup.svelte-s1wu8v .picker_editor input {\n  background: var(--jse-background-color, #fff);\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-color-picker-popup.svelte-s1wu8v .picker_done button {\n  background: var(--jse-button-background, #e0e0e0);\n  color: var(--jse-button-color, var(--jse-text-color, #4d4d4d));\n}\n.jse-color-picker-popup.svelte-s1wu8v .picker_done button:hover {\n  background: var(--jse-button-background-highlight, #e7e7e7);\n}');
var rl = Lr('<div class="jse-color-picker-popup svelte-s1wu8v"></div>');
function al(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "color", 8), o2 = ai(n2, "onChange", 8), r2 = ai(n2, "showOnTop", 8), a2 = Kt(), s2 = () => {
  };
  ta(i(function* () {
    var e3, n3 = new (null === (e3 = yield import("./vanilla-picker-RRXM6TOE.js")) || void 0 === e3 ? void 0 : e3.default)({
      parent: Sr(a2),
      color: t3(),
      popup: r2() ? "top" : "bottom",
      onDone(e4) {
        var n4 = 1 === e4.rgba[3] ? e4.hex.substring(0, 7) : e4.hex;
        o2()(n4);
      }
    });
    n3.show(), s2 = () => {
      n3.destroy();
    };
  })), oa(() => {
    s2();
  }), Ka();
  var l = rl();
  Ha(l, (e3) => Xt(a2, e3), () => Sr(a2)), Hr(e2, l), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-color-picker-button.svelte-xeg9n6 {\n  font-size: var(--jse-font-size-mono, 14px);\n  width: var(--jse-color-picker-button-size, 1em);\n  height: var(--jse-color-picker-button-size, 1em);\n  box-sizing: border-box;\n  padding: 0;\n  margin: 2px 0 0 calc(0.5 * var(--jse-padding, 10px));\n  display: inline-flex;\n  vertical-align: top;\n  border: 1px solid var(--jse-text-color, #4d4d4d);\n  border-radius: 2px;\n  background: inherit;\n  outline: none;\n}\n\n.jse-color-picker-button.svelte-xeg9n6:not(.jse-readonly) {\n  cursor: pointer;\n}');
var il = Lr('<button type="button"></button>');
function sl(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), {
    openAbsolutePopup: r2
  } = Pt("absolute-popup"), a2 = ai(n2, "path", 9), i2 = ai(n2, "value", 9), s2 = ai(n2, "readOnly", 9), l = ai(n2, "onPatch", 9), d = ai(n2, "focus", 9);
  function u(e3) {
    l()([{
      op: "replace",
      path: compileJSONPointer(a2()),
      value: e3
    }]), v();
  }
  function v() {
    d()();
  }
  xo(() => Ar(i2()), () => {
    Xt(t3, bi(i2()));
  }), xo(() => (Ar(s2()), Ar(i2())), () => {
    Xt(o2, s2() ? "Color ".concat(i2()) : "Click to open a color picker");
  }), yo(), Ka(true);
  var f, p2 = il();
  ko((e3) => {
    var n3;
    f = Ca(p2, 1, "jse-color-picker-button svelte-xeg9n6", null, f, e3), Oa(p2, "background: ".concat(null !== (n3 = Sr(t3)) && void 0 !== n3 ? n3 : "")), Ia(p2, "title", Sr(o2)), Ia(p2, "aria-label", Sr(o2));
  }, [() => ({
    "jse-readonly": s2()
  })], Lt), Dr("click", p2, function(e3) {
    var n3, t4;
    if (!s2()) {
      var o3 = e3.target, a3 = o3.getBoundingClientRect().top, l2 = (null !== (n3 = null === (t4 = Os(o3)) || void 0 === t4 ? void 0 : t4.innerHeight) && void 0 !== n3 ? n3 : 0) - a3 < 300 && a3 > 300, c = {
        color: i2(),
        onChange: u,
        showOnTop: l2
      };
      r2(al, c, {
        anchor: o3,
        closeOnOuterClick: true,
        onClose: v,
        offsetTop: 18,
        offsetLeft: -8,
        height: 300
      });
    }
  }), Hr(e2, p2), Nt();
}
var ll = 1e3;
var cl = 100;
var dl = 100;
var ul = 2e4;
var vl = [{
  start: 0,
  end: cl
}];
var fl = 1048576;
var pl = 1048576;
var hl = 10485760;
var gl = "Insert or paste contents, enter [ insert a new array, enter { to insert a new object, or start typing to insert a new value";
var ml = "Open context menu (Click here, right click on the selection, or use the context menu button or Ctrl+Q)";
var bl = "hover-insert-inside";
var jl = "hover-insert-after";
var xl = "hover-collection";
var yl = "valid";
var wl = "repairable";
var kl = 336;
var Sl = 260;
var Cl = 100;
var zl = {
  [ls.asc]: "ascending",
  [ls.desc]: "descending"
};
function Ol(e2) {
  for (var n2 = sortBy_default(e2, (e3) => e3.start), t3 = [n2[0]], o2 = 0; o2 < n2.length; o2++) {
    var r2 = t3.length - 1, a2 = t3[r2], i2 = n2[o2];
    i2.start <= a2.end ? t3[r2] = {
      start: Math.min(a2.start, i2.start),
      end: Math.max(a2.end, i2.end)
    } : t3.push(i2);
  }
  return t3;
}
function Ml(e2) {
  return El(e2) + cl;
}
function El(e2) {
  return Math.floor(e2 / cl) * cl;
}
function Al(e2) {
  return !!e2 && ("space" === e2.type || true === e2.space);
}
function Rl(e2) {
  return !!e2 && ("separator" === e2.type || true === e2.separator);
}
function ql(e2) {
  return !!e2 && "label" === e2.type && "string" == typeof e2.text;
}
function Pl(e2) {
  return !!e2 && "function" == typeof e2.onClick;
}
function Tl(e2) {
  return !!e2 && "dropdown-button" === e2.type && Pl(e2.main) && Array.isArray(e2.items);
}
function Nl(e2) {
  return !!e2 && "row" === e2.type && Array.isArray(e2.items);
}
function Il(e2) {
  return !!e2 && "column" === e2.type && Array.isArray(e2.items);
}
function Ul(e2) {
  return pi(e2) && pi(e2.parseError);
}
function Dl(e2) {
  return pi(e2) && Array.isArray(e2.validationErrors);
}
function Jl(e2) {
  return pi(e2) && Array.isArray(e2.path) && "string" == typeof e2.message && "severity" in e2;
}
function Bl(e2) {
  return pi(e2) && Jl(e2) && "boolean" == typeof e2.isChildError;
}
function _l(e2) {
  return pi(e2) && "component" in e2 && pi(e2.props);
}
function Fl(e2) {
  return pi(e2) && "function" == typeof e2.action && pi(e2.props);
}
function Ll(e2) {
  return void 0 !== e2 && "object" === e2.type;
}
function Wl(e2) {
  return void 0 !== e2 && "array" === e2.type;
}
function Vl(e2) {
  return void 0 !== e2 && "value" === e2.type;
}
function $l(e2) {
  return Ll(e2) || Wl(e2);
}
function Hl(e2) {
  return void 0 !== e2 && Array.isArray(e2.searchResults);
}
function Ql(e2) {
  return !!e2 && "tree" === e2.type;
}
function Yl(e2) {
  return !!e2 && "text" === e2.type;
}
function Kl(e2) {
  return !!e2 && "mode" === e2.type;
}
function Zl(e2) {
  var {
    json: n2,
    expand: t3
  } = e2, o2 = function(e3) {
    var {
      json: n3,
      factory: t4
    } = e3;
    return Array.isArray(n3) ? t4.createArrayDocumentState() : pi(n3) ? t4.createObjectDocumentState() : void 0 !== n3 ? t4.createValueDocumentState() : void 0;
  }({
    json: n2,
    factory: ec
  });
  return t3 && o2 ? ic(n2, o2, [], t3) : o2;
}
function Xl() {
  var {
    expanded: e2
  } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
    expanded: false
  };
  return {
    type: "array",
    expanded: e2,
    visibleSections: vl,
    items: []
  };
}
function Gl() {
  var {
    expanded: e2
  } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
    expanded: false
  };
  return {
    type: "object",
    expanded: e2,
    properties: {}
  };
}
var ec = {
  createObjectDocumentState: Gl,
  createArrayDocumentState: Xl,
  createValueDocumentState: function() {
    return {
      type: "value"
    };
  }
};
function nc(e2, n2, t3, o2) {
  var {
    createObjectDocumentState: r2,
    createArrayDocumentState: a2,
    createValueDocumentState: i2
  } = o2;
  return function e3(n3, t4, o3) {
    if (Array.isArray(n3)) {
      var s2 = Wl(t4) ? t4 : a2();
      if (0 === o3.length) return s2;
      var l = ui(o3[0]), c = e3(n3[l], s2.items[l], o3.slice(1));
      return setIn(s2, ["items", o3[0]], c);
    }
    if (pi(n3)) {
      var d = Ll(t4) ? t4 : r2();
      if (0 === o3.length) return d;
      var u = o3[0], f = e3(n3[u], d.properties[u], o3.slice(1));
      return setIn(d, ["properties", u], f);
    }
    return Vl(t4) ? t4 : i2();
  }(e2, n2, t3);
}
function tc(e2, n2) {
  return oc(e2, n2, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], (e3, n3) => {
    if (void 0 !== e3 && void 0 !== n3) return Array.isArray(e3) ? Wl(n3) ? n3 : Xl({
      expanded: !!$l(n3) && n3.expanded
    }) : pi(e3) ? Ll(n3) ? n3 : Gl({
      expanded: !!$l(n3) && n3.expanded
    }) : Vl(n3) ? n3 : void 0;
  }, () => true);
}
function oc(e2, n2, t3, o2, a2) {
  var i2 = o2(e2, n2, t3);
  if (Array.isArray(e2) && Wl(i2) && a2(i2)) {
    var s2 = [];
    return rc(e2, i2.visibleSections, (n3) => {
      var r2 = t3.concat(String(n3)), l2 = oc(e2[n3], i2.items[n3], r2, o2, a2);
      void 0 !== l2 && (s2[n3] = l2);
    }), !Mi(s2, i2.items) ? r(r({}, i2), {}, {
      items: s2
    }) : i2;
  }
  if (pi(e2) && Ll(i2) && a2(i2)) {
    var l = {};
    return Object.keys(e2).forEach((n3) => {
      var r2 = t3.concat(n3), s3 = oc(e2[n3], i2.properties[n3], r2, o2, a2);
      void 0 !== s3 && (l[n3] = s3);
    }), !Mi(Object.values(l), Object.values(i2.properties)) ? r(r({}, i2), {}, {
      properties: l
    }) : i2;
  }
  return i2;
}
function rc(e2, n2, t3) {
  n2.forEach((n3) => {
    var {
      start: o2,
      end: r2
    } = n3;
    Ai(o2, Math.min(e2.length, r2), t3);
  });
}
function ac(e2, n2) {
  for (var t3 = e2, o2 = [], r2 = 0; r2 < n2.length; ) {
    if (Array.isArray(t3)) {
      var a2 = n2[r2];
      o2.push("items", a2), t3 = t3[ui(a2)];
    } else {
      if (!pi(t3)) throw new Error("Cannot convert path: Object or Array expected at index ".concat(r2));
      var i2 = n2[r2];
      o2.push("properties", i2), t3 = t3[i2];
    }
    r2++;
  }
  return o2;
}
function ic(e2, n2, t3, o2) {
  for (var a2 = n2, i2 = function(n3) {
    var o3 = t3.slice(0, n3);
    a2 = pc(e2, a2, o3, (e3, o4) => {
      var a3 = $l(o4) && !o4.expanded ? r(r({}, o4), {}, {
        expanded: true
      }) : o4;
      return Wl(a3) ? function(e4, n4) {
        if (function(e5, n5) {
          return e5.some((e6) => n5 >= e6.start && n5 < e6.end);
        }(e4.visibleSections, n4)) return e4;
        var t4 = El(n4), o5 = {
          start: t4,
          end: Ml(t4)
        };
        return r(r({}, e4), {}, {
          visibleSections: Ol(e4.visibleSections.concat(o5))
        });
      }(a3, ui(t3[n3])) : a3;
    });
  }, s2 = 0; s2 < t3.length; s2++) i2(s2);
  return pc(e2, a2, t3, (e3, n3) => function(e4, n4, t4, o3) {
    return oc(e4, n4, t4, (e5, n5, t5) => Array.isArray(e5) && o3(t5) ? Wl(n5) ? n5.expanded ? n5 : r(r({}, n5), {}, {
      expanded: true
    }) : Xl({
      expanded: true
    }) : pi(e5) && o3(t5) ? Ll(n5) ? n5.expanded ? n5 : r(r({}, n5), {}, {
      expanded: true
    }) : Gl({
      expanded: true
    }) : n5, (e5) => $l(e5) && e5.expanded);
  }(e3, n3, [], o2));
}
function sc(e2, n2, t3, o2) {
  return pc(e2, n2, t3, (e3, n3) => o2 ? function(e4, n4, t4) {
    return oc(e4, n4, t4, (e5, n5) => lc(n5), () => true);
  }(e3, n3, t3) : lc(n3));
}
function lc(e2) {
  return Wl(e2) && e2.expanded ? r(r({}, e2), {}, {
    expanded: false,
    visibleSections: vl
  }) : Ll(e2) && e2.expanded ? r(r({}, e2), {}, {
    expanded: false
  }) : e2;
}
function cc(e2, n2, t3) {
  var o2 = {
    json: e2,
    documentState: n2
  }, r2 = t3.reduce((e3, n3) => ({
    json: immutableJSONPatch(e3.json, [n3]),
    documentState: dc(e3.json, e3.documentState, n3)
  }), o2);
  return {
    json: r2.json,
    documentState: tc(r2.json, r2.documentState)
  };
}
function dc(e2, n2, t3) {
  if (isJSONPatchAdd(t3)) return hc(e2, n2, t3, void 0);
  if (isJSONPatchRemove(t3)) return gc(e2, n2, t3);
  if (isJSONPatchReplace(t3)) {
    var o2 = parsePath(e2, t3.path), r2 = bc(e2, n2, o2);
    return r2 ? fc(e2, n2, o2, {
      type: "value",
      enforceString: r2
    }) : n2;
  }
  return isJSONPatchCopy(t3) || isJSONPatchMove(t3) ? function(e3, n3, t4) {
    if (isJSONPatchMove(t4) && t4.from === t4.path) return n3;
    var o3 = n3, r3 = parsePath(e3, t4.from), a2 = uc(e3, o3, r3);
    isJSONPatchMove(t4) && (o3 = gc(e3, o3, {
      path: t4.from
    }));
    return o3 = hc(e3, o3, {
      path: t4.path
    }, a2), o3;
  }(e2, n2, t3) : n2;
}
function uc(e2, n2, t3) {
  try {
    return getIn(n2, ac(e2, t3));
  } catch (e3) {
    return;
  }
}
function vc(e2, n2, t3, o2, r2) {
  var a2 = nc(e2, n2, t3, r2);
  return updateIn(a2, ac(e2, t3), (n3) => {
    var r3 = getIn(e2, t3);
    return o2(r3, n3);
  });
}
function fc(e2, n2, t3, o2) {
  return function(e3, n3, t4, o3, r2) {
    var a2 = nc(e3, n3, t4, r2);
    return setIn(a2, ac(e3, t4), o3);
  }(e2, n2, t3, o2, ec);
}
function pc(e2, n2, t3, o2) {
  return vc(e2, n2, t3, o2, ec);
}
function hc(e2, n2, t3, o2) {
  var a2 = parsePath(e2, t3.path), i2 = n2;
  return i2 = pc(e2, i2, initial_default(a2), (e3, n3) => {
    if (!Wl(n3)) return n3;
    var t4 = ui(last_default(a2)), {
      items: i3,
      visibleSections: s2
    } = n3;
    return r(r({}, n3), {}, {
      items: t4 < i3.length ? Ni(i3, t4, void 0 !== o2 ? [o2] : Array(1)) : i3,
      visibleSections: mc(s2, t4, 1)
    });
  }), fc(e2, i2, a2, o2);
}
function gc(e2, n2, t3) {
  var o2 = parsePath(e2, t3.path), a2 = initial_default(o2), i2 = getIn(e2, a2);
  return Array.isArray(i2) ? pc(e2, n2, a2, (e3, n3) => {
    if (!Wl(n3)) return n3;
    var t4 = ui(last_default(o2)), {
      items: a3,
      visibleSections: i3
    } = n3;
    return r(r({}, n3), {}, {
      items: a3.slice(0, t4).concat(a3.slice(t4 + 1)),
      visibleSections: mc(i3, t4, -1)
    });
  }) : function(e3, n3, t4) {
    var o3 = ac(e3, t4);
    return existsIn(n3, o3) ? deleteIn(n3, ac(e3, t4)) : n3;
  }(e2, n2, o2);
}
function mc(e2, n2, t3) {
  return function(e3) {
    var n3 = e3.slice(0), t4 = 1;
    for (; t4 < n3.length; ) n3[t4 - 1].end === n3[t4].start && (n3[t4 - 1] = {
      start: n3[t4 - 1].start,
      end: n3[t4].end
    }, n3.splice(t4)), t4++;
    return n3;
  }(e2.map((e3) => ({
    start: e3.start > n2 ? e3.start + t3 : e3.start,
    end: e3.end > n2 ? e3.end + t3 : e3.end
  })));
}
function bc(e2, n2, t3) {
  var o2, r2 = getIn(e2, t3), a2 = uc(e2, n2, t3), i2 = Vl(a2) ? a2.enforceString : void 0;
  return "boolean" == typeof i2 ? i2 : "string" == typeof (o2 = r2) && "string" != typeof Si(o2, JSON);
}
function jc(e2, n2) {
  var t3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o2 = e2.indexOf(n2);
  return -1 !== o2 ? t3 ? e2.slice(o2) : e2.slice(o2 + 1) : [];
}
function xc(e2, n2) {
  var t3 = [];
  return function e3(n3, o2, r2) {
    t3.push(r2), isJSONArray(n3) && Wl(o2) && o2.expanded && rc(n3, o2.visibleSections, (t4) => {
      e3(n3[t4], o2.items[t4], r2.concat(String(t4)));
    }), isJSONObject(n3) && Ll(o2) && o2.expanded && Object.keys(n3).forEach((t4) => {
      e3(n3[t4], o2.properties[t4], r2.concat(t4));
    });
  }(e2, n2, []), t3;
}
function yc(e2, n2) {
  var t3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], o2 = [];
  return function r2(a2, i2) {
    o2.push({
      path: i2,
      type: as.value
    });
    var s2 = uc(e2, n2, i2);
    if (a2 && $l(s2) && s2.expanded) {
      if (t3 && o2.push({
        path: i2,
        type: as.inside
      }), isJSONArray(a2)) {
        var l = Wl(s2) ? s2.visibleSections : vl;
        rc(a2, l, (e3) => {
          var n3 = i2.concat(String(e3));
          r2(a2[e3], n3), t3 && o2.push({
            path: n3,
            type: as.after
          });
        });
      }
      if (isJSONObject(a2)) Object.keys(a2).forEach((e3) => {
        var n3 = i2.concat(e3);
        o2.push({
          path: n3,
          type: as.key
        }), r2(a2[e3], n3), t3 && o2.push({
          path: n3,
          type: as.after
        });
      });
    }
  }(e2, []), o2;
}
function wc(e2, n2, t3) {
  var o2 = xc(e2, n2), r2 = o2.map(compileJSONPointer).indexOf(compileJSONPointer(t3));
  if (-1 !== r2 && r2 < o2.length - 1) return o2[r2 + 1];
}
function kc(e2, n2, t3) {
  var o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10240;
  return ic(e2, n2, t3, Ki({
    json: getIn(e2, t3)
  }, o2) ? Cc : Oc);
}
function Sc(e2, n2, t3) {
  var o2 = uc(e2, n2, t3);
  return !!$l(o2) && o2.expanded ? n2 : kc(e2, n2, t3);
}
function Cc(e2) {
  return 0 === e2.length || 1 === e2.length && "0" === e2[0];
}
function zc(e2) {
  return 0 === e2.length;
}
function Oc() {
  return true;
}
function Mc() {
  return false;
}
function Ec(e2) {
  return e2 && e2.type === rs.after || false;
}
function Ac(e2) {
  return e2 && e2.type === rs.inside || false;
}
function Rc(e2) {
  return e2 && e2.type === rs.key || false;
}
function qc(e2) {
  return e2 && e2.type === rs.value || false;
}
function Pc(e2) {
  return e2 && e2.type === rs.multi || false;
}
function Tc(e2) {
  return Pc(e2) && isEqual_default(e2.focusPath, e2.anchorPath);
}
function Nc(e2) {
  return Pc(e2) || Ec(e2) || Ac(e2) || Rc(e2) || qc(e2);
}
function Ic(e2) {
  return e2 && e2.type === rs.text || false;
}
function Uc(e2, n2) {
  var t3 = [];
  return function(e3, n3, t4) {
    if (!n3) return;
    var o2 = fd(n3), r2 = vd(n3);
    if (isEqual_default(o2, r2)) return t4(o2);
    if (void 0 === e3) return;
    var a2 = Vc(o2, r2);
    if (o2.length === a2.length || r2.length === a2.length) return t4(a2);
    var i2 = td(o2, r2), s2 = Jc(e3, i2), l = Bc(e3, i2), c = ud(e3, i2, s2), u = ud(e3, i2, l);
    if (-1 === c || -1 === u) return;
    var v = getIn(e3, a2);
    if (isJSONObject(v)) {
      for (var f = Object.keys(v), p2 = c; p2 <= u; p2++) {
        var h2 = t4(a2.concat(f[p2]));
        if (void 0 !== h2) return h2;
      }
      return;
    }
    if (isJSONArray(v)) {
      for (var g = c; g <= u; g++) {
        var m = t4(a2.concat(String(g)));
        if (void 0 !== m) return m;
      }
      return;
    }
    throw new Error("Failed to create selection");
  }(e2, n2, (e3) => {
    t3.push(e3);
  }), t3;
}
function Dc(e2) {
  return Ac(e2) ? e2.path : initial_default(vd(e2));
}
function Jc(e2, n2) {
  if (!Pc(n2)) return n2.path;
  var t3 = ud(e2, n2, n2.anchorPath);
  return ud(e2, n2, n2.focusPath) < t3 ? n2.focusPath : n2.anchorPath;
}
function Bc(e2, n2) {
  if (!Pc(n2)) return n2.path;
  var t3 = ud(e2, n2, n2.anchorPath);
  return ud(e2, n2, n2.focusPath) > t3 ? n2.focusPath : n2.anchorPath;
}
function _c(e2, n2, t3) {
  var o2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  if (t3) {
    var r2 = o2 ? vd(t3) : Jc(e2, t3), a2 = function(e3, n3, t4) {
      var o3 = xc(e3, n3), r3 = o3.map(compileJSONPointer), a3 = compileJSONPointer(t4), i3 = r3.indexOf(a3);
      if (-1 !== i3 && i3 > 0) return o3[i3 - 1];
    }(e2, n2, r2);
    if (o2) return Ac(t3) || Ec(t3) ? void 0 !== a2 ? td(r2, r2) : void 0 : void 0 !== a2 ? td(fd(t3), a2) : void 0;
    if (Ec(t3)) return Xc(r2);
    if (Ac(t3)) return Xc(r2);
    if (Rc(t3)) {
      if (void 0 === a2 || 0 === a2.length) return;
      var i2 = initial_default(a2), s2 = getIn(e2, i2);
      return Array.isArray(s2) || isEmpty_default(a2) ? Xc(a2) : Kc(a2);
    }
    return qc(t3), void 0 !== a2 ? Xc(a2) : void 0;
  }
}
function Fc(e2, n2, t3, o2) {
  if (!t3) return {
    caret: void 0,
    previous: void 0,
    next: void 0
  };
  var r2 = yc(e2, n2, o2), a2 = r2.findIndex((e3) => isEqual_default(e3.path, vd(t3)) && String(e3.type) === String(t3.type));
  return {
    caret: -1 !== a2 ? r2[a2] : void 0,
    previous: -1 !== a2 && a2 > 0 ? r2[a2 - 1] : void 0,
    next: -1 !== a2 && a2 < r2.length - 1 ? r2[a2 + 1] : void 0
  };
}
function Lc(e2, n2) {
  for (var t3 = xc(e2, n2), o2 = 0; o2 < t3.length - 1 && t3[o2 + 1].length > t3[o2].length; ) o2++;
  var r2 = t3[o2];
  return void 0 === r2 || 0 === r2.length || Array.isArray(getIn(e2, initial_default(r2))) ? Xc(r2) : Kc(r2);
}
function Wc(e2, n2) {
  if (1 === n2.length) {
    var t3 = head_default(n2);
    if ("replace" === t3.op) return Xc(parsePath(e2, t3.path));
  }
  if (!isEmpty_default(n2) && n2.every((e3) => "move" === e3.op)) {
    var o2 = head_default(n2), r2 = n2.slice(1);
    if ((isJSONPatchCopy(o2) || isJSONPatchMove(o2)) && o2.from !== o2.path && r2.every((e3) => (isJSONPatchCopy(e3) || isJSONPatchMove(e3)) && e3.from === e3.path)) return Kc(parsePath(e2, o2.path));
  }
  var a2 = n2.filter((e3) => "test" !== e3.op && "remove" !== e3.op && ("move" !== e3.op || e3.from !== e3.path) && "string" == typeof e3.path).map((n3) => parsePath(e2, n3.path));
  if (!isEmpty_default(a2)) return {
    type: rs.multi,
    anchorPath: head_default(a2),
    focusPath: last_default(a2)
  };
}
function Vc(e2, n2) {
  for (var t3 = 0; t3 < e2.length && t3 < n2.length && e2[t3] === n2[t3]; ) t3++;
  return e2.slice(0, t3);
}
function $c(e2) {
  return Rc(e2) || qc(e2) || Tc(e2);
}
function Hc(e2, n2) {
  return $c(n2) && hi(getIn(e2, vd(n2))) ? vd(n2) : initial_default(vd(n2));
}
function Qc(e2, n2) {
  if (e2.length < n2.length) return false;
  for (var t3 = 0; t3 < n2.length; t3++) if (e2[t3] !== n2[t3]) return false;
  return true;
}
function Yc(e2) {
  if (rd(e2)) {
    var {
      type: n2,
      path: t3
    } = e2;
    return {
      type: n2,
      path: t3
    };
  }
  return e2;
}
function Kc(e2) {
  return {
    type: rs.key,
    path: e2
  };
}
function Zc(e2, n2) {
  return {
    type: rs.key,
    path: e2,
    edit: true,
    initialValue: n2
  };
}
function Xc(e2) {
  return {
    type: rs.value,
    path: e2
  };
}
function Gc(e2, n2) {
  return {
    type: rs.value,
    path: e2,
    edit: true,
    initialValue: n2
  };
}
function ed(e2) {
  return {
    type: rs.inside,
    path: e2
  };
}
function nd(e2) {
  return {
    type: rs.after,
    path: e2
  };
}
function td(e2, n2) {
  var t3 = Vc(e2, n2), o2 = e2.length > t3.length && n2.length > t3.length;
  return {
    type: rs.multi,
    anchorPath: o2 ? t3.concat(e2[t3.length]) : t3,
    focusPath: o2 ? t3.concat(n2[t3.length]) : t3
  };
}
function od(e2, n2, t3, o2) {
  if (Rc(n2)) return String(last_default(n2.path));
  if (qc(n2)) {
    var r2 = getIn(e2, n2.path);
    return "string" == typeof r2 ? r2 : o2.stringify(r2, null, t3);
  }
  if (Pc(n2)) {
    if (isEmpty_default(n2.focusPath)) return o2.stringify(e2, null, t3);
    var a2 = Dc(n2), i2 = getIn(e2, a2);
    if (Array.isArray(i2)) {
      if (Tc(n2)) {
        var s2 = getIn(e2, n2.focusPath);
        return o2.stringify(s2, null, t3);
      }
      return Uc(e2, n2).map((n3) => {
        var r3 = getIn(e2, n3);
        return "".concat(o2.stringify(r3, null, t3), ",");
      }).join("\n");
    }
    return Uc(e2, n2).map((n3) => {
      var r3 = last_default(n3), a3 = getIn(e2, n3);
      return "".concat(o2.stringify(r3), ": ").concat(o2.stringify(a3, null, t3), ",");
    }).join("\n");
  }
}
function rd(e2) {
  return (Rc(e2) || qc(e2)) && true === e2.edit;
}
function ad(e2) {
  return Rc(e2) || qc(e2) || Pc(e2);
}
function id(e2) {
  return Rc(e2) || qc(e2) || Tc(e2);
}
function sd(e2) {
  switch (e2.type) {
    case as.key:
      return Kc(e2.path);
    case as.value:
      return Xc(e2.path);
    case as.after:
      return nd(e2.path);
    case as.inside:
      return ed(e2.path);
  }
}
function ld(e2, n2) {
  switch (e2) {
    case rs.key:
      return Kc(n2);
    case rs.value:
      return Xc(n2);
    case rs.after:
      return nd(n2);
    case rs.inside:
      return ed(n2);
    case rs.multi:
    case rs.text:
      return td(n2, n2);
  }
}
function cd(e2, n2, t3) {
  if (n2) return dd(e2, n2, t3) || Qc(Pc(n2) ? initial_default(n2.focusPath) : n2.path, t3) ? n2 : void 0;
}
function dd(e2, n2, t3) {
  if (void 0 === e2 || !n2) return false;
  if (Rc(n2) || Ac(n2) || Ec(n2)) return isEqual_default(n2.path, t3);
  if (qc(n2)) return Qc(t3, n2.path);
  if (Pc(n2)) {
    var o2 = Jc(e2, n2), r2 = Bc(e2, n2), a2 = initial_default(n2.focusPath);
    if (!Qc(t3, a2) || t3.length <= a2.length) return false;
    var i2 = ud(e2, n2, o2), s2 = ud(e2, n2, r2), l = ud(e2, n2, t3);
    return -1 !== l && l >= i2 && l <= s2;
  }
  return false;
}
function ud(e2, n2, t3) {
  var o2 = initial_default(n2.focusPath);
  if (!Qc(t3, o2) || t3.length <= o2.length) return -1;
  var r2 = t3[o2.length], a2 = getIn(e2, o2);
  if (isJSONObject(a2)) return Object.keys(a2).indexOf(r2);
  if (isJSONArray(a2)) {
    var i2 = ui(r2);
    if (i2 < a2.length) return i2;
  }
  return -1;
}
function vd(e2) {
  return Pc(e2) ? e2.focusPath : e2.path;
}
function fd(e2) {
  return Pc(e2) ? e2.anchorPath : e2.path;
}
function pd() {
  for (var e2 = [], n2 = arguments.length, t3 = new Array(n2), o2 = 0; o2 < n2; o2++) t3[o2] = arguments[o2];
  for (var r2 of t3) if ("string" == typeof r2 && e2.push(r2), r2 && "object" == typeof r2) for (var a2 in r2) Object.hasOwnProperty.call(r2, a2) && r2[a2] && e2.push(a2);
  return e2.join(" ");
}
function hd(e2, n2, t3) {
  return pd("jse-value", "jse-" + yi(e2, t3), {
    "jse-url": ki(e2),
    "jse-empty": "string" == typeof e2 && 0 === e2.length,
    "jse-table-cell": n2 === os.table
  });
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-value.jse-string.svelte-f9kmxj {\n  color: var(--jse-value-color-string, #008000);\n}\n.jse-value.jse-object.svelte-f9kmxj, .jse-value.jse-array.svelte-f9kmxj {\n  min-width: 16px;\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n}\n.jse-value.jse-number.svelte-f9kmxj {\n  color: var(--jse-value-color-number, #ee422e);\n}\n.jse-value.jse-boolean.svelte-f9kmxj {\n  color: var(--jse-value-color-boolean, #ff8c00);\n}\n.jse-value.jse-null.svelte-f9kmxj {\n  color: var(--jse-value-color-null, #004ed0);\n}\n.jse-value.jse-invalid.svelte-f9kmxj {\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-value.jse-url.svelte-f9kmxj {\n  color: var(--jse-value-color-url, #008000);\n  text-decoration: underline;\n}\n\ndiv.jse-editable-div.svelte-f9kmxj {\n  min-width: 2em;\n  padding: 0 5px;\n  box-sizing: border-box;\n  outline: none;\n  border-radius: 1px;\n  vertical-align: top;\n  cursor: text !important;\n  word-break: normal;\n  white-space: pre-wrap;\n  overflow-wrap: anywhere;\n}\ndiv.jse-editable-div.jse-short-text.svelte-f9kmxj {\n  overflow-wrap: normal;\n}\ndiv.jse-editable-div.jse-table-cell.svelte-f9kmxj {\n  overflow-wrap: normal;\n  white-space: nowrap;\n}\ndiv.jse-editable-div[contenteditable=true].svelte-f9kmxj {\n  outline: var(--jse-edit-outline, 2px solid #656565);\n  background: var(--jse-background-color, #fff);\n  position: relative;\n  display: inline-block;\n  border-radius: 0;\n  z-index: 3;\n}\ndiv.jse-editable-div.jse-empty.svelte-f9kmxj:not(:focus) {\n  outline: 1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  -moz-outline-radius: 2px;\n}\ndiv.jse-editable-div.jse-empty.svelte-f9kmxj::after {\n  pointer-events: none;\n  color: var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n}');
var gd = Lr('<div role="textbox" tabindex="0" contenteditable="true" spellcheck="false"></div>');
function md(e2, n2) {
  Tt(n2, false);
  var t3 = ii("jsoneditor:EditableDiv"), o2 = ai(n2, "value", 9), r2 = ai(n2, "initialValue", 9), a2 = ai(n2, "shortText", 9, false), i2 = ai(n2, "label", 9), s2 = ai(n2, "onChange", 9), l = ai(n2, "onCancel", 9), c = ai(n2, "onFind", 9), d = ai(n2, "onPaste", 9, noop_default), u = ai(n2, "onValueClass", 9, () => ""), v = Kt(void 0, true), f = Kt(void 0, true), p2 = false;
  function h2() {
    return Sr(v) ? function(e3) {
      return e3.replace(/\n$/, "");
    }(Sr(v).innerText) : "";
  }
  function g(e3) {
    Sr(v) && Zt(v, Sr(v).innerText = ws(e3));
  }
  ta(() => {
    t3("onMount", {
      value: o2(),
      initialValue: r2()
    }), g(void 0 !== r2() ? r2() : o2()), Sr(v) && function(e3) {
      if (null != e3.firstChild) {
        var n3 = document.createRange(), t4 = window.getSelection();
        n3.setStart(e3, 1), n3.collapse(true), null == t4 || t4.removeAllRanges(), null == t4 || t4.addRange(n3);
      } else e3.focus();
    }(Sr(v));
  }), oa(() => {
    var e3 = h2();
    t3("onDestroy", {
      closed: p2,
      value: o2(),
      newValue: e3
    }), p2 || e3 === o2() || s2()(e3, cs.no);
  }), xo(() => (Ar(u()), Ar(o2())), () => {
    Xt(f, u()(o2()));
  }), yo(), Ka(true);
  var m = gd();
  Ha(m, (e3) => Xt(v, e3), () => Sr(v)), ko((e3) => {
    Ia(m, "aria-label", i2()), Ca(m, 1, e3, "svelte-f9kmxj");
  }, [() => ya((Ar(pd), Sr(f), Ar(a2()), Or(() => pd("jse-editable-div", Sr(f), {
    "jse-short-text": a2()
  }))))], Lt), Dr("input", m, function() {
    var e3 = h2();
    "" === e3 && g(""), Xt(f, u()(e3));
  }), Dr("keydown", m, function(e3) {
    e3.stopPropagation();
    var n3 = Ns(e3);
    if ("Escape" === n3 && (e3.preventDefault(), p2 = true, l()()), "Enter" === n3 || "Tab" === n3) {
      e3.preventDefault(), p2 = true;
      var t4 = h2();
      s2()(t4, cs.nextInside);
    }
    "Ctrl+F" === n3 && (e3.preventDefault(), c()(false)), "Ctrl+H" === n3 && (e3.preventDefault(), c()(true));
  }), Dr("paste", m, function(e3) {
    if (e3.stopPropagation(), d() && e3.clipboardData) {
      var n3 = e3.clipboardData.getData("text/plain");
      d()(n3);
    }
  }), Dr("blur", m, function() {
    var e3 = document.hasFocus(), n3 = h2();
    t3("handleBlur", {
      hasFocus: e3,
      closed: p2,
      value: o2(),
      newValue: n3
    }), document.hasFocus() && !p2 && (p2 = true, n3 !== o2() && s2()(n3, cs.self));
  }), Hr(e2, m), Nt();
}
function bd(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "path", 9), o2 = ai(n2, "value", 9), r2 = ai(n2, "selection", 9), a2 = ai(n2, "mode", 9), i2 = ai(n2, "parser", 9), s2 = ai(n2, "normalization", 9), l = ai(n2, "enforceString", 9), d = ai(n2, "onPatch", 9), u = ai(n2, "onPasteJson", 9), v = ai(n2, "onSelect", 9), f = ai(n2, "onFind", 9), p2 = ai(n2, "focus", 9), h2 = ai(n2, "findNextInside", 9);
  function g(e3) {
    return l() ? e3 : Si(e3, i2());
  }
  function m() {
    v()(Xc(t3())), p2()();
  }
  Ka(true);
  var b = Lt(() => (Ar(s2()), Ar(o2()), Or(() => s2().escapeValue(o2())))), j = Lt(() => (Ar(rd), Ar(r2()), Or(() => rd(r2()) ? r2().initialValue : void 0)));
  md(e2, {
    get value() {
      return Sr(b);
    },
    get initialValue() {
      return Sr(j);
    },
    label: "Edit value",
    onChange: function(e3, n3) {
      d()([{
        op: "replace",
        path: compileJSONPointer(t3()),
        value: g(s2().unescapeValue(e3))
      }], (e4, o3, r3) => {
        if (!r3 || isEqual_default(t3(), vd(r3))) return {
          state: o3,
          selection: n3 === cs.nextInside ? h2()(t3()) : Xc(t3())
        };
      }), p2()();
    },
    onCancel: m,
    onPaste: function(e3) {
      try {
        var n3 = i2().parse(e3);
        hi(n3) && u()({
          path: t3(),
          contents: n3,
          onPasteAsJson: () => {
            m();
            var e4 = [{
              op: "replace",
              path: compileJSONPointer(t3()),
              value: n3
            }];
            d()(e4, (e5, n4) => ({
              state: kc(e5, n4, t3())
            }));
          }
        });
      } catch (e4) {
      }
    },
    get onFind() {
      return f();
    },
    onValueClass: function(e3) {
      return hd(g(s2().unescapeValue(e3)), a2(), i2());
    }
  }), Nt();
}
function jd(e2, n2, t3) {
  var o2 = initial_default(n2), r2 = getIn(e2, o2);
  if (isJSONArray(r2)) {
    var a2 = ui(last_default(n2));
    return t3.map((e3, n3) => ({
      op: "add",
      path: compileJSONPointer(o2.concat(String(a2 + n3))),
      value: e3.value
    }));
  }
  if (isJSONObject(r2)) {
    var i2 = last_default(n2), s2 = Object.keys(r2), l = void 0 !== i2 ? jc(s2, i2, true) : [];
    return [...t3.map((e3) => {
      var n3 = Ws(e3.key, s2);
      return {
        op: "add",
        path: compileJSONPointer(o2.concat(n3)),
        value: e3.value
      };
    }), ...l.map((e3) => zd(o2, e3))];
  }
  throw new Error("Cannot create insert operations: parent must be an Object or Array");
}
function xd(e2, n2, t3) {
  var o2 = getIn(e2, n2);
  if (Array.isArray(o2)) {
    var r2 = o2.length;
    return t3.map((e3, t4) => ({
      op: "add",
      path: compileJSONPointer(n2.concat(String(r2 + t4))),
      value: e3.value
    }));
  }
  return t3.map((e3) => {
    var t4 = Ws(e3.key, Object.keys(o2));
    return {
      op: "add",
      path: compileJSONPointer(n2.concat(t4)),
      value: e3.value
    };
  });
}
function yd(e2, n2, t3, o2) {
  var r2 = Ws(o2, n2.filter((e3) => e3 !== t3)), a2 = jc(n2, t3, false);
  return [{
    op: "move",
    from: compileJSONPointer(e2.concat(t3)),
    path: compileJSONPointer(e2.concat(r2))
  }, ...a2.map((n3) => zd(e2, n3))];
}
function wd(e2, n2) {
  var t3 = last_default(n2);
  if (isEmpty_default(t3)) throw new Error("Cannot duplicate root object");
  var o2 = initial_default(t3), r2 = last_default(t3), a2 = getIn(e2, o2);
  if (isJSONArray(a2)) {
    var i2 = last_default(n2), s2 = i2 ? ui(last_default(i2)) + 1 : 0;
    return [...n2.map((e3, n3) => ({
      op: "copy",
      from: compileJSONPointer(e3),
      path: compileJSONPointer(o2.concat(String(n3 + s2)))
    }))];
  }
  if (isJSONObject(a2)) {
    var l = Object.keys(a2), u = void 0 !== r2 ? jc(l, r2, false) : [];
    return [...n2.map((e3) => {
      var n3 = Ws(last_default(e3), l);
      return {
        op: "copy",
        from: compileJSONPointer(e3),
        path: compileJSONPointer(o2.concat(n3))
      };
    }), ...u.map((e3) => zd(o2, e3))];
  }
  throw new Error("Cannot create duplicate operations: parent must be an Object or Array");
}
function kd(e2, n2) {
  if (qc(n2)) return [{
    op: "move",
    from: compileJSONPointer(n2.path),
    path: ""
  }];
  if (!Pc(n2)) throw new Error("Cannot create extract operations: parent must be an Object or Array");
  var t3 = initial_default(n2.focusPath), o2 = getIn(e2, t3);
  if (isJSONArray(o2)) {
    var r2 = Uc(e2, n2).map((e3) => {
      var n3 = ui(last_default(e3));
      return o2[n3];
    });
    return [{
      op: "replace",
      path: "",
      value: r2
    }];
  }
  if (isJSONObject(o2)) {
    var a2 = {};
    return Uc(e2, n2).forEach((e3) => {
      var n3 = String(last_default(e3));
      a2[n3] = o2[n3];
    }), [{
      op: "replace",
      path: "",
      value: a2
    }];
  }
  throw new Error("Cannot extract: unsupported type of selection " + JSON.stringify(n2));
}
function Sd(e2, n2, t3, o2) {
  if (Rc(n2)) {
    var r2 = Ui(t3, o2), a2 = initial_default(n2.path), i2 = getIn(e2, a2);
    return yd(a2, Object.keys(i2), last_default(n2.path), "string" == typeof r2 ? r2 : t3);
  }
  if (qc(n2) || Pc(n2) && isEmpty_default(n2.focusPath)) try {
    return [{
      op: "replace",
      path: compileJSONPointer(vd(n2)),
      value: Di(t3, (e3) => Ii(e3, o2))
    }];
  } catch (e3) {
    return [{
      op: "replace",
      path: compileJSONPointer(vd(n2)),
      value: t3
    }];
  }
  if (Pc(n2)) {
    var s2 = Od(t3, o2);
    return function(e3, n3, t4) {
      var o3 = head_default(n3), r3 = initial_default(o3), a3 = getIn(e3, r3);
      if (isJSONArray(a3)) {
        var i3 = head_default(n3), s3 = i3 ? ui(last_default(i3)) : 0;
        return [...Cd(n3), ...t4.map((e4, n4) => ({
          op: "add",
          path: compileJSONPointer(r3.concat(String(n4 + s3))),
          value: e4.value
        }))];
      }
      if (isJSONObject(a3)) {
        var l2 = last_default(n3), u2 = initial_default(l2), v2 = last_default(l2), f2 = Object.keys(a3), p3 = void 0 !== v2 ? jc(f2, v2, false) : [], h3 = new Set(n3.map((e4) => last_default(e4))), g2 = f2.filter((e4) => !h3.has(e4));
        return [...Cd(n3), ...t4.map((e4) => {
          var n4 = Ws(e4.key, g2);
          return {
            op: "add",
            path: compileJSONPointer(u2.concat(n4)),
            value: e4.value
          };
        }), ...p3.map((e4) => zd(u2, e4))];
      }
      throw new Error("Cannot create replace operations: parent must be an Object or Array");
    }(e2, Uc(e2, n2), s2);
  }
  if (Ec(n2)) {
    var l = Od(t3, o2), u = n2.path, v = initial_default(u), f = getIn(e2, v);
    if (isJSONArray(f)) {
      var p2 = ui(last_default(u));
      return jd(e2, v.concat(String(p2 + 1)), l);
    }
    if (isJSONObject(f)) {
      var h2 = String(last_default(u)), g = Object.keys(f);
      if (isEmpty_default(g) || last_default(g) === h2) return xd(e2, v, l);
      var m = g.indexOf(h2), b = g[m + 1];
      return jd(e2, v.concat(b), l);
    }
    throw new Error("Cannot create insert operations: parent must be an Object or Array");
  }
  if (Ac(n2)) {
    var j = Od(t3, o2), w = n2.path, k = getIn(e2, w);
    if (isJSONArray(k)) return jd(e2, w.concat("0"), j);
    if (isJSONObject(k)) {
      var S = Object.keys(k);
      if (isEmpty_default(S)) return xd(e2, w, j);
      var C3 = head_default(S);
      return jd(e2, w.concat(C3), j);
    }
    throw new Error("Cannot create insert operations: parent must be an Object or Array");
  }
  throw new Error("Cannot insert: unsupported type of selection " + JSON.stringify(n2));
}
function Cd(e2) {
  return e2.map((e3) => ({
    op: "remove",
    path: compileJSONPointer(e3)
  })).reverse();
}
function zd(e2, n2) {
  return {
    op: "move",
    from: compileJSONPointer(e2.concat(n2)),
    path: compileJSONPointer(e2.concat(n2))
  };
}
function Od(e2, n2) {
  var t3 = /^\s*{/.test(e2), o2 = /^\s*\[/.test(e2), r2 = Ui(e2, n2), a2 = void 0 !== r2 ? r2 : Di(e2, (e3) => Ii(e3, n2));
  return t3 && pi(a2) || o2 && Array.isArray(a2) ? [{
    key: "New item",
    value: a2
  }] : Array.isArray(a2) ? a2.map((e3, n3) => ({
    key: "New item " + n3,
    value: e3
  })) : pi(a2) ? Object.keys(a2).map((e3) => ({
    key: e3,
    value: a2[e3]
  })) : [{
    key: "New item",
    value: a2
  }];
}
function Md(e2, n2) {
  if (Rc(n2)) {
    var t3 = initial_default(n2.path), o2 = getIn(e2, t3), r2 = yd(t3, Object.keys(o2), last_default(n2.path), "");
    return {
      operations: r2,
      newSelection: Wc(e2, r2)
    };
  }
  if (qc(n2)) return {
    operations: [{
      op: "replace",
      path: compileJSONPointer(n2.path),
      value: ""
    }],
    newSelection: n2
  };
  if (Pc(n2)) {
    var a2 = Uc(e2, n2), i2 = Cd(a2), s2 = last_default(a2);
    if (isEmpty_default(s2)) {
      return {
        operations: [{
          op: "replace",
          path: "",
          value: ""
        }],
        newSelection: Xc([])
      };
    }
    var l = initial_default(s2), u = getIn(e2, l);
    if (isJSONArray(u)) {
      var v = head_default(a2), f = ui(last_default(v));
      return {
        operations: i2,
        newSelection: 0 === f ? ed(l) : nd(l.concat(String(f - 1)))
      };
    }
    if (isJSONObject(u)) {
      var p2 = Object.keys(u), h2 = head_default(a2), g = last_default(h2), m = p2.indexOf(g), b = p2[m - 1];
      return {
        operations: i2,
        newSelection: 0 === m ? ed(l) : nd(l.concat(b))
      };
    }
    throw new Error("Cannot create remove operations: parent must be an Object or Array");
  }
  throw new Error("Cannot remove: unsupported type of selection " + JSON.stringify(n2));
}
function Ed(e2, n2) {
  var t3 = function(e3, n3) {
    if (isEmpty_default(n3) || !n3.every(isJSONPatchMove)) return n3;
    var t4 = [];
    for (var o2 of n3) {
      var r2 = Ad(parseJSONPointer(o2.from)), a2 = Ad(parseJSONPointer(o2.path));
      if (!r2 || !a2) return n3;
      t4.push({
        from: r2,
        path: a2,
        operation: o2
      });
    }
    var i2 = t4[0].path.parent, s2 = getIn(e3, i2);
    if (!isJSONObject(s2)) return n3;
    if (!t4.every((e4) => function(e5, n4) {
      return isEqual_default(e5.from.parent, n4) && isEqual_default(e5.path.parent, n4);
    }(e4, i2))) return n3;
    var c = function(e4, n4) {
      var t5 = Object.keys(n4), o3 = t5.slice();
      for (var r3 of e4) {
        var a3 = o3.indexOf(r3.from.key);
        -1 !== a3 && (o3.splice(a3, 1), o3.push(r3.path.key));
      }
      var i3 = 0;
      for (; i3 < t5.length && t5[i3] === o3[i3]; ) i3++;
      return o3[i3];
    }(t4, e3), u = (e4) => e4.operation, v = t4.filter((e4) => e4.operation.from !== e4.operation.path);
    return v.some((e4) => e4.path.key === c) ? v.map(u) : [zd(i2, c), ...v.map(u)];
  }(e2, n2);
  return revertJSONPatch(e2, t3, {
    before: (e3, n3, t4) => {
      if (isJSONPatchRemove(n3)) {
        var o2 = parseJSONPointer(n3.path);
        return {
          revertOperations: [...t4, ...Rd(e3, o2)]
        };
      }
      if (isJSONPatchMove(n3)) {
        var r2 = parseJSONPointer(n3.from);
        return {
          revertOperations: n3.from === n3.path ? [n3, ...Rd(e3, r2)] : [...t4, ...Rd(e3, r2)]
        };
      }
      return {
        document: e3
      };
    }
  });
}
function Ad(e2) {
  return e2.length > 0 ? {
    parent: initial_default(e2),
    key: last_default(e2)
  } : void 0;
}
function Rd(e2, n2) {
  var t3 = initial_default(n2), o2 = last_default(n2), r2 = getIn(e2, t3);
  return isJSONObject(r2) ? jc(Object.keys(r2), o2, false).map((e3) => zd(t3, e3)) : [];
}
function qd(e2) {
  var n2 = e2.activeIndex < e2.items.length - 1 ? e2.activeIndex + 1 : e2.items.length > 0 ? 0 : -1, t3 = e2.items[n2], o2 = e2.items.map((e3, t4) => r(r({}, e3), {}, {
    active: t4 === n2
  }));
  return r(r({}, e2), {}, {
    items: o2,
    activeItem: t3,
    activeIndex: n2
  });
}
function Pd(e2, n2) {
  var t3, o2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r2 = e2.toLowerCase(), a2 = null !== (t3 = null == o2 ? void 0 : o2.maxResults) && void 0 !== t3 ? t3 : 1 / 0, i2 = null == o2 ? void 0 : o2.columns, s2 = [], l = [];
  function c(e3) {
    s2.length >= a2 || s2.push(e3);
  }
  function u(e3, n3) {
    if (isJSONArray(n3)) {
      var t4 = l.length;
      l.push("0");
      for (var o3 = 0; o3 < n3.length; o3++) if (l[t4] = String(o3), u(e3, n3[o3]), s2.length >= a2) return;
      l.pop();
    } else if (isJSONObject(n3)) {
      var r3 = Object.keys(n3), i3 = l.length;
      for (var d of (l.push(""), r3)) if (l[i3] = d, Td(d, e3, l, ss.key, c), u(e3, n3[d]), s2.length >= a2) return;
      l.pop();
    } else Td(String(n3), e3, l, ss.value, c);
  }
  if ("" === e2) return [];
  if (i2) {
    if (!Array.isArray(n2)) throw new Error("json must be an Array when option columns is defined");
    for (var v = 0; v < n2.length; v++) {
      l[0] = String(v);
      for (var f = n2[v], p2 = 0; p2 < i2.length; p2++) {
        var h2 = i2[p2];
        if (1 === h2.length) l[1] = h2[0];
        else for (var g = 0; g < h2.length; g++) l[g + 1] = h2[g];
        for (; l.length > h2.length + 1; ) l.pop();
        u(r2, getIn(f, h2));
      }
      if (s2.length >= a2) break;
    }
    return s2;
  }
  return u(r2, n2), s2;
}
function Td(e2, n2, t3, o2, r2) {
  var a2 = e2.toLowerCase(), i2 = 0, s2 = -1, l = -1;
  do {
    -1 !== (l = a2.indexOf(n2, s2)) && (s2 = l + n2.length, r2({
      path: t3.slice(0),
      field: o2,
      fieldIndex: i2,
      start: l,
      end: s2
    }), i2++);
  } while (-1 !== l);
}
function Nd(e2, n2, t3, o2) {
  return e2.substring(0, t3) + n2 + e2.substring(o2);
}
function Id(e2, n2, t3) {
  var o2 = e2;
  return forEachRight_default(t3, (e3) => {
    o2 = Nd(o2, n2, e3.start, e3.end);
  }), o2;
}
function Ud(e2, n2, t3, o2, r2) {
  var {
    field: a2,
    path: i2,
    start: s2,
    end: l
  } = o2;
  if (a2 === ss.key) {
    var u = initial_default(i2), v = getIn(e2, u), f = last_default(i2), p2 = yd(u, Object.keys(v), f, Nd(f, t3, s2, l));
    return {
      newSelection: Wc(e2, p2),
      operations: p2
    };
  }
  if (a2 === ss.value) {
    var h2 = getIn(e2, i2);
    if (void 0 === h2) throw new Error("Cannot replace: path not found ".concat(compileJSONPointer(i2)));
    var g = "string" == typeof h2 ? h2 : String(h2), m = bc(e2, n2, i2), b = Nd(g, t3, s2, l), j = [{
      op: "replace",
      path: compileJSONPointer(i2),
      value: m ? b : Si(b, r2)
    }];
    return {
      newSelection: Wc(e2, j),
      operations: j
    };
  }
  throw new Error("Cannot replace: unknown type of search result field ".concat(a2));
}
function Dd(e2) {
  return e2.path.concat(e2.field, String(e2.fieldIndex));
}
function Jd(e2) {
  var n2 = Hl(e2) ? e2.searchResults.filter((e3) => e3.field === ss.key) : void 0;
  return n2 && n2.length > 0 ? n2 : void 0;
}
function Bd(e2) {
  var n2 = Hl(e2) ? e2.searchResults.filter((e3) => e3.field === ss.value) : void 0;
  return n2 && n2.length > 0 ? n2 : void 0;
}
var _d = {
  createObjectDocumentState: () => ({
    type: "object",
    properties: {}
  }),
  createArrayDocumentState: () => ({
    type: "array",
    items: []
  }),
  createValueDocumentState: () => ({
    type: "value"
  })
};
function Fd(e2, n2) {
  return n2.reduce((n3, t3) => function(e3, n4, t4, o2) {
    return vc(e3, n4, t4, o2, _d);
  }(e2, n3, t3.path, (e3, n4) => r(r({}, n4), {}, {
    searchResults: n4.searchResults ? n4.searchResults.concat(t3) : [t3]
  })), void 0);
}
function Ld(e2) {
  var n2, t3 = null !== (n2 = null == e2 ? void 0 : e2.searchResults) && void 0 !== n2 ? n2 : [], o2 = Ll(e2) ? Object.values(e2.properties).flatMap(Ld) : Wl(e2) ? e2.items.flatMap(Ld) : [];
  return t3.concat(o2);
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-highlight.svelte-5fb7bl {\n  background-color: var(--jse-search-match-color, #ffe665);\n  outline: var(--jse-search-match-outline, none);\n}\n.jse-highlight.jse-active.svelte-5fb7bl {\n  background-color: var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));\n  outline: var(--jse-search-match-outline, 2px solid #e0be00);\n}');
var Wd = Lr("<span> </span>");
function Vd(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(), o2 = ai(n2, "text", 8), r2 = ai(n2, "searchResultItems", 8);
  xo(() => (Ar(o2()), Ar(r2())), () => {
    Xt(t3, function(e3, n3) {
      var t4 = [], o3 = 0;
      for (var r3 of n3) {
        var a3 = e3.slice(o3, r3.start);
        "" !== a3 && t4.push({
          resultIndex: void 0,
          type: "normal",
          text: a3,
          active: false
        });
        var i2 = e3.slice(r3.start, r3.end);
        t4.push({
          resultIndex: r3.resultIndex,
          type: "highlight",
          text: i2,
          active: r3.active
        }), o3 = r3.end;
      }
      var s2 = last_default(n3);
      return s2 && s2.end < e3.length && t4.push({
        type: "normal",
        text: e3.slice(s2.end),
        resultIndex: void 0,
        active: false
      }), t4;
    }(String(o2()), r2()));
  }), yo(), Ka();
  var a2 = $r();
  da(vo(a2), 1, () => Sr(t3), ca, (e3, n3) => {
    var t4 = $r(), o3 = vo(t4), r3 = (e4) => {
      var t5 = Vr();
      ko(() => Xr(t5, (Sr(n3), Or(() => Sr(n3).text)))), Hr(e4, t5);
    }, a3 = (e4) => {
      var t5, o4 = Wd(), r4 = uo(o4);
      ko((e5, n4, a4) => {
        t5 = Ca(o4, 1, "jse-highlight svelte-5fb7bl", null, t5, e5), Ia(o4, "data-search-result-index", n4), Xr(r4, a4);
      }, [() => ({
        "jse-active": Sr(n3).active
      }), () => (Sr(n3), Or(() => String(Sr(n3).resultIndex))), () => (Ar(ws), Sr(n3), Or(() => ws(Sr(n3).text)))], Lt), Hr(e4, o4);
    };
    sa(o3, (e4) => {
      Sr(n3), Or(() => "normal" === Sr(n3).type) ? e4(r3) : e4(a3, false);
    }), Hr(e3, t4);
  }), Hr(e2, a2), Nt();
}
function $d(e2) {
  var n2 = 1e3;
  if (e2 < 900) return e2.toFixed() + " B";
  var t3 = e2 / n2;
  if (t3 < 900) return t3.toFixed(1) + " KB";
  var o2 = t3 / n2;
  if (o2 < 900) return o2.toFixed(1) + " MB";
  var r2 = o2 / n2;
  return r2 < 900 ? r2.toFixed(1) + " GB" : (r2 / n2).toFixed(1) + " TB";
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-tag.svelte-jlw0fj {\n  border: none;\n  font-size: 80%;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  color: var(--jse-tag-color, var(--jse-text-color-inverse, #fff));\n  background: var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  border-radius: 2px;\n  cursor: pointer;\n  display: inline-block;\n  padding: 0 4px;\n  line-height: normal;\n  margin: 1px 0;\n}\n.jse-tag.svelte-jlw0fj:hover {\n  opacity: 0.8;\n}\n.jse-tag.disabled.svelte-jlw0fj {\n  opacity: 0.7;\n  cursor: inherit;\n}');
var Hd = Lr('<button type="button"><!></button>');
function Qd(e2, n2) {
  Tt(n2, true);
  var t3, o2 = Ft(() => n2.onclick ? (e3) => {
    e3.preventDefault(), e3.stopPropagation(), n2.onclick();
  } : void 0), r2 = Hd();
  r2.__click = function() {
    for (var e3, n3 = arguments.length, t4 = new Array(n3), r3 = 0; r3 < n3; r3++) t4[r3] = arguments[r3];
    null === (e3 = Sr(o2)) || void 0 === e3 || e3.apply(this, t4);
  }, function(e3, n3) {
    for (var t4 = arguments.length, o3 = new Array(t4 > 2 ? t4 - 2 : 0), r3 = 2; r3 < t4; r3++) o3[r3 - 2] = arguments[r3];
    var a2, i2 = e3, s2 = at3;
    So(() => {
      s2 !== (s2 = n3()) && (a2 && (Mo(a2), a2 = null), a2 = Co(() => s2(i2, ...o3)));
    }, mt2);
  }(uo(r2), () => {
    var e3;
    return null !== (e3 = n2.children) && void 0 !== e3 ? e3 : at3;
  }), ko((e3) => t3 = Ca(r2, 1, "jse-tag svelte-jlw0fj", null, t3, e3), [() => ({
    disabled: !n2.onclick
  })]), Hr(e2, r2), Nt();
}
Jr(["click"]);
function Yd(e2, n2, t3) {
  "string" == typeof n2.value && Sr(t3) && Is(e2) && (e2.preventDefault(), e2.stopPropagation(), window.open(n2.value, "_blank"));
}
function Kd(e2, n2) {
  n2.readOnly || (e2.preventDefault(), n2.onSelect(Gc(n2.path)));
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-value.jse-string.svelte-c0g9qz {\n  color: var(--jse-value-color-string, #008000);\n}\n.jse-value.jse-object.svelte-c0g9qz, .jse-value.jse-array.svelte-c0g9qz {\n  min-width: 16px;\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n}\n.jse-value.jse-number.svelte-c0g9qz {\n  color: var(--jse-value-color-number, #ee422e);\n}\n.jse-value.jse-boolean.svelte-c0g9qz {\n  color: var(--jse-value-color-boolean, #ff8c00);\n}\n.jse-value.jse-null.svelte-c0g9qz {\n  color: var(--jse-value-color-null, #004ed0);\n}\n.jse-value.jse-invalid.svelte-c0g9qz {\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-value.jse-url.svelte-c0g9qz {\n  color: var(--jse-value-color-url, #008000);\n  text-decoration: underline;\n}\n\n.jse-value.svelte-c0g9qz {\n  display: inline-block;\n  min-width: 2em;\n  padding: 0 5px;\n  box-sizing: border-box;\n  outline: none;\n  border-radius: 1px;\n  vertical-align: top;\n  word-break: normal;\n  overflow-wrap: anywhere;\n  white-space: pre-wrap;\n}\n.jse-value.jse-table-cell.svelte-c0g9qz {\n  overflow-wrap: normal;\n  white-space: nowrap;\n}\n.jse-value.jse-empty.svelte-c0g9qz {\n  min-width: 4em;\n  outline: 1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  -moz-outline-radius: 2px;\n}\n.jse-value.jse-empty.svelte-c0g9qz::after {\n  pointer-events: none;\n  color: var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  content: "value";\n}');
var Zd = Lr('<div role="button" tabindex="-1" data-type="selectable-value"><!> <!></div>');
function Xd(e2, n2) {
  Tt(n2, true);
  var t3 = Yt(true), o2 = Ft(() => Sr(t3) && "string" == typeof n2.value && n2.value.length > n2.truncateTextSize && (!n2.searchResultItems || !n2.searchResultItems.some((e3) => e3.active && e3.end > n2.truncateTextSize))), r2 = Ft(() => Sr(o2) && "string" == typeof n2.value ? n2.value.substring(0, n2.truncateTextSize).trim() : n2.value), a2 = Ft(() => ki(n2.value));
  function i2() {
    Xt(t3, false);
  }
  var s2 = Zd();
  s2.__click = [Yd, n2, a2], s2.__dblclick = [Kd, n2];
  var l = uo(s2), c = (e3) => {
    var t4 = Ft(() => n2.normalization.escapeValue(Sr(r2)));
    Vd(e3, {
      get text() {
        return Sr(t4);
      },
      get searchResultItems() {
        return n2.searchResultItems;
      }
    });
  }, d = (e3) => {
    var t4 = Vr();
    ko((e4) => Xr(t4, e4), [() => ws(n2.normalization.escapeValue(Sr(r2)))]), Hr(e3, t4);
  };
  sa(l, (e3) => {
    n2.searchResultItems ? e3(c) : e3(d, false);
  });
  var u = fo(l, 2), v = (e3) => {
    Qd(e3, {
      onclick: i2,
      children: (e4, t4) => {
        var o3 = Vr();
        ko((e5) => Xr(o3, "Show more (".concat(null != e5 ? e5 : "", ")")), [() => $d(n2.value.length)]), Hr(e4, o3);
      },
      $$slots: {
        default: true
      }
    });
  };
  sa(u, (e3) => {
    Sr(o2) && "string" == typeof n2.value && e3(v);
  }), ko((e3) => {
    Ca(s2, 1, e3, "svelte-c0g9qz"), Ia(s2, "title", Sr(a2) ? "Ctrl+Click or Ctrl+Enter to open url in new window" : void 0);
  }, [() => ya(hd(n2.value, n2.mode, n2.parser))]), Hr(e2, s2), Nt();
}
Jr(["click", "dblclick"]);
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-tooltip.svelte-14y3y8t {\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  line-height: normal;\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n  border-radius: 3px;\n  background: var(--jse-context-menu-background, #656565);\n  color: var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));\n  white-space: nowrap;\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n}');
var Gd = Lr('<div class="jse-tooltip svelte-14y3y8t"> </div>');
function eu(e2, n2) {
  var t3 = ai(n2, "text", 8), o2 = Gd(), r2 = uo(o2);
  ko(() => Xr(r2, t3())), Hr(e2, o2);
}
function nu(e2, n2) {
  var t3, {
    text: o2,
    openAbsolutePopup: r2,
    closeAbsolutePopup: a2
  } = n2;
  function i2() {
    t3 = r2(eu, {
      text: o2
    }, {
      position: "top",
      width: 10 * o2.length,
      offsetTop: 3,
      anchor: e2,
      closeOnOuterClick: true
    });
  }
  function s2() {
    a2(t3);
  }
  return e2.addEventListener("mouseenter", i2), e2.addEventListener("mouseleave", s2), {
    destroy() {
      e2.removeEventListener("mouseenter", i2), e2.removeEventListener("mouseleave", s2);
    }
  };
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-timestamp.svelte-1jla5ec {\n  padding: 0;\n  margin: 0;\n  vertical-align: middle;\n  display: inline-flex;\n  color: var(--jse-value-color-number, #ee422e);\n}');
var tu = Lr('<div class="jse-timestamp svelte-1jla5ec"><!></div>');
function ou(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Pt("absolute-popup"), a2 = ai(n2, "value", 9);
  xo(() => Ar(a2()), () => {
    Xt(t3, "Time: ".concat(new Date(a2()).toString()));
  }), yo(), Ka(true);
  var i2 = tu();
  nl(uo(i2), {
    get data() {
      return faClock;
    }
  }), ba(i2, (e3, n3) => null == nu ? void 0 : nu(e3, n3), () => r({
    text: Sr(t3)
  }, o2)), Hr(e2, i2), Nt();
}
function ru(e2) {
  var n2 = [];
  return !e2.isEditing && gi(e2.value) && n2.push({
    component: ol,
    props: e2
  }), !e2.isEditing && xi(e2.value) && n2.push({
    component: sl,
    props: e2
  }), e2.isEditing && n2.push({
    component: bd,
    props: e2
  }), e2.isEditing || n2.push({
    component: Xd,
    props: e2
  }), !e2.isEditing && mi(e2.value) && n2.push({
    component: ou,
    props: e2
  }), n2;
}
function au(e2) {
  return e2.map((e3, n2) => uu.test(e3) ? "[" + e3 + "]" : /[.[\]]/.test(e3) || "" === e3 ? '["' + function(e4) {
    return e4.replace(/"/g, '\\"');
  }(e3) + '"]' : (n2 > 0 ? "." : "") + e3).join("");
}
function iu(e2) {
  for (var n2 = [], t3 = 0; t3 < e2.length; ) "." === e2[t3] && t3++, "[" === e2[t3] ? (t3++, '"' === e2[t3] ? (t3++, n2.push(o2((e3) => '"' === e3, true)), r2('"')) : n2.push(o2((e3) => "]" === e3)), r2("]")) : n2.push(o2((e3) => "." === e3 || "[" === e3));
  function o2(n3) {
    for (var o3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r3 = ""; t3 < e2.length && !n3(e2[t3]); ) o3 && "\\" === e2[t3] && '"' === e2[t3 + 1] ? (r3 += '"', t3 += 2) : (r3 += e2[t3], t3++);
    return r3;
  }
  function r2(n3) {
    if (e2[t3] !== n3) throw new SyntaxError("Invalid JSON path: ".concat(n3, " expected at position ").concat(t3));
    t3++;
  }
  return n2;
}
function su(e2) {
  return {
    value: e2,
    label: isEmpty_default(e2) ? "(item root)" : au(e2)
  };
}
function lu(e2) {
  if (uu.test(e2)) return "[" + e2 + "]";
  if (du.test(e2)) return "." + e2;
  var n2 = JSON.stringify(e2);
  return "['" + n2.substring(1, n2.length - 1).replace(/\\"/g, '"') + "']";
}
function cu(e2) {
  return e2.map((e3) => uu.test(e3) ? "?.[".concat(e3, "]") : du.test(e3) ? "?.".concat(e3) : "?.[".concat(JSON.stringify(e3), "]")).join("");
}
var du = /^[a-zA-Z$_][a-zA-Z$_\d]*$/;
var uu = /^\d+$/;
var vu = {};
var fu = {
  showWizard: true,
  showOriginal: true
};
var pu = Math.min;
var hu = Math.max;
var gu = Math.round;
var mu = Math.floor;
var bu = (e2) => ({
  x: e2,
  y: e2
});
var ju = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var xu = {
  start: "end",
  end: "start"
};
function yu(e2, n2, t3) {
  return hu(e2, pu(n2, t3));
}
function wu(e2, n2) {
  return "function" == typeof e2 ? e2(n2) : e2;
}
function ku(e2) {
  return e2.split("-")[0];
}
function Su(e2) {
  return e2.split("-")[1];
}
function Cu(e2) {
  return "x" === e2 ? "y" : "x";
}
function zu(e2) {
  return "y" === e2 ? "height" : "width";
}
var Ou = /* @__PURE__ */ new Set(["top", "bottom"]);
function Mu(e2) {
  return Ou.has(ku(e2)) ? "y" : "x";
}
function Eu(e2) {
  return Cu(Mu(e2));
}
function Au(e2) {
  return e2.replace(/start|end/g, (e3) => xu[e3]);
}
var Ru = ["left", "right"];
var qu = ["right", "left"];
var Pu = ["top", "bottom"];
var Tu = ["bottom", "top"];
function Nu(e2, n2, t3, o2) {
  var r2 = Su(e2), a2 = function(e3, n3, t4) {
    switch (e3) {
      case "top":
      case "bottom":
        return t4 ? n3 ? qu : Ru : n3 ? Ru : qu;
      case "left":
      case "right":
        return n3 ? Pu : Tu;
      default:
        return [];
    }
  }(ku(e2), "start" === t3, o2);
  return r2 && (a2 = a2.map((e3) => e3 + "-" + r2), n2 && (a2 = a2.concat(a2.map(Au)))), a2;
}
function Iu(e2) {
  return e2.replace(/left|right|bottom|top/g, (e3) => ju[e3]);
}
function Uu(e2) {
  return "number" != typeof e2 ? function(e3) {
    return r({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e3);
  }(e2) : {
    top: e2,
    right: e2,
    bottom: e2,
    left: e2
  };
}
function Du(e2) {
  var {
    x: n2,
    y: t3,
    width: o2,
    height: r2
  } = e2;
  return {
    width: o2,
    height: r2,
    top: t3,
    left: n2,
    right: n2 + o2,
    bottom: t3 + r2,
    x: n2,
    y: t3
  };
}
function Ju(e2, n2, t3) {
  var o2, {
    reference: r2,
    floating: a2
  } = e2, i2 = Mu(n2), s2 = Eu(n2), l = zu(s2), c = ku(n2), d = "y" === i2, u = r2.x + r2.width / 2 - a2.width / 2, v = r2.y + r2.height / 2 - a2.height / 2, f = r2[l] / 2 - a2[l] / 2;
  switch (c) {
    case "top":
      o2 = {
        x: u,
        y: r2.y - a2.height
      };
      break;
    case "bottom":
      o2 = {
        x: u,
        y: r2.y + r2.height
      };
      break;
    case "right":
      o2 = {
        x: r2.x + r2.width,
        y: v
      };
      break;
    case "left":
      o2 = {
        x: r2.x - a2.width,
        y: v
      };
      break;
    default:
      o2 = {
        x: r2.x,
        y: r2.y
      };
  }
  switch (Su(n2)) {
    case "start":
      o2[s2] -= f * (t3 && d ? -1 : 1);
      break;
    case "end":
      o2[s2] += f * (t3 && d ? -1 : 1);
  }
  return o2;
}
var Bu = function() {
  var e2 = i(function* (e3, n2, t3) {
    for (var {
      placement: o2 = "bottom",
      strategy: a2 = "absolute",
      middleware: i2 = [],
      platform: s2
    } = t3, l = i2.filter(Boolean), c = yield null == s2.isRTL ? void 0 : s2.isRTL(n2), d = yield s2.getElementRects({
      reference: e3,
      floating: n2,
      strategy: a2
    }), {
      x: u,
      y: v
    } = Ju(d, o2, c), f = o2, p2 = {}, h2 = 0, g = 0; g < l.length; g++) {
      var {
        name: m,
        fn: b
      } = l[g], {
        x: j,
        y: x,
        data: y,
        reset: w
      } = yield b({
        x: u,
        y: v,
        initialPlacement: o2,
        placement: f,
        strategy: a2,
        middlewareData: p2,
        rects: d,
        platform: s2,
        elements: {
          reference: e3,
          floating: n2
        }
      });
      u = null != j ? j : u, v = null != x ? x : v, p2 = r(r({}, p2), {}, {
        [m]: r(r({}, p2[m]), y)
      }), w && h2 <= 50 && (h2++, "object" == typeof w && (w.placement && (f = w.placement), w.rects && (d = true === w.rects ? yield s2.getElementRects({
        reference: e3,
        floating: n2,
        strategy: a2
      }) : w.rects), {
        x: u,
        y: v
      } = Ju(d, f, c)), g = -1);
    }
    return {
      x: u,
      y: v,
      placement: f,
      strategy: a2,
      middlewareData: p2
    };
  });
  return function(n2, t3, o2) {
    return e2.apply(this, arguments);
  };
}();
function _u(e2, n2) {
  return Fu.apply(this, arguments);
}
function Fu() {
  return Fu = i(function* (e2, n2) {
    var t3;
    void 0 === n2 && (n2 = {});
    var {
      x: o2,
      y: r2,
      platform: a2,
      rects: i2,
      elements: s2,
      strategy: l
    } = e2, {
      boundary: c = "clippingAncestors",
      rootBoundary: d = "viewport",
      elementContext: u = "floating",
      altBoundary: v = false,
      padding: f = 0
    } = wu(n2, e2), p2 = Uu(f), h2 = s2[v ? "floating" === u ? "reference" : "floating" : u], g = Du(yield a2.getClippingRect({
      element: null == (t3 = yield null == a2.isElement ? void 0 : a2.isElement(h2)) || t3 ? h2 : h2.contextElement || (yield null == a2.getDocumentElement ? void 0 : a2.getDocumentElement(s2.floating)),
      boundary: c,
      rootBoundary: d,
      strategy: l
    })), m = "floating" === u ? {
      x: o2,
      y: r2,
      width: i2.floating.width,
      height: i2.floating.height
    } : i2.reference, b = yield null == a2.getOffsetParent ? void 0 : a2.getOffsetParent(s2.floating), j = (yield null == a2.isElement ? void 0 : a2.isElement(b)) && (yield null == a2.getScale ? void 0 : a2.getScale(b)) || {
      x: 1,
      y: 1
    }, x = Du(a2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield a2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: s2,
      rect: m,
      offsetParent: b,
      strategy: l
    }) : m);
    return {
      top: (g.top - x.top + p2.top) / j.y,
      bottom: (x.bottom - g.bottom + p2.bottom) / j.y,
      left: (g.left - x.left + p2.left) / j.x,
      right: (x.right - g.right + p2.right) / j.x
    };
  }), Fu.apply(this, arguments);
}
var Lu = /* @__PURE__ */ new Set(["left", "top"]);
function Wu() {
  return Wu = i(function* (e2, n2) {
    var {
      placement: t3,
      platform: o2,
      elements: r2
    } = e2, a2 = yield null == o2.isRTL ? void 0 : o2.isRTL(r2.floating), i2 = ku(t3), s2 = Su(t3), l = "y" === Mu(t3), c = Lu.has(i2) ? -1 : 1, d = a2 && l ? -1 : 1, u = wu(n2, e2), {
      mainAxis: v,
      crossAxis: f,
      alignmentAxis: p2
    } = "number" == typeof u ? {
      mainAxis: u,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: u.mainAxis || 0,
      crossAxis: u.crossAxis || 0,
      alignmentAxis: u.alignmentAxis
    };
    return s2 && "number" == typeof p2 && (f = "end" === s2 ? -1 * p2 : p2), l ? {
      x: f * d,
      y: v * c
    } : {
      x: v * c,
      y: f * d
    };
  }), Wu.apply(this, arguments);
}
function Vu() {
  return "undefined" != typeof window;
}
function $u(e2) {
  return Yu(e2) ? (e2.nodeName || "").toLowerCase() : "#document";
}
function Hu(e2) {
  var n2;
  return (null == e2 || null == (n2 = e2.ownerDocument) ? void 0 : n2.defaultView) || window;
}
function Qu(e2) {
  var n2;
  return null == (n2 = (Yu(e2) ? e2.ownerDocument : e2.document) || window.document) ? void 0 : n2.documentElement;
}
function Yu(e2) {
  return !!Vu() && (e2 instanceof Node || e2 instanceof Hu(e2).Node);
}
function Ku(e2) {
  return !!Vu() && (e2 instanceof Element || e2 instanceof Hu(e2).Element);
}
function Zu(e2) {
  return !!Vu() && (e2 instanceof HTMLElement || e2 instanceof Hu(e2).HTMLElement);
}
function Xu(e2) {
  return !(!Vu() || "undefined" == typeof ShadowRoot) && (e2 instanceof ShadowRoot || e2 instanceof Hu(e2).ShadowRoot);
}
var Gu = /* @__PURE__ */ new Set(["inline", "contents"]);
function ev(e2) {
  var {
    overflow: n2,
    overflowX: t3,
    overflowY: o2,
    display: r2
  } = vv(e2);
  return /auto|scroll|overlay|hidden|clip/.test(n2 + o2 + t3) && !Gu.has(r2);
}
var nv = /* @__PURE__ */ new Set(["table", "td", "th"]);
function tv(e2) {
  return nv.has($u(e2));
}
var ov = [":popover-open", ":modal"];
function rv(e2) {
  return ov.some((n2) => {
    try {
      return e2.matches(n2);
    } catch (e3) {
      return false;
    }
  });
}
var av = ["transform", "translate", "scale", "rotate", "perspective"];
var iv = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var sv = ["paint", "layout", "strict", "content"];
function lv(e2) {
  var n2 = cv(), t3 = Ku(e2) ? vv(e2) : e2;
  return av.some((e3) => !!t3[e3] && "none" !== t3[e3]) || !!t3.containerType && "normal" !== t3.containerType || !n2 && !!t3.backdropFilter && "none" !== t3.backdropFilter || !n2 && !!t3.filter && "none" !== t3.filter || iv.some((e3) => (t3.willChange || "").includes(e3)) || sv.some((e3) => (t3.contain || "").includes(e3));
}
function cv() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
var dv = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function uv(e2) {
  return dv.has($u(e2));
}
function vv(e2) {
  return Hu(e2).getComputedStyle(e2);
}
function fv(e2) {
  return Ku(e2) ? {
    scrollLeft: e2.scrollLeft,
    scrollTop: e2.scrollTop
  } : {
    scrollLeft: e2.scrollX,
    scrollTop: e2.scrollY
  };
}
function pv(e2) {
  if ("html" === $u(e2)) return e2;
  var n2 = e2.assignedSlot || e2.parentNode || Xu(e2) && e2.host || Qu(e2);
  return Xu(n2) ? n2.host : n2;
}
function hv(e2) {
  var n2 = pv(e2);
  return uv(n2) ? e2.ownerDocument ? e2.ownerDocument.body : e2.body : Zu(n2) && ev(n2) ? n2 : hv(n2);
}
function gv(e2, n2, t3) {
  var o2;
  void 0 === n2 && (n2 = []), void 0 === t3 && (t3 = true);
  var r2 = hv(e2), a2 = r2 === (null == (o2 = e2.ownerDocument) ? void 0 : o2.body), i2 = Hu(r2);
  if (a2) {
    var s2 = mv(i2);
    return n2.concat(i2, i2.visualViewport || [], ev(r2) ? r2 : [], s2 && t3 ? gv(s2) : []);
  }
  return n2.concat(r2, gv(r2, [], t3));
}
function mv(e2) {
  return e2.parent && Object.getPrototypeOf(e2.parent) ? e2.frameElement : null;
}
function bv(e2) {
  var n2 = vv(e2), t3 = parseFloat(n2.width) || 0, o2 = parseFloat(n2.height) || 0, r2 = Zu(e2), a2 = r2 ? e2.offsetWidth : t3, i2 = r2 ? e2.offsetHeight : o2, s2 = gu(t3) !== a2 || gu(o2) !== i2;
  return s2 && (t3 = a2, o2 = i2), {
    width: t3,
    height: o2,
    $: s2
  };
}
function jv(e2) {
  return Ku(e2) ? e2 : e2.contextElement;
}
function xv(e2) {
  var n2 = jv(e2);
  if (!Zu(n2)) return bu(1);
  var t3 = n2.getBoundingClientRect(), {
    width: o2,
    height: r2,
    $: a2
  } = bv(n2), i2 = (a2 ? gu(t3.width) : t3.width) / o2, s2 = (a2 ? gu(t3.height) : t3.height) / r2;
  return i2 && Number.isFinite(i2) || (i2 = 1), s2 && Number.isFinite(s2) || (s2 = 1), {
    x: i2,
    y: s2
  };
}
var yv = bu(0);
function wv(e2) {
  var n2 = Hu(e2);
  return cv() && n2.visualViewport ? {
    x: n2.visualViewport.offsetLeft,
    y: n2.visualViewport.offsetTop
  } : yv;
}
function kv(e2, n2, t3, o2) {
  void 0 === n2 && (n2 = false), void 0 === t3 && (t3 = false);
  var r2 = e2.getBoundingClientRect(), a2 = jv(e2), i2 = bu(1);
  n2 && (o2 ? Ku(o2) && (i2 = xv(o2)) : i2 = xv(e2));
  var s2 = function(e3, n3, t4) {
    return void 0 === n3 && (n3 = false), !(!t4 || n3 && t4 !== Hu(e3)) && n3;
  }(a2, t3, o2) ? wv(a2) : bu(0), l = (r2.left + s2.x) / i2.x, c = (r2.top + s2.y) / i2.y, d = r2.width / i2.x, u = r2.height / i2.y;
  if (a2) for (var v = Hu(a2), f = o2 && Ku(o2) ? Hu(o2) : o2, p2 = v, h2 = mv(p2); h2 && o2 && f !== p2; ) {
    var g = xv(h2), m = h2.getBoundingClientRect(), b = vv(h2), j = m.left + (h2.clientLeft + parseFloat(b.paddingLeft)) * g.x, x = m.top + (h2.clientTop + parseFloat(b.paddingTop)) * g.y;
    l *= g.x, c *= g.y, d *= g.x, u *= g.y, l += j, c += x, h2 = mv(p2 = Hu(h2));
  }
  return Du({
    width: d,
    height: u,
    x: l,
    y: c
  });
}
function Sv(e2, n2) {
  var t3 = fv(e2).scrollLeft;
  return n2 ? n2.left + t3 : kv(Qu(e2)).left + t3;
}
function Cv(e2, n2, t3) {
  void 0 === t3 && (t3 = false);
  var o2 = e2.getBoundingClientRect();
  return {
    x: o2.left + n2.scrollLeft - (t3 ? 0 : Sv(e2, o2)),
    y: o2.top + n2.scrollTop
  };
}
var zv = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Ov(e2, n2, t3) {
  var o2;
  if ("viewport" === n2) o2 = function(e3, n3) {
    var t4 = Hu(e3), o3 = Qu(e3), r3 = t4.visualViewport, a2 = o3.clientWidth, i2 = o3.clientHeight, s2 = 0, l = 0;
    if (r3) {
      a2 = r3.width, i2 = r3.height;
      var c = cv();
      (!c || c && "fixed" === n3) && (s2 = r3.offsetLeft, l = r3.offsetTop);
    }
    return {
      width: a2,
      height: i2,
      x: s2,
      y: l
    };
  }(e2, t3);
  else if ("document" === n2) o2 = function(e3) {
    var n3 = Qu(e3), t4 = fv(e3), o3 = e3.ownerDocument.body, r3 = hu(n3.scrollWidth, n3.clientWidth, o3.scrollWidth, o3.clientWidth), a2 = hu(n3.scrollHeight, n3.clientHeight, o3.scrollHeight, o3.clientHeight), i2 = -t4.scrollLeft + Sv(e3), s2 = -t4.scrollTop;
    return "rtl" === vv(o3).direction && (i2 += hu(n3.clientWidth, o3.clientWidth) - r3), {
      width: r3,
      height: a2,
      x: i2,
      y: s2
    };
  }(Qu(e2));
  else if (Ku(n2)) o2 = function(e3, n3) {
    var t4 = kv(e3, true, "fixed" === n3), o3 = t4.top + e3.clientTop, r3 = t4.left + e3.clientLeft, a2 = Zu(e3) ? xv(e3) : bu(1);
    return {
      width: e3.clientWidth * a2.x,
      height: e3.clientHeight * a2.y,
      x: r3 * a2.x,
      y: o3 * a2.y
    };
  }(n2, t3);
  else {
    var r2 = wv(e2);
    o2 = {
      x: n2.x - r2.x,
      y: n2.y - r2.y,
      width: n2.width,
      height: n2.height
    };
  }
  return Du(o2);
}
function Mv(e2, n2) {
  var t3 = pv(e2);
  return !(t3 === n2 || !Ku(t3) || uv(t3)) && ("fixed" === vv(t3).position || Mv(t3, n2));
}
function Ev(e2, n2, t3) {
  var o2 = Zu(n2), r2 = Qu(n2), a2 = "fixed" === t3, i2 = kv(e2, true, a2, n2), s2 = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = bu(0);
  function c() {
    l.x = Sv(r2);
  }
  if (o2 || !o2 && !a2) if (("body" !== $u(n2) || ev(r2)) && (s2 = fv(n2)), o2) {
    var d = kv(n2, true, a2, n2);
    l.x = d.x + n2.clientLeft, l.y = d.y + n2.clientTop;
  } else r2 && c();
  a2 && !o2 && r2 && c();
  var u = !r2 || o2 || a2 ? bu(0) : Cv(r2, s2);
  return {
    x: i2.left + s2.scrollLeft - l.x - u.x,
    y: i2.top + s2.scrollTop - l.y - u.y,
    width: i2.width,
    height: i2.height
  };
}
function Av(e2) {
  return "static" === vv(e2).position;
}
function Rv(e2, n2) {
  if (!Zu(e2) || "fixed" === vv(e2).position) return null;
  if (n2) return n2(e2);
  var t3 = e2.offsetParent;
  return Qu(e2) === t3 && (t3 = t3.ownerDocument.body), t3;
}
function qv(e2, n2) {
  var t3 = Hu(e2);
  if (rv(e2)) return t3;
  if (!Zu(e2)) {
    for (var o2 = pv(e2); o2 && !uv(o2); ) {
      if (Ku(o2) && !Av(o2)) return o2;
      o2 = pv(o2);
    }
    return t3;
  }
  for (var r2 = Rv(e2, n2); r2 && tv(r2) && Av(r2); ) r2 = Rv(r2, n2);
  return r2 && uv(r2) && Av(r2) && !lv(r2) ? t3 : r2 || function(e3) {
    for (var n3 = pv(e3); Zu(n3) && !uv(n3); ) {
      if (lv(n3)) return n3;
      if (rv(n3)) return null;
      n3 = pv(n3);
    }
    return null;
  }(e2) || t3;
}
var Pv = {
  convertOffsetParentRelativeRectToViewportRelativeRect: function(e2) {
    var {
      elements: n2,
      rect: t3,
      offsetParent: o2,
      strategy: r2
    } = e2, a2 = "fixed" === r2, i2 = Qu(o2), s2 = !!n2 && rv(n2.floating);
    if (o2 === i2 || s2 && a2) return t3;
    var l = {
      scrollLeft: 0,
      scrollTop: 0
    }, c = bu(1), d = bu(0), u = Zu(o2);
    if ((u || !u && !a2) && (("body" !== $u(o2) || ev(i2)) && (l = fv(o2)), Zu(o2))) {
      var v = kv(o2);
      c = xv(o2), d.x = v.x + o2.clientLeft, d.y = v.y + o2.clientTop;
    }
    var f = !i2 || u || a2 ? bu(0) : Cv(i2, l, true);
    return {
      width: t3.width * c.x,
      height: t3.height * c.y,
      x: t3.x * c.x - l.scrollLeft * c.x + d.x + f.x,
      y: t3.y * c.y - l.scrollTop * c.y + d.y + f.y
    };
  },
  getDocumentElement: Qu,
  getClippingRect: function(e2) {
    var {
      element: n2,
      boundary: t3,
      rootBoundary: o2,
      strategy: r2
    } = e2, a2 = [..."clippingAncestors" === t3 ? rv(n2) ? [] : function(e3, n3) {
      var t4 = n3.get(e3);
      if (t4) return t4;
      for (var o3 = gv(e3, [], false).filter((e4) => Ku(e4) && "body" !== $u(e4)), r3 = null, a3 = "fixed" === vv(e3).position, i3 = a3 ? pv(e3) : e3; Ku(i3) && !uv(i3); ) {
        var s3 = vv(i3), l = lv(i3);
        l || "fixed" !== s3.position || (r3 = null), (a3 ? !l && !r3 : !l && "static" === s3.position && r3 && zv.has(r3.position) || ev(i3) && !l && Mv(e3, i3)) ? o3 = o3.filter((e4) => e4 !== i3) : r3 = s3, i3 = pv(i3);
      }
      return n3.set(e3, o3), o3;
    }(n2, this._c) : [].concat(t3), o2], i2 = a2[0], s2 = a2.reduce((e3, t4) => {
      var o3 = Ov(n2, t4, r2);
      return e3.top = hu(o3.top, e3.top), e3.right = pu(o3.right, e3.right), e3.bottom = pu(o3.bottom, e3.bottom), e3.left = hu(o3.left, e3.left), e3;
    }, Ov(n2, i2, r2));
    return {
      width: s2.right - s2.left,
      height: s2.bottom - s2.top,
      x: s2.left,
      y: s2.top
    };
  },
  getOffsetParent: qv,
  getElementRects: function() {
    var e2 = i(function* (e3) {
      var n2 = this.getOffsetParent || qv, t3 = this.getDimensions, o2 = yield t3(e3.floating);
      return {
        reference: Ev(e3.reference, yield n2(e3.floating), e3.strategy),
        floating: {
          x: 0,
          y: 0,
          width: o2.width,
          height: o2.height
        }
      };
    });
    return function(n2) {
      return e2.apply(this, arguments);
    };
  }(),
  getClientRects: function(e2) {
    return Array.from(e2.getClientRects());
  },
  getDimensions: function(e2) {
    var {
      width: n2,
      height: t3
    } = bv(e2);
    return {
      width: n2,
      height: t3
    };
  },
  getScale: xv,
  isElement: Ku,
  isRTL: function(e2) {
    return "rtl" === vv(e2).direction;
  }
};
function Tv(e2, n2) {
  return e2.x === n2.x && e2.y === n2.y && e2.width === n2.width && e2.height === n2.height;
}
function Nv(e2, n2, t3, o2) {
  void 0 === o2 && (o2 = {});
  var {
    ancestorScroll: a2 = true,
    ancestorResize: i2 = true,
    elementResize: s2 = "function" == typeof ResizeObserver,
    layoutShift: l = "function" == typeof IntersectionObserver,
    animationFrame: c = false
  } = o2, d = jv(e2), u = a2 || i2 ? [...d ? gv(d) : [], ...gv(n2)] : [];
  u.forEach((e3) => {
    a2 && e3.addEventListener("scroll", t3, {
      passive: true
    }), i2 && e3.addEventListener("resize", t3);
  });
  var v, f = d && l ? function(e3, n3) {
    var t4, o3 = null, a3 = Qu(e3);
    function i3() {
      var e4;
      clearTimeout(t4), null == (e4 = o3) || e4.disconnect(), o3 = null;
    }
    return function s3(l2, c2) {
      void 0 === l2 && (l2 = false), void 0 === c2 && (c2 = 1), i3();
      var d2 = e3.getBoundingClientRect(), {
        left: u2,
        top: v2,
        width: f2,
        height: p3
      } = d2;
      if (l2 || n3(), f2 && p3) {
        var h3 = {
          rootMargin: -mu(v2) + "px " + -mu(a3.clientWidth - (u2 + f2)) + "px " + -mu(a3.clientHeight - (v2 + p3)) + "px " + -mu(u2) + "px",
          threshold: hu(0, pu(1, c2)) || 1
        }, g2 = true;
        try {
          o3 = new IntersectionObserver(m, r(r({}, h3), {}, {
            root: a3.ownerDocument
          }));
        } catch (e4) {
          o3 = new IntersectionObserver(m, h3);
        }
        o3.observe(e3);
      }
      function m(n4) {
        var o4 = n4[0].intersectionRatio;
        if (o4 !== c2) {
          if (!g2) return s3();
          o4 ? s3(false, o4) : t4 = setTimeout(() => {
            s3(false, 1e-7);
          }, 1e3);
        }
        1 !== o4 || Tv(d2, e3.getBoundingClientRect()) || s3(), g2 = false;
      }
    }(true), i3;
  }(d, t3) : null, p2 = -1, h2 = null;
  s2 && (h2 = new ResizeObserver((e3) => {
    var [o3] = e3;
    o3 && o3.target === d && h2 && (h2.unobserve(n2), cancelAnimationFrame(p2), p2 = requestAnimationFrame(() => {
      var e4;
      null == (e4 = h2) || e4.observe(n2);
    })), t3();
  }), d && !c && h2.observe(d), h2.observe(n2));
  var g = c ? kv(e2) : null;
  return c && function n3() {
    var o3 = kv(e2);
    g && !Tv(g, o3) && t3();
    g = o3, v = requestAnimationFrame(n3);
  }(), t3(), () => {
    var e3;
    u.forEach((e4) => {
      a2 && e4.removeEventListener("scroll", t3), i2 && e4.removeEventListener("resize", t3);
    }), null == f || f(), null == (e3 = h2) || e3.disconnect(), h2 = null, c && cancelAnimationFrame(v);
  };
}
var Iv = function(e2) {
  return void 0 === e2 && (e2 = 0), {
    name: "offset",
    options: e2,
    fn: (n2) => i(function* () {
      var t3, o2, {
        x: a2,
        y: i2,
        placement: s2,
        middlewareData: l
      } = n2, c = yield function(e3, n3) {
        return Wu.apply(this, arguments);
      }(n2, e2);
      return s2 === (null == (t3 = l.offset) ? void 0 : t3.placement) && null != (o2 = l.arrow) && o2.alignmentOffset ? {} : {
        x: a2 + c.x,
        y: i2 + c.y,
        data: r(r({}, c), {}, {
          placement: s2
        })
      };
    })()
  };
};
var Uv = function(e2) {
  return void 0 === e2 && (e2 = {}), {
    name: "shift",
    options: e2,
    fn: (o2) => i(function* () {
      var {
        x: a2,
        y: i2,
        placement: s2
      } = o2, l = wu(e2, o2), {
        mainAxis: c = true,
        crossAxis: d = false,
        limiter: u = {
          fn: (e3) => {
            var {
              x: n2,
              y: t3
            } = e3;
            return {
              x: n2,
              y: t3
            };
          }
        }
      } = l, v = t2(l, n), f = {
        x: a2,
        y: i2
      }, p2 = yield _u(o2, v), h2 = Mu(ku(s2)), g = Cu(h2), m = f[g], b = f[h2];
      if (c) {
        var j = "y" === g ? "bottom" : "right";
        m = yu(m + p2["y" === g ? "top" : "left"], m, m - p2[j]);
      }
      if (d) {
        var x = "y" === h2 ? "bottom" : "right";
        b = yu(b + p2["y" === h2 ? "top" : "left"], b, b - p2[x]);
      }
      var y = u.fn(r(r({}, o2), {}, {
        [g]: m,
        [h2]: b
      }));
      return r(r({}, y), {}, {
        data: {
          x: y.x - a2,
          y: y.y - i2,
          enabled: {
            [g]: c,
            [h2]: d
          }
        }
      });
    })()
  };
};
var Dv = function(n2) {
  return void 0 === n2 && (n2 = {}), {
    name: "flip",
    options: n2,
    fn: (o2) => i(function* () {
      var r2, a2, {
        placement: i2,
        middlewareData: s2,
        rects: l,
        initialPlacement: c,
        platform: d,
        elements: u
      } = o2, v = wu(n2, o2), {
        mainAxis: f = true,
        crossAxis: p2 = true,
        fallbackPlacements: h2,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: b = true
      } = v, j = t2(v, e);
      if (null != (r2 = s2.arrow) && r2.alignmentOffset) return {};
      var x = ku(i2), y = Mu(c), w = ku(c) === c, k = yield null == d.isRTL ? void 0 : d.isRTL(u.floating), S = h2 || (w || !b ? [Iu(c)] : function(e2) {
        var n3 = Iu(e2);
        return [Au(e2), n3, Au(n3)];
      }(c)), C3 = "none" !== m;
      !h2 && C3 && S.push(...Nu(c, b, m, k));
      var z3 = [c, ...S], O = yield _u(o2, j), M2 = [], E = (null == (a2 = s2.flip) ? void 0 : a2.overflows) || [];
      if (f && M2.push(O[x]), p2) {
        var A2 = function(e2, n3, t3) {
          void 0 === t3 && (t3 = false);
          var o3 = Su(e2), r3 = Eu(e2), a3 = zu(r3), i3 = "x" === r3 ? o3 === (t3 ? "end" : "start") ? "right" : "left" : "start" === o3 ? "bottom" : "top";
          return n3.reference[a3] > n3.floating[a3] && (i3 = Iu(i3)), [i3, Iu(i3)];
        }(i2, l, k);
        M2.push(O[A2[0]], O[A2[1]]);
      }
      if (E = [...E, {
        placement: i2,
        overflows: M2
      }], !M2.every((e2) => e2 <= 0)) {
        var R, q2, P = ((null == (R = s2.flip) ? void 0 : R.index) || 0) + 1, T2 = z3[P];
        if (T2) {
          if (!("alignment" === p2 && y !== Mu(T2)) || E.every((e2) => e2.overflows[0] > 0 && Mu(e2.placement) === y)) return {
            data: {
              index: P,
              overflows: E
            },
            reset: {
              placement: T2
            }
          };
        }
        var N2 = null == (q2 = E.filter((e2) => e2.overflows[0] <= 0).sort((e2, n3) => e2.overflows[1] - n3.overflows[1])[0]) ? void 0 : q2.placement;
        if (!N2) switch (g) {
          case "bestFit":
            var I, U2 = null == (I = E.filter((e2) => {
              if (C3) {
                var n3 = Mu(e2.placement);
                return n3 === y || "y" === n3;
              }
              return true;
            }).map((e2) => [e2.placement, e2.overflows.filter((e3) => e3 > 0).reduce((e3, n3) => e3 + n3, 0)]).sort((e2, n3) => e2[1] - n3[1])[0]) ? void 0 : I[0];
            U2 && (N2 = U2);
            break;
          case "initialPlacement":
            N2 = c;
        }
        if (i2 !== N2) return {
          reset: {
            placement: N2
          }
        };
      }
      return {};
    })()
  };
};
function Jv(e2) {
  var n2, t3, o2 = {
    autoUpdate: true
  }, a2 = e2, i2 = (n3) => r(r(r({}, o2), e2 || {}), n3 || {}), s2 = (e3) => {
    n2 && t3 && (a2 = i2(e3), ((e4, n3, t4) => {
      var o3 = /* @__PURE__ */ new Map(), a3 = r({
        platform: Pv
      }, t4), i3 = r(r({}, a3.platform), {}, {
        _c: o3
      });
      return Bu(e4, n3, r(r({}, a3), {}, {
        platform: i3
      }));
    })(n2, t3, a2).then((e4) => {
      var n3;
      Object.assign(t3.style, {
        position: e4.strategy,
        left: "".concat(e4.x, "px"),
        top: "".concat(e4.y, "px")
      }), (null === (n3 = a2) || void 0 === n3 ? void 0 : n3.onComputed) && a2.onComputed(e4);
    }));
  }, l = (e3) => {
    oa(e3.subscribe((e4) => {
      void 0 === n2 ? (n2 = e4, s2()) : (Object.assign(n2, e4), s2());
    }));
  };
  return [(e3) => {
    if ("subscribe" in e3) return l(e3), {};
    n2 = e3, s2();
  }, (e3, o3) => {
    var r2;
    t3 = e3, a2 = i2(o3), setTimeout(() => s2(o3), 0), s2(o3);
    var l2 = () => {
      r2 && (r2(), r2 = void 0);
    }, c = function() {
      var {
        autoUpdate: e4
      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2 || {};
      l2(), false !== e4 && function() {
        return kr.apply(this, arguments);
      }().then(() => Nv(n2, t3, () => s2(a2), true === e4 ? {} : e4));
    };
    return r2 = c(), {
      update(e4) {
        s2(e4), r2 = c(e4);
      },
      destroy() {
        l2();
      }
    };
  }, s2];
}
function Bv(e2) {
  var {
    loadOptions: n2,
    filterText: t3,
    items: o2,
    multiple: r2,
    value: a2,
    itemId: i2,
    groupBy: s2,
    filterSelectedItems: l,
    itemFilter: c,
    convertStringItemsToObjects: d,
    filterGroupedItems: u,
    label: v
  } = e2;
  if (o2 && n2) return o2;
  if (!o2) return [];
  o2 && o2.length > 0 && "object" != typeof o2[0] && (o2 = d(o2));
  var f = o2.filter((e3) => {
    var n3 = c(e3[v], t3, e3);
    return n3 && r2 && null != a2 && a2.length && (n3 = !a2.some((n4) => !!l && n4[i2] === e3[i2])), n3;
  });
  return s2 && (f = u(f)), f;
}
function _v(e2) {
  return Fv.apply(this, arguments);
}
function Fv() {
  return (Fv = i(function* (e2) {
    var {
      dispatch: n2,
      loadOptions: t3,
      convertStringItemsToObjects: o2,
      filterText: r2
    } = e2, a2 = yield t3(r2).catch((e3) => {
      console.warn("svelte-select loadOptions error :>> ", e3), n2("error", {
        type: "loadOptions",
        details: e3
      });
    });
    if (a2 && !a2.cancelled) return a2 ? (a2 && a2.length > 0 && "object" != typeof a2[0] && (a2 = o2(a2)), n2("loaded", {
      items: a2
    })) : a2 = [], {
      filteredItems: a2,
      loading: false,
      focused: true,
      listOpen: true
    };
  })).apply(this, arguments);
}
Ds("\n  svg.svelte-qbd276 {\n      width: var(--chevron-icon-width, 20px);\n      height: var(--chevron-icon-width, 20px);\n      color: var(--chevron-icon-colour, currentColor);\n  }\n");
var Lv = Wr('<svg width="100%" height="100%" viewBox="0 0 20 20" focusable="false" aria-hidden="true" class="svelte-qbd276"><path fill="currentColor" d="M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"></path></svg>');
Ds("\n    svg.svelte-whdbu1 {\n        width: var(--clear-icon-width, 20px);\n        height: var(--clear-icon-width, 20px);\n        color: var(--clear-icon-color, currentColor);\n    }\n");
var Wv = Wr('<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="svelte-whdbu1"><path fill="currentColor" d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>');
function Vv(e2) {
  Hr(e2, Wv());
}
Ds("\n    .loading.svelte-1p3nqvd {\n        width: var(--spinner-width, 20px);\n        height: var(--spinner-height, 20px);\n        color: var(--spinner-color, var(--icons-color));\n        animation: svelte-1p3nqvd-rotate 0.75s linear infinite;\n        transform-origin: center center;\n        transform: none;\n    }\n\n    .circle_path.svelte-1p3nqvd {\n        stroke-dasharray: 90;\n        stroke-linecap: round;\n    }\n\n    @keyframes svelte-1p3nqvd-rotate {\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n");
var $v = Wr('<svg class="loading svelte-1p3nqvd" viewBox="25 25 50 50"><circle class="circle_path svelte-1p3nqvd" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>');
Ds("\n    .svelte-select.svelte-82qwg8 {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    .svelte-82qwg8 {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select.svelte-82qwg8:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container.svelte-82qwg8 {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend.svelte-82qwg8,\n    .indicators.svelte-82qwg8 {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators.svelte-82qwg8 {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input.svelte-82qwg8 {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    .svelte-82qwg8:not(.multi) > .value-container:where(.svelte-82qwg8) > input:where(.svelte-82qwg8) {\n        width: 100%;\n        height: 100%;\n    }\n\n    input.svelte-82qwg8::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input.svelte-82qwg8:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused.svelte-82qwg8 {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled.svelte-82qwg8 {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled.svelte-82qwg8 input:where(.svelte-82qwg8)::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item.svelte-82qwg8 {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi.svelte-82qwg8 .selected-item:where(.svelte-82qwg8) {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item.svelte-82qwg8:focus {\n        outline: none;\n    }\n\n    .hide-selected-item.svelte-82qwg8 {\n        opacity: 0;\n    }\n\n    .icon.svelte-82qwg8 {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select.svelte-82qwg8 {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select.svelte-82qwg8:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading.svelte-82qwg8 {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron.svelte-82qwg8 {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi.svelte-82qwg8 {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi.svelte-82qwg8 input:where(.svelte-82qwg8) {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error.svelte-82qwg8 {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text.svelte-82qwg8 {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item.svelte-82qwg8 {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled.svelte-82qwg8:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text.svelte-82qwg8 {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear.svelte-82qwg8 {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active.svelte-82qwg8 {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list.svelte-82qwg8 {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat.svelte-82qwg8 {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title.svelte-82qwg8 {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty.svelte-82qwg8 {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item.svelte-82qwg8 {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item.svelte-82qwg8 {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item.svelte-82qwg8:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active.svelte-82qwg8 {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first.svelte-82qwg8 {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover.svelte-82qwg8:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable.svelte-82qwg8,\n    .item.hover.item.not-selectable.svelte-82qwg8,\n    .item.active.item.not-selectable.svelte-82qwg8,\n    .item.not-selectable.svelte-82qwg8:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required.svelte-82qwg8 {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n");
var Hv = Lr('<div class="list-item svelte-82qwg8" tabindex="-1" role="none"><div><!></div></div>');
var Qv = Lr('<div class="empty svelte-82qwg8">No options</div>');
var Yv = Lr('<div role="none"><!> <!> <!></div>');
var Kv = Lr('<span id="aria-selection" class="svelte-82qwg8"> </span> <span id="aria-context" class="svelte-82qwg8"> </span>', 1);
var Zv = Lr('<div class="multi-item-clear svelte-82qwg8"><!></div>');
var Xv = Lr('<div role="none"><span class="multi-item-text svelte-82qwg8"><!></span> <!></div>');
var Gv = Lr("<div><!></div>");
var ef = Lr('<div class="icon loading svelte-82qwg8" aria-hidden="true"><!></div>');
var nf = Lr('<button type="button" class="icon clear-select svelte-82qwg8"><!></button>');
var tf = Lr('<div class="icon chevron svelte-82qwg8" aria-hidden="true"><!></div>');
var of = Lr('<input type="hidden" class="svelte-82qwg8"/>');
var rf = Lr('<select class="required svelte-82qwg8" required tabindex="-1" aria-hidden="true"></select>');
var af = Lr('<div role="none"><!> <span aria-live="polite" aria-atomic="false" aria-relevant="additions text" class="a11y-text svelte-82qwg8"><!></span> <div class="prepend svelte-82qwg8"><!></div> <div class="value-container svelte-82qwg8"><!> <input/></div> <div class="indicators svelte-82qwg8"><!> <!> <!></div> <!> <!></div>');
function sf(e2, n2) {
  var t3 = function(e3) {
    var n3 = {};
    for (var t4 in e3.children && (n3.default = true), e3.$$slots) n3[t4] = true;
    return n3;
  }(n2);
  Tt(n2, false);
  var o2, a2 = Kt(), s2 = Kt(), l = Kt(), c = Kt(), d = Kt(), u = Kt(), v = Kt(), f = Kt(), p2 = Kt(), h2 = ra(), g = ai(n2, "justValue", 12, null), m = ai(n2, "filter", 8, Bv), b = ai(n2, "getItems", 8, _v), j = ai(n2, "id", 8, null), x = ai(n2, "name", 8, null), y = ai(n2, "container", 12, void 0), w = ai(n2, "input", 12, void 0), k = ai(n2, "multiple", 8, false), S = ai(n2, "multiFullItemClearable", 8, false), C3 = ai(n2, "disabled", 8, false), z3 = ai(n2, "focused", 12, false), O = ai(n2, "value", 12, null), M2 = ai(n2, "filterText", 12, ""), E = ai(n2, "placeholder", 8, "Please select"), A2 = ai(n2, "placeholderAlwaysShow", 8, false), R = ai(n2, "items", 12, null), q2 = ai(n2, "label", 8, "label"), P = ai(n2, "itemFilter", 8, (e3, n3, t4) => "".concat(e3).toLowerCase().includes(n3.toLowerCase())), T2 = ai(n2, "groupBy", 8, void 0), N2 = ai(n2, "groupFilter", 8, (e3) => e3), I = ai(n2, "groupHeaderSelectable", 8, false), U2 = ai(n2, "itemId", 8, "value"), D2 = ai(n2, "loadOptions", 8, void 0), J = ai(n2, "containerStyles", 8, ""), B = ai(n2, "hasError", 8, false), _ = ai(n2, "filterSelectedItems", 8, true), F2 = ai(n2, "required", 8, false), L = ai(n2, "closeListOnChange", 8, true), W2 = ai(n2, "clearFilterTextOnBlur", 8, true), V2 = ai(n2, "createGroupHeaderItem", 8, (e3, n3) => ({
    value: e3,
    [q2()]: e3
  })), $ = () => Sr(v), H2 = ai(n2, "searchable", 8, true), Q = ai(n2, "inputStyles", 8, ""), Y2 = ai(n2, "clearable", 8, true), K = ai(n2, "loading", 12, false), Z2 = ai(n2, "listOpen", 12, false), X2 = ai(n2, "debounce", 8, function(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    clearTimeout(o2), o2 = setTimeout(e3, n3);
  }), G2 = ai(n2, "debounceWait", 8, 300), ee = ai(n2, "hideEmptyState", 8, false), ne = ai(n2, "inputAttributes", 24, () => ({})), te = ai(n2, "listAutoWidth", 8, true), oe = ai(n2, "showChevron", 8, false), re = ai(n2, "listOffset", 8, 5), ae = ai(n2, "hoverItemIndex", 12, 0), ie3 = ai(n2, "floatingConfig", 24, () => ({})), se = ai(n2, "class", 8, ""), le = Kt(), ce = Kt(), de = Kt(), ue = Kt();
  var ve = Kt();
  function fe(e3) {
    return e3.map((e4, n3) => ({
      index: n3,
      value: e4,
      label: "".concat(e4)
    }));
  }
  function pe(e3) {
    var n3 = [], t4 = {};
    e3.forEach((e4) => {
      var o4 = T2()(e4);
      n3.includes(o4) || (n3.push(o4), t4[o4] = [], o4 && t4[o4].push(Object.assign(V2()(o4, e4), {
        id: o4,
        groupHeader: true,
        selectable: I()
      }))), t4[o4].push(Object.assign({
        groupItem: !!o4
      }, e4));
    });
    var o3 = [];
    return N2()(n3).forEach((e4) => {
      t4[e4] && o3.push(...t4[e4]);
    }), o3;
  }
  function he() {
    var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n3 = arguments.length > 1 ? arguments[1] : void 0;
    ae(e3 < 0 ? 0 : e3), !n3 && T2() && Sr(v)[ae()] && !Sr(v)[ae()].selectable && Ie(1);
  }
  function ge() {
    var e3 = true;
    if (O()) {
      var n3 = [], t4 = [];
      O().forEach((o3) => {
        n3.includes(o3[U2()]) ? e3 = false : (n3.push(o3[U2()]), t4.push(o3));
      }), e3 || O(t4);
    }
    return e3;
  }
  function me(e3) {
    var n3 = e3 ? e3[U2()] : O()[U2()];
    return R().find((e4) => e4[U2()] === n3);
  }
  function be(e3) {
    return je.apply(this, arguments);
  }
  function je() {
    return (je = i(function* (e3) {
      var n3 = O()[e3];
      1 === O().length ? O(void 0) : O(O().filter((e4) => e4 !== n3)), h2("clear", n3);
    })).apply(this, arguments);
  }
  function xe(e3) {
    if (z3()) switch (e3.stopPropagation(), e3.key) {
      case "Escape":
        e3.preventDefault(), ze();
        break;
      case "Enter":
        if (e3.preventDefault(), Z2()) {
          if (0 === Sr(v).length) break;
          var n3 = Sr(v)[ae()];
          if (O() && !k() && O()[U2()] === n3[U2()]) {
            ze();
            break;
          }
          Te(Sr(v)[ae()]);
        }
        break;
      case "ArrowDown":
        e3.preventDefault(), Z2() ? Ie(1) : (Z2(true), Xt(le, void 0));
        break;
      case "ArrowUp":
        e3.preventDefault(), Z2() ? Ie(-1) : (Z2(true), Xt(le, void 0));
        break;
      case "Tab":
        if (Z2() && z3()) {
          if (0 === Sr(v).length || O() && O()[U2()] === Sr(v)[ae()][U2()]) return ze();
          e3.preventDefault(), Te(Sr(v)[ae()]), ze();
        }
        break;
      case "Backspace":
        if (!k() || M2().length > 0) return;
        if (k() && O() && O().length > 0) {
          if (be(void 0 !== Sr(le) ? Sr(le) : O().length - 1), 0 === Sr(le) || void 0 === Sr(le)) break;
          Xt(le, O().length > Sr(le) ? Sr(le) - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!O() || !k() || M2().length > 0) return;
        void 0 === Sr(le) ? Xt(le, O().length - 1) : O().length > Sr(le) && 0 !== Sr(le) && Xt(le, Sr(le) - 1);
        break;
      case "ArrowRight":
        if (!O() || !k() || M2().length > 0 || void 0 === Sr(le)) return;
        Sr(le) === O().length - 1 ? Xt(le, void 0) : Sr(le) < O().length - 1 && Xt(le, Sr(le) + 1);
    }
  }
  function ye(e3) {
    var n3, t4;
    z3() && w() === (null === (n3 = document) || void 0 === n3 ? void 0 : n3.activeElement) || (e3 && h2("focus", e3), null === (t4 = w()) || void 0 === t4 || t4.focus(), z3(true));
  }
  function we(e3) {
    return ke.apply(this, arguments);
  }
  function ke() {
    return (ke = i(function* (e3) {
      var n3;
      Pe || (Z2() || z3()) && (h2("blur", e3), ze(), z3(false), Xt(le, void 0), null === (n3 = w()) || void 0 === n3 || n3.blur());
    })).apply(this, arguments);
  }
  function Se() {
    if (!C3()) return M2().length > 0 ? Z2(true) : void Z2(!Z2());
  }
  function Ce() {
    h2("clear", O()), O(void 0), ze(), ye();
  }
  function ze() {
    W2() && M2(""), Z2(false);
  }
  aa(i(function* () {
    Xt(ce, O()), Xt(de, M2()), Xt(ue, k());
  })), ta(() => {
    Z2() && z3(true), z3() && w() && w().focus();
  });
  var Oe = ai(n2, "ariaValues", 8, (e3) => "Option ".concat(e3, ", selected.")), Me = ai(n2, "ariaListOpen", 8, (e3, n3) => "You are currently focused on option ".concat(e3, ". There are ").concat(n3, " results available.")), Ee = ai(n2, "ariaFocused", 8, () => "Select is focused, type to refine list, press down to open the menu.");
  var Ae, Re = Kt(null);
  function qe() {
    clearTimeout(Ae), Ae = setTimeout(() => {
      Pe = false;
    }, 100);
  }
  oa(() => {
    var e3;
    null === (e3 = Sr(Re)) || void 0 === e3 || e3.remove();
  });
  var Pe = false;
  function Te(e3) {
    e3 && false !== e3.selectable && function(e4) {
      if (e4) {
        M2("");
        var n3 = Object.assign({}, e4);
        if (n3.groupHeader && !n3.selectable) return;
        O(k() ? O() ? O().concat([n3]) : [n3] : O(n3)), setTimeout(() => {
          L() && ze(), Xt(le, void 0), h2("change", O()), h2("select", e4);
        });
      }
    }(e3);
  }
  function Ne(e3) {
    Pe || ae(e3);
  }
  function Ie(e3) {
    if (0 === Sr(v).filter((e4) => !Object.hasOwn(e4, "selectable") || true === e4.selectable).length) return ae(0);
    e3 > 0 && ae() === Sr(v).length - 1 ? ae(0) : e3 < 0 && 0 === ae() ? ae(Sr(v).length - 1) : ae(ae() + e3);
    var n3 = Sr(v)[ae()];
    n3 && false === n3.selectable && (1 !== e3 && -1 !== e3 || Ie(e3));
  }
  function Ue(e3, n3, t4) {
    if (!k()) return n3 && n3[t4] === e3[t4];
  }
  var De = Be, Je = Be;
  function Be(e3) {
    return {
      update(n3) {
        n3.scroll && (qe(), e3.scrollIntoView({
          behavior: "auto",
          block: "nearest"
        }));
      }
    };
  }
  var _e = Kt({
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [Iv(re()), Dv(), Uv()],
    autoUpdate: false
  }), [Fe2, Le, We2] = Jv(Sr(_e)), Ve2 = Kt(true);
  xo(() => (Ar(R()), Ar(O())), () => {
    R(), O() && function() {
      if ("string" == typeof O()) {
        var e3 = (R() || []).find((e4) => e4[U2()] === O());
        O(e3 || {
          [U2()]: O(),
          label: O()
        });
      } else k() && Array.isArray(O()) && O().length > 0 && O(O().map((e4) => "string" == typeof e4 ? {
        value: e4,
        label: e4
      } : e4));
    }();
  }), xo(() => (Ar(ne()), Ar(H2())), () => {
    !ne() && H2() || (Xt(ve, Object.assign({
      autocapitalize: "none",
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: false,
      tabindex: 0,
      type: "text",
      "aria-autocomplete": "list"
    }, ne())), j() && Zt(ve, Sr(ve).id = j()), H2() || Zt(ve, Sr(ve).readonly = true));
  }), xo(() => Ar(k()), () => {
    k() && O() && (Array.isArray(O()) ? O([...O()]) : O([O()]));
  }), xo(() => (Sr(ue), Ar(k())), () => {
    Sr(ue) && !k() && O() && O(null);
  }), xo(() => (Ar(k()), Ar(O())), () => {
    k() && O() && O().length > 1 && ge();
  }), xo(() => Ar(O()), () => {
    O() && (k() ? JSON.stringify(O()) !== JSON.stringify(Sr(ce)) && ge() && h2("input", O()) : Sr(ce) && JSON.stringify(O()[U2()]) === JSON.stringify(Sr(ce)[U2()]) || h2("input", O()));
  }), xo(() => (Ar(O()), Ar(k()), Sr(ce)), () => {
    !O() && k() && Sr(ce) && h2("input", O());
  }), xo(() => (Ar(z3()), Ar(w())), () => {
    !z3() && w() && ze();
  }), xo(() => (Ar(M2()), Sr(de)), () => {
    M2() !== Sr(de) && (D2() || 0 !== M2().length) && (D2() ? X2()(i(function* () {
      K(true);
      var e3 = yield b()({
        dispatch: h2,
        loadOptions: D2(),
        convertStringItemsToObjects: fe,
        filterText: M2()
      });
      e3 ? (K(e3.loading), Z2(Z2() ? e3.listOpen : M2().length > 0), z3(Z2() && e3.focused), R(T2() ? pe(e3.filteredItems) : e3.filteredItems)) : (K(false), z3(true), Z2(true));
    }), G2()) : (Z2(true), k() && Xt(le, void 0)));
  }), xo(() => (Ar(m()), Ar(D2()), Ar(M2()), Ar(R()), Ar(k()), Ar(O()), Ar(U2()), Ar(T2()), Ar(q2()), Ar(_()), Ar(P())), () => {
    Xt(v, m()({
      loadOptions: D2(),
      filterText: M2(),
      items: R(),
      multiple: k(),
      value: O(),
      itemId: U2(),
      groupBy: T2(),
      label: q2(),
      filterSelectedItems: _(),
      itemFilter: P(),
      convertStringItemsToObjects: fe,
      filterGroupedItems: pe
    }));
  }), xo(() => (Ar(k()), Ar(Z2()), Ar(O()), Sr(v)), () => {
    !k() && Z2() && O() && Sr(v) && he(Sr(v).findIndex((e3) => e3[U2()] === O()[U2()]), true);
  }), xo(() => (Ar(Z2()), Ar(k())), () => {
    Z2() && k() && ae(0);
  }), xo(() => Ar(M2()), () => {
    M2() && ae(0);
  }), xo(() => Ar(ae()), () => {
    var e3;
    e3 = ae(), h2("hoverItem", e3);
  }), xo(() => (Ar(k()), Ar(O())), () => {
    Xt(a2, k() ? O() && O().length > 0 : O());
  }), xo(() => (Sr(a2), Ar(M2())), () => {
    Xt(s2, Sr(a2) && M2().length > 0);
  }), xo(() => (Sr(a2), Ar(Y2()), Ar(C3()), Ar(K())), () => {
    Xt(l, Sr(a2) && Y2() && !C3() && !K());
  }), xo(() => (Ar(A2()), Ar(k()), Ar(E()), Ar(O())), () => {
    var e3;
    Xt(c, A2() && k() || k() && 0 === (null === (e3 = O()) || void 0 === e3 ? void 0 : e3.length) ? E() : O() ? "" : E());
  }), xo(() => (Ar(O()), Ar(k())), () => {
    var e3, n3;
    Xt(d, O() ? (e3 = k(), n3 = void 0, n3 = e3 && O().length > 0 ? O().map((e4) => e4[q2()]).join(", ") : O()[q2()], Oe()(n3)) : "");
  }), xo(() => (Sr(v), Ar(ae()), Ar(z3()), Ar(Z2())), () => {
    Xt(u, function() {
      if (!Sr(v) || 0 === Sr(v).length) return "";
      var e3 = Sr(v)[ae()];
      if (Z2() && e3) {
        var n3 = Sr(v) ? Sr(v).length : 0;
        return Me()(e3[q2()], n3);
      }
      return Ee()();
    }((Sr(v), ae(), z3(), Z2())));
  }), xo(() => Ar(R()), () => {
    !function(e3) {
      e3 && 0 !== e3.length && !e3.some((e4) => "object" != typeof e4) && O() && (k() ? !O().some((e4) => !e4 || !e4[U2()]) : O()[U2()]) && (Array.isArray(O()) ? O(O().map((e4) => me(e4) || e4)) : O(me() || O()));
    }(R());
  }), xo(() => (Ar(k()), Ar(O()), Ar(U2())), () => {
    g((k(), O(), U2(), k() ? O() ? O().map((e3) => e3[U2()]) : null : O() ? O()[U2()] : O()));
  }), xo(() => (Ar(k()), Sr(ce), Ar(O())), () => {
    k() || !Sr(ce) || O() || h2("input", O());
  }), xo(() => (Ar(Z2()), Sr(v), Ar(k()), Ar(O())), () => {
    Z2() && Sr(v) && !k() && !O() && he();
  }), xo(() => Sr(v), () => {
    !function(e3) {
      Z2() && h2("filter", e3);
    }(Sr(v));
  }), xo(() => (Ar(y()), Ar(ie3()), Sr(_e)), () => {
    y() && ie3() && We2(Object.assign(Sr(_e), ie3()));
  }), xo(() => Sr(Re), () => {
    Xt(f, !!Sr(Re));
  }), xo(() => (Sr(Re), Ar(Z2())), () => {
    !function(e3, n3) {
      if (!e3 || !n3) return Xt(Ve2, true);
      setTimeout(() => {
        Xt(Ve2, false);
      }, 0);
    }(Sr(Re), Z2());
  }), xo(() => (Ar(Z2()), Ar(y()), Sr(Re)), () => {
    Z2() && y() && Sr(Re) && function() {
      var {
        width: e3
      } = y().getBoundingClientRect();
      Zt(Re, Sr(Re).style.width = te() ? e3 + "px" : "auto");
    }();
  }), xo(() => Ar(ae()), () => {
    Xt(p2, ae());
  }), xo(() => (Ar(w()), Ar(Z2()), Ar(z3())), () => {
    w() && Z2() && !z3() && ye();
  }), xo(() => (Ar(y()), Ar(ie3())), () => {
    var e3;
    y() && void 0 === (null === (e3 = ie3()) || void 0 === e3 ? void 0 : e3.autoUpdate) && Zt(_e, Sr(_e).autoUpdate = true);
  }), yo(), Ka();
  var $e, He = af();
  Dr("click", oo, function(e3) {
    var n3;
    Z2() || z3() || !y() || y().contains(e3.target) || null !== (n3 = Sr(Re)) && void 0 !== n3 && n3.contains(e3.target) || we();
  }), Dr("keydown", oo, xe);
  var Qe = uo(He), Ye = (e3) => {
    var o3, r2 = Yv(), a3 = uo(r2), i2 = (e4) => {
      var t4 = $r();
      ga(vo(t4), n2, "list-prepend", {}, null), Hr(e4, t4);
    };
    sa(a3, (e4) => {
      Or(() => t3["list-prepend"]) && e4(i2);
    });
    var s3 = fo(a3, 2), l2 = (e4) => {
      var t4 = $r();
      ga(vo(t4), n2, "list", {
        get filteredItems() {
          return Sr(v);
        }
      }, null), Hr(e4, t4);
    }, c2 = (e4, t4) => {
      var o4 = (e5) => {
        var t5 = $r();
        da(vo(t5), 1, () => Sr(v), ca, (e6, t6, o5) => {
          var r4, a4 = Hv(), i3 = uo(a4);
          ga(uo(i3), n2, "item", {
            get item() {
              return Sr(t6);
            },
            index: o5
          }, (e7) => {
            var n3 = Vr();
            ko(() => Xr(n3, (Sr(t6), Ar(q2()), Or(() => {
              var e8;
              return null === (e8 = Sr(t6)) || void 0 === e8 ? void 0 : e8[q2()];
            })))), Hr(e7, n3);
          }), ba(i3, (e7, n3) => null == De ? void 0 : De(e7), () => ({
            scroll: Ue(Sr(t6), O(), U2()),
            listDom: Sr(f)
          })), ba(i3, (e7, n3) => null == Je ? void 0 : Je(e7), () => ({
            scroll: Sr(p2) === o5,
            listDom: Sr(f)
          })), ko((e7) => r4 = Ca(i3, 1, "item svelte-82qwg8", null, r4, e7), [() => {
            var e7, n3;
            return {
              "list-group-title": Sr(t6).groupHeader,
              active: Ue(Sr(t6), O(), U2()),
              first: (n3 = o5, 0 === n3),
              hover: ae() === o5,
              "group-item": Sr(t6).groupItem,
              "not-selectable": false === (null === (e7 = Sr(t6)) || void 0 === e7 ? void 0 : e7.selectable)
            };
          }], Lt), Dr("mouseover", a4, () => Ne(o5)), Dr("focus", a4, () => Ne(o5)), Dr("click", a4, Qa(() => function(e7) {
            var {
              item: n3,
              i: t7
            } = e7;
            if (false !== (null == n3 ? void 0 : n3.selectable)) return O() && !k() && O()[U2()] === n3[U2()] ? ze() : void (function(e8) {
              return e8.groupHeader && e8.selectable || e8.selectable || !e8.hasOwnProperty("selectable");
            }(n3) && (ae(t7), Te(n3)));
          }({
            item: Sr(t6),
            i: o5
          }))), Dr("keydown", a4, Ya(Qa(function(e7) {
            Ga.call(this, n2, e7);
          }))), Hr(e6, a4);
        }), Hr(e5, t5);
      }, r3 = (e5, t5) => {
        var o5 = (e6) => {
          var t6 = $r();
          ga(vo(t6), n2, "empty", {}, (e7) => {
            Hr(e7, Qv());
          }), Hr(e6, t6);
        };
        sa(e5, (e6) => {
          ee() || e6(o5);
        }, t5);
      };
      sa(e4, (e5) => {
        Sr(v), Or(() => Sr(v).length > 0) ? e5(o4) : e5(r3, false);
      }, t4);
    };
    sa(s3, (e4) => {
      Or(() => t3.list) ? e4(l2) : e4(c2, false);
    });
    var d2 = fo(s3, 2), u2 = (e4) => {
      var t4 = $r();
      ga(vo(t4), n2, "list-append", {}, null), Hr(e4, t4);
    };
    sa(d2, (e4) => {
      Or(() => t3["list-append"]) && e4(u2);
    }), ba(r2, (e4) => null == Le ? void 0 : Le(e4)), Ha(r2, (e4) => Xt(Re, e4), () => Sr(Re)), jo(() => Dr("scroll", r2, qe)), jo(() => Dr("pointerup", r2, Ya(Qa(function(e4) {
      Ga.call(this, n2, e4);
    })))), jo(() => Dr("mousedown", r2, Ya(Qa(function(e4) {
      Ga.call(this, n2, e4);
    })))), ko((e4) => o3 = Ca(r2, 1, "svelte-select-list svelte-82qwg8", null, o3, e4), [() => ({
      prefloat: Sr(Ve2)
    })], Lt), Hr(e3, r2);
  };
  sa(Qe, (e3) => {
    Z2() && e3(Ye);
  });
  var Ke = fo(Qe, 2), Ze = uo(Ke), Xe = (e3) => {
    var n3 = Kv(), t4 = vo(n3), o3 = uo(t4), r2 = uo(fo(t4, 2));
    ko(() => {
      Xr(o3, Sr(d)), Xr(r2, Sr(u));
    }), Hr(e3, n3);
  };
  sa(Ze, (e3) => {
    z3() && e3(Xe);
  });
  var Ge = fo(Ke, 2);
  ga(uo(Ge), n2, "prepend", {}, null);
  var en = fo(Ge, 2), nn = uo(en), tn = (e3) => {
    var t4 = $r(), o3 = vo(t4), r2 = (e4) => {
      var t5 = $r();
      da(vo(t5), 1, O, ca, (e5, t6, o4) => {
        var r3, a4 = Xv(), i2 = uo(a4);
        ga(uo(i2), n2, "selection", {
          get selection() {
            return Sr(t6);
          },
          index: o4
        }, (e6) => {
          var n3 = Vr();
          ko(() => Xr(n3, (Sr(t6), Ar(q2()), Or(() => Sr(t6)[q2()])))), Hr(e6, n3);
        });
        var s3 = fo(i2, 2), l2 = (e6) => {
          var t7 = Zv();
          ga(uo(t7), n2, "multi-clear-icon", {}, (e7) => {
            Vv(e7);
          }), Dr("pointerup", t7, Ya(Qa(() => be(o4)))), Hr(e6, t7);
        };
        sa(s3, (e6) => {
          C3() || S() || !Vv || e6(l2);
        }), ko((e6) => r3 = Ca(a4, 1, "multi-item svelte-82qwg8", null, r3, e6), [() => ({
          active: Sr(le) === o4,
          disabled: C3()
        })], Lt), Dr("click", a4, Ya(() => S() ? be(o4) : {})), Dr("keydown", a4, Ya(Qa(function(e6) {
          Ga.call(this, n2, e6);
        }))), Hr(e5, a4);
      }), Hr(e4, t5);
    }, a3 = (e4) => {
      var t5, o4 = Gv();
      ga(uo(o4), n2, "selection", {
        get selection() {
          return O();
        }
      }, (e5) => {
        var n3 = Vr();
        ko(() => Xr(n3, (Ar(O()), Ar(q2()), Or(() => O()[q2()])))), Hr(e5, n3);
      }), ko((e5) => t5 = Ca(o4, 1, "selected-item svelte-82qwg8", null, t5, e5), [() => ({
        "hide-selected-item": Sr(s2)
      })], Lt), Hr(e4, o4);
    };
    sa(o3, (e4) => {
      k() ? e4(r2) : e4(a3, false);
    }), Hr(e3, t4);
  };
  sa(nn, (e3) => {
    Sr(a2) && e3(tn);
  });
  var on = fo(nn, 2);
  Da(on, () => r(r({
    readOnly: !H2()
  }, Sr(ve)), {}, {
    placeholder: Sr(c),
    style: Q(),
    disabled: C3()
  }), void 0, "svelte-82qwg8"), Ha(on, (e3) => w(e3), () => w());
  var rn = fo(en, 2), an = uo(rn), sn = (e3) => {
    var t4 = ef();
    ga(uo(t4), n2, "loading-icon", {}, (e4) => {
      !function(e5) {
        Hr(e5, $v());
      }(e4);
    }), Hr(e3, t4);
  };
  sa(an, (e3) => {
    K() && e3(sn);
  });
  var ln = fo(an, 2), cn = (e3) => {
    var t4 = nf();
    ga(uo(t4), n2, "clear-icon", {}, (e4) => {
      Vv(e4);
    }), Dr("click", t4, Ce), Hr(e3, t4);
  };
  sa(ln, (e3) => {
    Sr(l) && e3(cn);
  });
  var dn = fo(ln, 2), un = (e3) => {
    var t4 = tf();
    ga(uo(t4), n2, "chevron-icon", {
      get listOpen() {
        return Z2();
      }
    }, (e4) => {
      !function(e5) {
        Hr(e5, Lv());
      }(e4);
    }), Hr(e3, t4);
  };
  sa(dn, (e3) => {
    oe() && e3(un);
  });
  var vn = fo(rn, 2);
  ga(vn, n2, "input-hidden", {
    get value() {
      return O();
    }
  }, (e3) => {
    var n3 = of();
    ko((e4) => {
      Ia(n3, "name", x()), Na(n3, e4);
    }, [() => (Ar(O()), Or(() => O() ? JSON.stringify(O()) : null))], Lt), Hr(e3, n3);
  });
  var fn = fo(vn, 2), pn = (e3) => {
    var t4 = $r();
    ga(vo(t4), n2, "required", {
      get value() {
        return O();
      }
    }, (e4) => {
      Hr(e4, rf());
    }), Hr(e3, t4);
  };
  return sa(fn, (e3) => {
    Ar(F2()), Ar(O()), Or(() => F2() && (!O() || 0 === O().length)) && e3(pn);
  }), jo(() => Dr("pointerup", He, Ya(Se))), Ha(He, (e3) => y(e3), () => y()), ba(He, (e3) => null == Fe2 ? void 0 : Fe2(e3)), ko((e3) => {
    var n3;
    $e = Ca(He, 1, "svelte-select ".concat(null !== (n3 = se()) && void 0 !== n3 ? n3 : ""), "svelte-82qwg8", $e, e3), Oa(He, J());
  }, [() => ({
    multi: k(),
    disabled: C3(),
    focused: z3(),
    "list-open": Z2(),
    "show-chevron": oe(),
    error: B()
  })], Lt), Dr("keydown", on, xe), Dr("blur", on, we), Dr("focus", on, ye), Fa(on, M2), Hr(e2, He), Va(n2, "getFilteredItems", $), Va(n2, "handleClear", Ce), Nt({
    getFilteredItems: $,
    handleClear: Ce
  });
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\ntable.jse-transform-wizard.svelte-qbze6z {\n  border-collapse: collapse;\n  border-spacing: 0;\n  width: 100%;\n}\ntable.jse-transform-wizard.svelte-qbze6z input:where(.svelte-qbze6z) {\n  font-family: inherit;\n  font-size: inherit;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) th:where(.svelte-qbze6z) {\n  font-weight: normal;\n  text-align: left;\n  width: 60px;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) {\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n  margin-bottom: calc(0.5 * var(--jse-padding, 10px));\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select .multi-item {\n  align-items: center;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select .value-container {\n  gap: 0 !important;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select.jse-filter-path {\n  flex: 4;\n  margin-right: calc(0.5 * var(--jse-padding, 10px));\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select.jse-filter-relation {\n  flex: 1.5;\n  margin-right: calc(0.5 * var(--jse-padding, 10px));\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select.jse-sort-path {\n  flex: 3;\n  margin-right: calc(0.5 * var(--jse-padding, 10px));\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select.jse-sort-direction {\n  flex: 1;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select.jse-projection-paths {\n  flex: 1;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .svelte-select input {\n  box-sizing: border-box;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .jse-filter-value:where(.svelte-qbze6z) {\n  flex: 4;\n  padding: 4px 8px;\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  border-radius: var(--jse-input-radius, 3px);\n  outline: none;\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n  color: inherit;\n}\ntable.jse-transform-wizard.svelte-qbze6z tr:where(.svelte-qbze6z) td:where(.svelte-qbze6z) .jse-horizontal:where(.svelte-qbze6z) .jse-filter-value:where(.svelte-qbze6z):focus {\n  border: var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)));\n}');
var lf = Lr('<table class="jse-transform-wizard svelte-qbze6z"><tbody><tr class="svelte-qbze6z"><th class="svelte-qbze6z">Filter</th><td class="svelte-qbze6z"><div class="jse-horizontal svelte-qbze6z"><!> <!> <input class="jse-filter-value svelte-qbze6z"/></div></td></tr><tr class="svelte-qbze6z"><th class="svelte-qbze6z">Sort</th><td class="svelte-qbze6z"><div class="jse-horizontal svelte-qbze6z"><!> <!></div></td></tr><tr class="svelte-qbze6z"><th class="svelte-qbze6z">Pick</th><td class="svelte-qbze6z"><div class="jse-horizontal svelte-qbze6z"><!></div></td></tr></tbody></table>');
function cf(e2, n2) {
  var t3, o2, r2, a2, i2;
  Tt(n2, false);
  var s2 = Kt(void 0, true), l = Kt(void 0, true), c = Kt(void 0, true), d = Kt(void 0, true), u = Kt(void 0, true), f = Kt(void 0, true), p2 = ii("jsoneditor:TransformWizard"), h2 = ai(n2, "json", 9), g = ai(n2, "queryOptions", 29, () => ({})), m = ai(n2, "onChange", 9), b = ["==", "!=", "<", "<=", ">", ">="].map((e3) => ({
    value: e3,
    label: e3
  })), j = [{
    value: "asc",
    label: "ascending"
  }, {
    value: "desc",
    label: "descending"
  }], x = Kt(null !== (t3 = g()) && void 0 !== t3 && null !== (t3 = t3.filter) && void 0 !== t3 && t3.path ? su(g().filter.path) : void 0, true), y = Kt(null !== (o2 = b.find((e3) => {
    var n3;
    return e3.value === (null === (n3 = g().filter) || void 0 === n3 ? void 0 : n3.relation);
  })) && void 0 !== o2 ? o2 : b[0], true), w = Kt((null === (r2 = g()) || void 0 === r2 || null === (r2 = r2.filter) || void 0 === r2 ? void 0 : r2.value) || "", true), k = Kt(null !== (a2 = g()) && void 0 !== a2 && null !== (a2 = a2.sort) && void 0 !== a2 && a2.path ? su(g().sort.path) : void 0, true), S = Kt(null !== (i2 = j.find((e3) => {
    var n3;
    return e3.value === (null === (n3 = g().sort) || void 0 === n3 ? void 0 : n3.direction);
  })) && void 0 !== i2 ? i2 : j[0], true);
  xo(() => Ar(h2()), () => {
    Xt(s2, Array.isArray(h2()));
  }), xo(() => (Sr(s2), Ar(h2())), () => {
    Xt(l, Sr(s2) ? Ei(h2()) : []);
  }), xo(() => (Sr(s2), Ar(h2())), () => {
    Xt(c, Sr(s2) ? Ei(h2(), true) : []);
  }), xo(() => (Sr(l), su), () => {
    Xt(d, Sr(l).map(su));
  }), xo(() => (Sr(c), su), () => {
    Xt(u, Sr(c) ? Sr(c).map(su) : []);
  }), xo(() => (Ar(g()), Sr(u), isEqual_default), () => {
    var e3;
    Xt(f, null !== (e3 = g()) && void 0 !== e3 && null !== (e3 = e3.projection) && void 0 !== e3 && e3.paths && Sr(u) ? g().projection.paths.map((e4) => Sr(u).find((n3) => isEqual_default(n3.value, e4))).filter((e4) => !!e4) : void 0);
  }), xo(() => Sr(x), () => {
    var e3, n3, t4;
    n3 = null === (e3 = Sr(x)) || void 0 === e3 ? void 0 : e3.value, isEqual_default(null === (t4 = g()) || void 0 === t4 || null === (t4 = t4.filter) || void 0 === t4 ? void 0 : t4.path, n3) || (p2("changeFilterPath", n3), g(setIn(g(), ["filter", "path"], n3, true)), m()(g()));
  }), xo(() => Sr(y), () => {
    var e3, n3, t4;
    n3 = null === (e3 = Sr(y)) || void 0 === e3 ? void 0 : e3.value, isEqual_default(null === (t4 = g()) || void 0 === t4 || null === (t4 = t4.filter) || void 0 === t4 ? void 0 : t4.relation, n3) || (p2("changeFilterRelation", n3), g(setIn(g(), ["filter", "relation"], n3, true)), m()(g()));
  }), xo(() => Sr(w), () => {
    var e3, n3;
    e3 = Sr(w), isEqual_default(null === (n3 = g()) || void 0 === n3 || null === (n3 = n3.filter) || void 0 === n3 ? void 0 : n3.value, e3) || (p2("changeFilterValue", e3), g(setIn(g(), ["filter", "value"], e3, true)), m()(g()));
  }), xo(() => Sr(k), () => {
    var e3, n3, t4;
    n3 = null === (e3 = Sr(k)) || void 0 === e3 ? void 0 : e3.value, isEqual_default(null === (t4 = g()) || void 0 === t4 || null === (t4 = t4.sort) || void 0 === t4 ? void 0 : t4.path, n3) || (p2("changeSortPath", n3), g(setIn(g(), ["sort", "path"], n3, true)), m()(g()));
  }), xo(() => Sr(S), () => {
    var e3, n3, t4;
    n3 = null === (e3 = Sr(S)) || void 0 === e3 ? void 0 : e3.value, isEqual_default(null === (t4 = g()) || void 0 === t4 || null === (t4 = t4.sort) || void 0 === t4 ? void 0 : t4.direction, n3) || (p2("changeSortDirection", n3), g(setIn(g(), ["sort", "direction"], n3, true)), m()(g()));
  }), xo(() => Sr(f), () => {
    !function(e3) {
      var n3;
      isEqual_default(null === (n3 = g()) || void 0 === n3 || null === (n3 = n3.projection) || void 0 === n3 ? void 0 : n3.paths, e3) || (p2("changeProjectionPaths", e3), g(setIn(g(), ["projection", "paths"], e3, true)), m()(g()));
    }(Sr(f) ? Sr(f).map((e3) => e3.value) : void 0);
  }), yo(), Ka(true);
  var C3 = lf(), z3 = uo(C3), O = uo(z3), M2 = fo(uo(O)), E = uo(M2), A2 = uo(E);
  sf(A2, {
    class: "jse-filter-path",
    showChevron: true,
    get items() {
      return Sr(d);
    },
    get value() {
      return Sr(x);
    },
    set value(e3) {
      Xt(x, e3);
    },
    $$legacy: true
  });
  var R = fo(A2, 2);
  sf(R, {
    class: "jse-filter-relation",
    showChevron: true,
    clearable: false,
    get items() {
      return b;
    },
    get value() {
      return Sr(y);
    },
    set value(e3) {
      Xt(y, e3);
    },
    $$legacy: true
  });
  var q2 = fo(R, 2), P = fo(O), N2 = fo(uo(P)), I = uo(N2), U2 = uo(I);
  sf(U2, {
    class: "jse-sort-path",
    showChevron: true,
    get items() {
      return Sr(d);
    },
    get value() {
      return Sr(k);
    },
    set value(e3) {
      Xt(k, e3);
    },
    $$legacy: true
  }), sf(fo(U2, 2), {
    class: "jse-sort-direction",
    showChevron: true,
    clearable: false,
    get items() {
      return j;
    },
    get value() {
      return Sr(S);
    },
    set value(e3) {
      Xt(S, e3);
    },
    $$legacy: true
  });
  var D2 = fo(P), J = fo(uo(D2)), B = uo(J);
  sf(uo(B), {
    class: "jse-projection-paths",
    multiple: true,
    showChevron: true,
    get items() {
      return Sr(u);
    },
    get value() {
      return Sr(f);
    },
    set value(e3) {
      Xt(f, e3);
    },
    $$legacy: true
  }), Fa(q2, () => Sr(w), (e3) => Xt(w, e3)), Hr(e2, C3), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-select-query-language.svelte-atm4um {\n  position: relative;\n  width: 32px;\n}\n.jse-select-query-language.svelte-atm4um .jse-select-query-language-container:where(.svelte-atm4um) {\n  position: absolute;\n  top: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n}\n.jse-select-query-language.svelte-atm4um .jse-select-query-language-container:where(.svelte-atm4um) .jse-query-language:where(.svelte-atm4um) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  text-align: left;\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  white-space: nowrap;\n  color: var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));\n  background: var(--jse-context-menu-background, #656565);\n}\n.jse-select-query-language.svelte-atm4um .jse-select-query-language-container:where(.svelte-atm4um) .jse-query-language:where(.svelte-atm4um):hover {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n}');
var df = Lr('<button type="button"><!> </button>');
var uf = Lr('<div class="jse-select-query-language svelte-atm4um"><div class="jse-select-query-language-container svelte-atm4um"></div></div>');
function vf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "queryLanguages", 8), o2 = ai(n2, "queryLanguageId", 12), r2 = ai(n2, "onChangeQueryLanguage", 8);
  Ka();
  var a2 = uf();
  da(uo(a2), 5, t3, ca, (e3, n3) => {
    var t4, a3 = df(), i2 = uo(a3), s2 = (e4) => {
      nl(e4, {
        get data() {
          return faCheckSquare;
        }
      });
    }, l = (e4) => {
      nl(e4, {
        get data() {
          return faSquare;
        }
      });
    };
    sa(i2, (e4) => {
      Sr(n3), Ar(o2()), Or(() => Sr(n3).id === o2()) ? e4(s2) : e4(l, false);
    });
    var c = fo(i2);
    ko((e4) => {
      var o3;
      t4 = Ca(a3, 1, "jse-query-language svelte-atm4um", null, t4, e4), Ia(a3, "title", (Sr(n3), Or(() => "Select ".concat(Sr(n3).name, " as query language")))), Xr(c, " ".concat(null !== (Sr(n3), o3 = Or(() => Sr(n3).name)) && void 0 !== o3 ? o3 : ""));
    }, [() => ({
      selected: Sr(n3).id === o2()
    })], Lt), Dr("click", a3, () => {
      return e4 = Sr(n3).id, o2(e4), void r2()(e4);
      var e4;
    }), Hr(e3, a3);
  }), Hr(e2, a2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-header.svelte-1y24war {\n  display: flex;\n  background: var(--jse-theme-color, #3883fa);\n  color: var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n}\n.jse-header.svelte-1y24war .jse-title:where(.svelte-1y24war) {\n  flex: 1;\n  padding: 5px;\n  vertical-align: middle;\n}\n.jse-header.svelte-1y24war button:where(.svelte-1y24war) {\n  border: none;\n  background: transparent;\n  min-width: 32px;\n  color: inherit;\n  cursor: pointer;\n}\n.jse-header.svelte-1y24war button:where(.svelte-1y24war):hover {\n  background: rgba(255, 255, 255, 0.1);\n}');
var ff = Lr('<button type="button" class="jse-fullscreen svelte-1y24war" title="Toggle full screen"><!></button>');
var pf = Lr('<div class="jse-header svelte-1y24war"><div class="jse-title svelte-1y24war"> </div> <!> <!> <button type="button" class="jse-close svelte-1y24war"><!></button></div>');
function hf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "title", 9, "Modal"), o2 = ai(n2, "fullScreenButton", 9, false), r2 = ai(n2, "fullscreen", 13, false), a2 = ai(n2, "onClose", 9, void 0);
  Ka(true);
  var i2 = pf(), s2 = uo(i2), l = uo(s2), c = fo(s2, 2);
  ga(c, n2, "actions", {}, null);
  var d = fo(c, 2), u = (e3) => {
    var n3 = ff(), t4 = uo(n3), o3 = Lt(() => r2() ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter);
    nl(t4, {
      get data() {
        return Sr(o3);
      }
    }), Dr("click", n3, () => r2(!r2())), Hr(e3, n3);
  };
  sa(d, (e3) => {
    o2() && e3(u);
  });
  var v = fo(d, 2);
  nl(uo(v), {
    get data() {
      return faTimes;
    }
  }), ko(() => Xr(l, t3())), Dr("click", v, () => {
    var e3;
    return null === (e3 = a2()) || void 0 === e3 ? void 0 : e3();
  }), Hr(e2, i2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-config.svelte-1kpylsp {\n  border: none;\n  background: transparent;\n  min-width: 32px;\n  color: inherit;\n  cursor: pointer;\n}\n.jse-config.svelte-1kpylsp:hover {\n  background: rgba(255, 255, 255, 0.1);\n}\n.jse-config.hide.svelte-1kpylsp {\n  display: none;\n}');
var gf = Lr('<button slot="actions" type="button" title="Select a query language"><!></button>');
var mf = ii("jsoneditor:AutoScrollHandler");
function bf(e2) {
  var n2, t3;
  function o2(e3) {
    return e3 < 20 ? 200 : e3 < 50 ? 400 : 1200;
  }
  function r2() {
    if (e2) {
      var t4 = 0.05 * (n2 || 0);
      e2.scrollTop += t4;
    }
  }
  function a2(e3) {
    t3 && e3 === n2 || (i2(), mf("startAutoScroll", e3), n2 = e3, t3 = setInterval(r2, 50));
  }
  function i2() {
    t3 && (mf("stopAutoScroll"), clearInterval(t3), t3 = void 0, n2 = void 0);
  }
  return mf("createAutoScrollHandler", e2), {
    onDrag: function(n3) {
      if (e2) {
        var t4 = n3.clientY, {
          top: r3,
          bottom: s2
        } = e2.getBoundingClientRect();
        if (t4 < r3) a2(-o2(r3 - t4));
        else if (t4 > s2) {
          a2(o2(t4 - s2));
        } else i2();
      }
    },
    onDragEnd: function() {
      i2();
    }
  };
}
var jf = (e2, n2, t3, o2) => (e2 /= o2 / 2) < 1 ? t3 / 2 * e2 * e2 + n2 : -t3 / 2 * (--e2 * (e2 - 2) - 1) + n2;
var xf = () => {
  var e2, n2, t3, o2, r2, a2, i2, s2, l, c, d, u, v;
  function f(n3) {
    return n3.getBoundingClientRect().top - (e2.getBoundingClientRect ? e2.getBoundingClientRect().top : 0) + t3;
  }
  function p2(n3) {
    e2.scrollTo ? e2.scrollTo(e2.scrollLeft, n3) : e2.scrollTop = n3;
  }
  function h2(e3) {
    c || (c = e3), p2(a2(d = e3 - c, t3, s2, l)), v = true, d < l ? requestAnimationFrame(h2) : function() {
      if (p2(t3 + s2), n2 && i2) {
        n2.setAttribute("tabindex", "-1"), n2.focus();
      }
      "function" == typeof u && u();
      c = 0, v = false;
    }();
  }
  return function(d2) {
    var p3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    switch (l = 1e3, r2 = p3.offset || 0, u = p3.callback, a2 = p3.easing || jf, i2 = p3.a11y || false, typeof p3.container) {
      case "object":
        e2 = p3.container;
        break;
      case "string":
        e2 = document.querySelector(p3.container);
        break;
      default:
        e2 = window.document.documentElement;
    }
    switch (t3 = e2.scrollTop, typeof d2) {
      case "number":
        n2 = void 0, i2 = false, o2 = t3 + d2;
        break;
      case "object":
        o2 = f(n2 = d2);
        break;
      case "string":
        n2 = document.querySelector(d2), o2 = f(n2);
    }
    switch (s2 = o2 - t3 + r2, typeof p3.duration) {
      case "number":
        l = p3.duration;
        break;
      case "function":
        l = p3.duration(s2);
    }
    v ? c = 0 : requestAnimationFrame(h2);
  };
};
function yf(e2, n2) {
  var t3 = Date.now(), o2 = e2();
  return n2(Date.now() - t3), o2;
}
var wf = ii("validation");
var kf = {
  createObjectDocumentState: () => ({
    type: "object",
    properties: {}
  }),
  createArrayDocumentState: () => ({
    type: "array",
    items: []
  }),
  createValueDocumentState: () => ({
    type: "value"
  })
};
function Sf(e2, n2, t3, o2) {
  return vc(e2, n2, t3, o2, kf);
}
function Cf(e2, n2, t3, o2) {
  if (wf("validateJSON"), !n2) return [];
  if (t3 !== o2) {
    var r2 = t3.stringify(e2);
    return n2(void 0 !== r2 ? o2.parse(r2) : void 0);
  }
  return n2(e2);
}
function zf(e2, n2, t3, o2) {
  if (wf("validateText"), e2.length > 104857600) return {
    validationErrors: [{
      path: [],
      message: "Validation turned off: the document is too large",
      severity: is.info
    }]
  };
  if (0 !== e2.length) try {
    var r2 = yf(() => t3.parse(e2), (e3) => wf("validate: parsed json in ".concat(e3, " ms")));
    if (!n2) return;
    var a2 = t3 === o2 ? r2 : yf(() => o2.parse(e2), (e3) => wf("validate: parsed json with the validationParser in ".concat(e3, " ms"))), i2 = yf(() => n2(a2), (e3) => wf("validate: validated json in ".concat(e3, " ms")));
    return isEmpty_default(i2) ? void 0 : {
      validationErrors: i2
    };
  } catch (n3) {
    var s2 = yf(() => function(e3, n4) {
      if (e3.length > fl) return false;
      try {
        return n4.parse(jsonrepair(e3)), true;
      } catch (e4) {
        return false;
      }
    }(e2, t3), (e3) => wf("validate: checked whether repairable in ".concat(e3, " ms")));
    return {
      parseError: _i(e2, n3.message || n3.toString()),
      isRepairable: s2
    };
  }
}
var Of = ii("jsoneditor:FocusTracker");
function Mf(e2) {
  var n2, {
    onMount: t3,
    onDestroy: o2,
    getWindow: r2,
    hasFocus: a2,
    onFocus: i2,
    onBlur: s2
  } = e2, l = false;
  function c() {
    var e3 = a2();
    e3 && (clearTimeout(n2), l || (Of("focus"), i2(), l = e3));
  }
  function d() {
    l && (clearTimeout(n2), n2 = setTimeout(() => {
      a2() || (Of("blur"), l = false, s2());
    }));
  }
  t3(() => {
    Of("mount FocusTracker");
    var e3 = r2();
    e3 && (e3.addEventListener("focusin", c, true), e3.addEventListener("focusout", d, true));
  }), o2(() => {
    Of("destroy FocusTracker");
    var e3 = r2();
    e3 && (e3.removeEventListener("focusin", c, true), e3.removeEventListener("focusout", d, true));
  });
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-message.svelte-czprfx {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  padding: var(--jse-padding, 10px);\n  display: flex;\n  gap: var(--jse-padding, 10px);\n  flex-wrap: wrap;\n  align-items: stretch;\n}\n.jse-message.jse-success.svelte-czprfx {\n  background: var(--message-success-background, #9ac45d);\n  color: var(--jse-message-success-color, #fff);\n}\n.jse-message.svelte-czprfx .jse-text:where(.svelte-czprfx) {\n  display: flex;\n  flex: 1;\n  min-width: 60%;\n  align-items: center;\n}\n.jse-message.svelte-czprfx .jse-text.jse-clickable:where(.svelte-czprfx) {\n  cursor: pointer;\n}\n.jse-message.svelte-czprfx .jse-text.jse-clickable:where(.svelte-czprfx):hover {\n  background-color: rgba(255, 255, 255, 0.1);\n}\n.jse-message.jse-error.svelte-czprfx {\n  background: var(--jse-message-error-background, var(--jse-error-color, #ee5341));\n  color: var(--jse-message-error-color, #fff);\n}\n.jse-message.jse-warning.svelte-czprfx {\n  background: var(--jse-message-warning-background, #ffde5c);\n  color: var(--jse-message-warning-color, #4d4d4d);\n}\n.jse-message.jse-info.svelte-czprfx {\n  background: var(--jse-message-info-background, #4f91ff);\n  color: var(--jse-message-info-color, #fff);\n}\n.jse-message.svelte-czprfx .jse-actions:where(.svelte-czprfx) {\n  display: flex;\n  gap: var(--jse-padding, 10px);\n}\n.jse-message.svelte-czprfx .jse-actions:where(.svelte-czprfx) button.jse-action:where(.svelte-czprfx) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-message-action-background, rgba(255, 255, 255, 0.2));\n  color: inherit;\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n}\n.jse-message.svelte-czprfx .jse-actions:where(.svelte-czprfx) button.jse-action:where(.svelte-czprfx):hover {\n  background: var(--jse-message-action-background-highlight, rgba(255, 255, 255, 0.3));\n}');
var Ef = Lr('<button type="button" class="jse-button jse-action jse-primary svelte-czprfx"><!> </button>');
var Af = Lr('<div><div role="button" tabindex="-1"><div class="jse-text-centered"><!> </div></div> <div class="jse-actions svelte-czprfx"></div></div>');
function Rf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "type", 9, "success"), o2 = ai(n2, "icon", 9, void 0), r2 = ai(n2, "message", 9, void 0), a2 = ai(n2, "actions", 25, () => []), i2 = ai(n2, "onClick", 9, void 0), s2 = ai(n2, "onClose", 9, void 0);
  s2() && oa(s2()), Ka(true);
  var l, c = Af(), d = uo(c), u = uo(d), v = uo(u), f = (e3) => {
    nl(e3, {
      get data() {
        return o2();
      }
    });
  };
  sa(v, (e3) => {
    o2() && e3(f);
  });
  var p2 = fo(v);
  da(fo(d, 2), 5, a2, ca, (e3, n3) => {
    var t4 = Ef(), o3 = uo(t4), r3 = (e4) => {
      nl(e4, {
        get data() {
          return Sr(n3), Or(() => Sr(n3).icon);
        }
      });
    };
    sa(o3, (e4) => {
      Sr(n3), Or(() => Sr(n3).icon) && e4(r3);
    });
    var a3 = fo(o3);
    ko(() => {
      var e4;
      Ia(t4, "title", (Sr(n3), Or(() => Sr(n3).title))), t4.disabled = (Sr(n3), Or(() => Sr(n3).disabled)), Xr(a3, " ".concat(null !== (Sr(n3), e4 = Or(() => Sr(n3).text)) && void 0 !== e4 ? e4 : ""));
    }), Dr("click", t4, () => {
      Sr(n3).onClick && Sr(n3).onClick();
    }), Dr("mousedown", t4, () => {
      Sr(n3).onMouseDown && Sr(n3).onMouseDown();
    }), Hr(e3, t4);
  }), ko((e3) => {
    var n3, o3;
    Ca(c, 1, "jse-message jse-".concat(null !== (n3 = t3()) && void 0 !== n3 ? n3 : ""), "svelte-czprfx"), l = Ca(d, 1, "jse-text svelte-czprfx", null, l, e3), Xr(p2, " ".concat(null !== (o3 = r2()) && void 0 !== o3 ? o3 : ""));
  }, [() => ({
    "jse-clickable": !!i2()
  })], Lt), Dr("click", d, function() {
    i2() && i2()();
  }), Hr(e2, c), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-validation-errors-overview.svelte-1uindol {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  overflow: auto;\n  max-height: 25%;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) {\n  border-collapse: collapse;\n  width: 100%;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) {\n  cursor: pointer;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr.jse-validation-error:where(.svelte-1uindol) {\n  background: var(--jse-message-error-background, var(--jse-error-color, #ee5341));\n  color: var(--jse-message-error-color, #fff);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr.jse-validation-warning:where(.svelte-1uindol) {\n  background: var(--jse-message-warning-background, #ffde5c);\n  color: var(--jse-message-warning-color, #4d4d4d);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr.jse-validation-warning:where(.svelte-1uindol):hover {\n  filter: brightness(105%);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr.jse-validation-info:where(.svelte-1uindol) {\n  background: var(--jse-message-info-background, #4f91ff);\n  color: var(--jse-message-info-color, #fff);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol):hover {\n  filter: brightness(110%);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td:where(.svelte-1uindol) {\n  padding: 4px var(--jse-padding, 10px);\n  vertical-align: middle;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td.jse-validation-error-icon:where(.svelte-1uindol) {\n  width: 36px;\n  box-sizing: border-box;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td.jse-validation-error-action:where(.svelte-1uindol) {\n  width: 36px;\n  box-sizing: border-box;\n  padding: 0;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td.jse-validation-error-action:where(.svelte-1uindol) button.jse-validation-errors-collapse:where(.svelte-1uindol) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  width: 36px;\n  height: 26px;\n  cursor: pointer;\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td.jse-validation-error-action:where(.svelte-1uindol) button.jse-validation-errors-collapse:where(.svelte-1uindol):hover {\n  background-color: rgba(255, 255, 255, 0.2);\n}\n.jse-validation-errors-overview.svelte-1uindol table:where(.svelte-1uindol) tr:where(.svelte-1uindol) td:where(.svelte-1uindol) div.jse-validation-errors-expand:where(.svelte-1uindol) {\n  display: inline-block;\n  position: relative;\n  top: 3px;\n}');
var qf = Lr('<button type="button" class="jse-validation-errors-collapse svelte-1uindol" title="Collapse validation errors"><!></button>');
var Pf = Lr('<tr tabindex="0"><td class="jse-validation-error-icon svelte-1uindol"><!></td><td class="jse-validation-error-path svelte-1uindol"> </td><td class="jse-validation-error-message svelte-1uindol"> </td><td class="jse-validation-error-action svelte-1uindol"><!></td></tr>');
var Tf = Lr('<tr class="jse-validation-error svelte-1uindol"><td class="svelte-1uindol"></td><td class="svelte-1uindol"></td><td class="svelte-1uindol"> </td><td class="svelte-1uindol"></td></tr>');
var Nf = Lr('<table class="jse-validation-errors-overview-expanded svelte-1uindol"><tbody><!><!></tbody></table>');
var If = Lr('<table class="jse-validation-errors-overview-collapsed svelte-1uindol"><tbody><tr><td class="jse-validation-error-icon svelte-1uindol"><!></td><td class="jse-validation-error-count svelte-1uindol"> <div class="jse-validation-errors-expand svelte-1uindol"><!></div></td></tr></tbody></table>');
var Uf = Lr('<div class="jse-validation-errors-overview svelte-1uindol"><!></div>');
function Df(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = ai(n2, "validationErrors", 9), r2 = ai(n2, "selectError", 9), a2 = Kt(true, true);
  function i2() {
    Xt(a2, false);
  }
  function s2() {
    Xt(a2, true);
  }
  xo(() => Ar(o2()), () => {
    Xt(t3, o2().length);
  }), yo(), Ka(true);
  var l = $r(), c = vo(l), d = (e3) => {
    var n3 = Uf(), l2 = uo(n3), c2 = (e4) => {
      var n4 = Nf(), a3 = uo(n4), s3 = uo(a3);
      da(s3, 1, () => (Ar(Ri), Ar(o2()), Ar(dl), Or(() => Ri(o2(), dl))), ca, (e5, n5, t4) => {
        var a4 = Pf(), s4 = uo(a4);
        nl(uo(s4), {
          get data() {
            return faExclamationTriangle;
          }
        });
        var l4 = fo(s4), c4 = uo(l4), d3 = fo(l4), u = uo(d3), v = uo(fo(d3)), f = (e6) => {
          var n6 = qf();
          nl(uo(n6), {
            get data() {
              return faAngleDown;
            }
          }), Dr("click", n6, Qa(i2)), Hr(e6, n6);
        };
        sa(v, (e6) => {
          Ar(o2()), Or(() => 0 === t4 && o2().length > 1) && e6(f);
        }), ko((e6) => {
          var t5;
          Ca(a4, 1, "jse-validation-".concat(null !== (Sr(n5), t5 = Or(() => Sr(n5).severity)) && void 0 !== t5 ? t5 : ""), "svelte-1uindol"), Xr(c4, e6), Xr(u, (Sr(n5), Or(() => Sr(n5).message)));
        }, [() => (Ar(au), Sr(n5), Or(() => au(Sr(n5).path)))], Lt), Dr("click", a4, () => {
          setTimeout(() => r2()(Sr(n5)));
        }), Hr(e5, a4);
      });
      var l3 = fo(s3), c3 = (e5) => {
        var n5 = Tf(), o3 = fo(uo(n5), 2), r3 = uo(o3);
        ko(() => Xr(r3, "(and ".concat(Sr(t3) - dl, " more errors)"))), Hr(e5, n5);
      };
      sa(l3, (e5) => {
        Sr(t3) > dl && e5(c3);
      }), Hr(e4, n4);
    }, d2 = (e4) => {
      var n4 = If(), r3 = uo(n4), a3 = uo(r3), i3 = uo(a3);
      nl(uo(i3), {
        get data() {
          return faExclamationTriangle;
        }
      });
      var l3 = uo(fo(i3));
      nl(uo(fo(l3)), {
        get data() {
          return faAngleRight;
        }
      }), ko((e5) => {
        var n5;
        Ca(a3, 1, "jse-validation-".concat(null != e5 ? e5 : ""), "svelte-1uindol"), Xr(l3, "".concat(null !== (n5 = Sr(t3)) && void 0 !== n5 ? n5 : "", " validation errors "));
      }, [() => (Ar(o2()), Or(() => {
        return e5 = o2(), [is.error, is.warning, is.info].find((n5) => e5.some((e6) => e6.severity === n5));
        var e5;
      }))], Lt), Dr("click", a3, s2), Hr(e4, n4);
    };
    sa(l2, (e4) => {
      Sr(a2) || 1 === Sr(t3) ? e4(c2) : e4(d2, false);
    }), Hr(e3, n3);
  };
  sa(c, (e3) => {
    Ar(isEmpty_default), Ar(o2()), Or(() => !isEmpty_default(o2())) && e3(d);
  }), Hr(e2, l), Nt();
}
function Jf(e2, n2) {
  if (e2) return e2.addEventListener("keydown", t3), {
    destroy() {
      e2.removeEventListener("keydown", t3);
    }
  };
  function t3(e3) {
    "Escape" === e3.key && (e3.preventDefault(), e3.stopPropagation(), n2());
  }
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\ndialog.jse-modal.svelte-1s9c2ql {\n  border-radius: 3px;\n  font-size: var(--jse-padding, 10px);\n  border: none;\n  padding: 0;\n  display: flex;\n  min-width: 0;\n  margin: auto;\n  overflow: visible;\n  transition: width 0.1s ease-in-out, height 0.1s ease-in-out;\n}\ndialog.jse-modal.jse-sort-modal.svelte-1s9c2ql {\n  width: 400px;\n}\ndialog.jse-modal.jse-repair-modal.svelte-1s9c2ql {\n  width: 600px;\n  height: 500px;\n}\ndialog.jse-modal.jse-jsoneditor-modal.svelte-1s9c2ql {\n  width: 800px;\n  height: 600px;\n}\ndialog.jse-modal.jse-transform-modal.svelte-1s9c2ql {\n  width: 1200px;\n  height: 800px;\n}\ndialog.jse-modal.jse-fullscreen.svelte-1s9c2ql {\n  width: 100%;\n  height: 100%;\n}\ndialog.jse-modal.svelte-1s9c2ql::backdrop {\n  background: var(--jse-overlay-background, rgba(0, 0, 0, 0.3));\n}\ndialog.jse-modal[open].svelte-1s9c2ql {\n  animation: svelte-1s9c2ql-zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n}\ndialog.jse-modal[open].svelte-1s9c2ql::backdrop {\n  animation: svelte-1s9c2ql-fade 0.2s ease-out;\n}\ndialog.jse-modal.svelte-1s9c2ql .jse-modal-inner:where(.svelte-1s9c2ql) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-width: 0;\n  min-height: 0;\n  padding: 0;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  line-height: normal;\n  background: var(--jse-modal-background, #f5f5f5);\n  color: var(--jse-text-color, #4d4d4d);\n}\n@keyframes svelte-1s9c2ql-zoom {\n  from {\n    transform: scale(0.95);\n  }\n  to {\n    transform: scale(1);\n  }\n}\n@keyframes svelte-1s9c2ql-fade {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\ndialog.jse-modal.svelte-1s9c2ql .svelte-select {\n  --border: var(--jse-svelte-select-border, 1px solid #d8dbdf);\n  --item-is-active-bg: var(--jse-item-is-active-bg, #3883fa);\n  --border-radius: var(--jse-svelte-select-border-radius, 3px);\n  --background: var(--jse-svelte-select-background, #fff);\n  --padding: var(--jse-svelte-select-padding, 0 10px);\n  --multi-select-padding: var(--jse-svelte-select-multi-select-padding, 0 10px);\n  --font-size: var(--jse-svelte-select-font-size, var(--jse-font-size, 16px));\n  --height: 36px;\n  --multi-item-height: 28px;\n  --multi-item-margin: 2px;\n  --multi-item-padding: 2px 8px;\n  --multi-item-border-radius: 6px;\n  --indicator-top: 8px;\n}');
var Bf = Lr('<dialog><div class="jse-modal-inner svelte-1s9c2ql"><!></div></dialog>');
function _f(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "className", 8, void 0), o2 = ai(n2, "fullscreen", 8, false), r2 = ai(n2, "onClose", 8), a2 = Kt();
  function i2() {
    r2()();
  }
  ta(() => Sr(a2).showModal()), oa(() => Sr(a2).close()), Ka();
  var s2, l = Bf(), c = uo(l);
  ga(uo(c), n2, "default", {}, null), Ha(l, (e3) => Xt(a2, e3), () => Sr(a2)), jo(() => Dr("close", l, i2)), jo(() => {
    return Dr("pointerdown", l, (e3 = i2, function() {
      for (var n3 = arguments.length, t4 = new Array(n3), o3 = 0; o3 < n3; o3++) t4[o3] = arguments[o3];
      t4[0].target === this && (null == e3 || e3.apply(this, t4));
    }));
    var e3;
  }), jo(() => Dr("cancel", l, Ya(function(e3) {
    Ga.call(this, n2, e3);
  }))), ba(l, (e3, n3) => null == Jf ? void 0 : Jf(e3, n3), () => i2), ko((e3, n3) => s2 = Ca(l, 1, e3, "svelte-1s9c2ql", s2, n3), [() => ya((Ar(pd), Ar(t3()), Or(() => pd("jse-modal", t3())))), () => ({
    "jse-fullscreen": o2()
  })], Lt), Hr(e2, l), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-modal-contents.svelte-189qksl {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  overflow: auto;\n  min-width: 0;\n  min-height: 0;\n}\n.jse-modal-contents.svelte-189qksl .jse-actions:where(.svelte-189qksl) {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  padding-top: var(--jse-padding, 10px);\n}\n.jse-modal-contents.svelte-189qksl .jse-actions:where(.svelte-189qksl) button.jse-primary:where(.svelte-189qksl) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-modal-contents.svelte-189qksl .jse-actions:where(.svelte-189qksl) button.jse-primary:where(.svelte-189qksl):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-modal-contents.svelte-189qksl .jse-actions:where(.svelte-189qksl) button.jse-primary:where(.svelte-189qksl):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}\n\n.jse-shortcuts.svelte-189qksl {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  margin: calc(2 * var(--jse-padding, 10px)) 0;\n}\n.jse-shortcuts.svelte-189qksl .jse-shortcut:where(.svelte-189qksl) .jse-key:where(.svelte-189qksl) {\n  font-size: 200%;\n  color: var(--jse-theme-color, #3883fa);\n}');
var Ff = Lr('<!> <div class="jse-modal-contents svelte-189qksl"><div>Clipboard permission is disabled by your browser. You can use:</div> <div class="jse-shortcuts svelte-189qksl"><div class="jse-shortcut svelte-189qksl"><div class="jse-key svelte-189qksl"> </div> for copy</div> <div class="jse-shortcut svelte-189qksl"><div class="jse-key svelte-189qksl"> </div> for cut</div> <div class="jse-shortcut svelte-189qksl"><div class="jse-key svelte-189qksl"> </div> for paste</div></div> <div class="jse-actions svelte-189qksl"><button type="button" class="jse-primary svelte-189qksl">Close</button></div></div>', 1);
function Lf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "onClose", 9), o2 = Ts() ? "" : "Ctrl";
  Ka(true), _f(e2, {
    get onClose() {
      return t3();
    },
    className: "jse-copy-paste",
    children: (e3, n3) => {
      var r2 = Ff(), a2 = vo(r2);
      hf(a2, {
        title: "Copying and pasting",
        get onClose() {
          return t3();
        }
      });
      var i2 = fo(a2, 2), s2 = fo(uo(i2), 2), l = uo(s2), c = uo(l), d = uo(c), u = fo(l, 2), v = uo(u), f = uo(v), p2 = uo(fo(u, 2)), h2 = uo(p2), g = uo(fo(s2, 2));
      ko(() => {
        Xr(d, "".concat(o2, "+C")), Xr(f, "".concat(o2, "+X")), Xr(h2, "".concat(o2, "+V"));
      }), Dr("click", g, function() {
        for (var e4, n4 = arguments.length, o3 = new Array(n4), r3 = 0; r3 < n4; r3++) o3[r3] = arguments[r3];
        null === (e4 = t3()) || void 0 === e4 || e4.apply(this, o3);
      }), Hr(e3, r2);
    },
    $$slots: {
      default: true
    }
  }), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-menu.svelte-pf7s2l {\n  background: var(--jse-theme-color, #3883fa);\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size-main-menu, 14px);\n  color: var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n  display: flex;\n  flex-wrap: wrap;\n  align-items: stretch;\n  position: relative;\n}\n.jse-menu.svelte-pf7s2l .jse-button:where(.svelte-pf7s2l) {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: 1.5em;\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  width: var(--jse-menu-button-size, 32px);\n  height: var(--jse-menu-button-size, 32px);\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  margin: 0;\n  border-radius: 0;\n  display: inline-flex;\n  align-items: center;\n  text-align: center;\n  justify-content: center;\n}\n.jse-menu.svelte-pf7s2l .jse-button:where(.svelte-pf7s2l):hover, .jse-menu.svelte-pf7s2l .jse-button:where(.svelte-pf7s2l):focus {\n  background: var(--jse-theme-color-highlight, #5f9dff);\n}\n.jse-menu.svelte-pf7s2l .jse-button:where(.svelte-pf7s2l):disabled {\n  color: var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n  opacity: 0.5;\n  background: transparent;\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button:where(.svelte-pf7s2l) {\n  width: auto;\n  height: calc(var(--jse-menu-button-size, 32px) - var(--jse-padding, 10px));\n  margin: calc(0.5 * var(--jse-padding, 10px)) 0;\n  padding: 0 calc(0.5 * var(--jse-padding, 10px)) 1px;\n  border: 1px solid var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button:where(.svelte-pf7s2l):not(.jse-last) {\n  border-right: none;\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-first:where(.svelte-pf7s2l) {\n  margin-left: calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-last:where(.svelte-pf7s2l) {\n  margin-right: calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button:where(.svelte-pf7s2l):hover, .jse-menu.svelte-pf7s2l .jse-button.jse-group-button:where(.svelte-pf7s2l):focus {\n  background: var(--jse-theme-color-highlight, #5f9dff);\n}\n.jse-menu.svelte-pf7s2l .jse-button.jse-group-button.jse-selected:where(.svelte-pf7s2l) {\n  background: var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n  color: var(--jse-theme-color, #3883fa);\n}\n.jse-menu.svelte-pf7s2l .jse-space:where(.svelte-pf7s2l) {\n  flex: 1;\n}\n.jse-menu.svelte-pf7s2l .jse-separator:where(.svelte-pf7s2l) {\n  background: var(--jse-menu-color, var(--jse-text-color-inverse, #fff));\n  opacity: 0.3;\n  width: 1px;\n  margin: 3px;\n}');
var Wf = Lr('<div class="jse-separator svelte-pf7s2l"></div>');
var Vf = Lr('<div class="jse-space svelte-pf7s2l"></div>');
var $f = Lr('<button type="button"><!> <!></button>');
var Hf = Lr('<div class="jse-menu svelte-pf7s2l"><!> <!> <!></div>');
function Qf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "items", 25, () => []);
  Ka(true);
  var o2 = Hf(), r2 = uo(o2);
  ga(r2, n2, "left", {}, null);
  var a2 = fo(r2, 2);
  da(a2, 1, t3, ca, (e3, n3) => {
    var t4 = $r(), o3 = vo(t4), r3 = (e4) => {
      Hr(e4, Wf());
    }, a3 = (e4, t5) => {
      var o4 = (e5) => {
        Hr(e5, Vf());
      }, r4 = (e5, t6) => {
        var o5 = (e6) => {
          var t7 = $f(), o6 = uo(t7), r6 = (e7) => {
            nl(e7, {
              get data() {
                return Sr(n3), Or(() => Sr(n3).icon);
              }
            });
          };
          sa(o6, (e7) => {
            Sr(n3), Or(() => Sr(n3).icon) && e7(r6);
          });
          var a4 = fo(o6, 2), i2 = (e7) => {
            var t8 = Vr();
            ko(() => Xr(t8, (Sr(n3), Or(() => Sr(n3).text)))), Hr(e7, t8);
          };
          sa(a4, (e7) => {
            Sr(n3), Or(() => Sr(n3).text) && e7(i2);
          }), ko(() => {
            var e7;
            Ca(t7, 1, "jse-button ".concat(null !== (Sr(n3), e7 = Or(() => Sr(n3).className)) && void 0 !== e7 ? e7 : ""), "svelte-pf7s2l"), Ia(t7, "title", (Sr(n3), Or(() => Sr(n3).title))), t7.disabled = (Sr(n3), Or(() => Sr(n3).disabled || false));
          }), Dr("click", t7, function() {
            for (var e7, t8 = arguments.length, o7 = new Array(t8), r7 = 0; r7 < t8; r7++) o7[r7] = arguments[r7];
            null === (e7 = Sr(n3).onClick) || void 0 === e7 || e7.apply(this, o7);
          }), Hr(e6, t7);
        }, r5 = (e6) => {
          var t7 = Vr();
          ko((e7) => Xr(t7, e7), [() => (Sr(n3), Or(() => function(e7) {
            return console.error("Unknown type of menu item", e7), "???";
          }(Sr(n3))))], Lt), Hr(e6, t7);
        };
        sa(e5, (e6) => {
          Ar(Pl), Sr(n3), Or(() => Pl(Sr(n3))) ? e6(o5) : e6(r5, false);
        }, t6);
      };
      sa(e4, (e5) => {
        Ar(Al), Sr(n3), Or(() => Al(Sr(n3))) ? e5(o4) : e5(r4, false);
      }, t5);
    };
    sa(o3, (e4) => {
      Ar(Rl), Sr(n3), Or(() => Rl(Sr(n3))) ? e4(r3) : e4(a3, false);
    }), Hr(e3, t4);
  }), ga(fo(a2, 2), n2, "right", {}, null), Hr(e2, o2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-json-repair-component.svelte-3golau {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  background: var(--jse-background-color, #fff);\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-json-repair-component.svelte-3golau .jse-info:where(.svelte-3golau) {\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  vertical-align: center;\n}\n.jse-json-repair-component.svelte-3golau .jse-json-text:where(.svelte-3golau) {\n  flex: 1;\n  border: none;\n  padding: 2px;\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n  color: var(--jse-text-color, #4d4d4d);\n  resize: none;\n  outline: none;\n}');
var Yf = Lr('<div slot="left" class="jse-info svelte-3golau">Repair invalid JSON, then click apply</div>');
var Kf = Lr('<div class="jse-json-repair-component svelte-3golau"><!> <!> <textarea class="jse-json-text svelte-3golau" autocomplete="off" autocapitalize="off" spellcheck="false"></textarea></div>');
function Zf(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), r2 = Kt(void 0, true), a2 = Kt(void 0, true), i2 = Kt(void 0, true), s2 = Kt(void 0, true), l = ai(n2, "text", 13, ""), c = ai(n2, "readOnly", 9, false), d = ai(n2, "onParse", 9), u = ai(n2, "onRepair", 9), v = ai(n2, "onChange", 9, void 0), f = ai(n2, "onApply", 9), p2 = ai(n2, "onCancel", 9), h2 = ii("jsoneditor:JSONRepair"), g = Kt(void 0, true);
  function m() {
    if (Sr(g) && Sr(t3)) {
      var e3 = void 0 !== Sr(t3).position ? Sr(t3).position : 0;
      Sr(g).setSelectionRange(e3, e3), Sr(g).focus();
    }
  }
  function b() {
    f()(l());
  }
  function j() {
    try {
      l(u()(l())), v() && v()(l());
    } catch (e3) {
    }
  }
  var x = Kt(void 0, true);
  xo(() => Ar(l()), () => {
    Xt(t3, function(e3) {
      try {
        return void d()(e3);
      } catch (n3) {
        return _i(e3, n3.message);
      }
    }(l()));
  }), xo(() => Ar(l()), () => {
    Xt(o2, function(e3) {
      try {
        return u()(e3), true;
      } catch (e4) {
        return false;
      }
    }(l()));
  }), xo(() => Sr(t3), () => {
    h2("error", Sr(t3));
  }), xo(() => Ar(p2()), () => {
    Xt(x, [{
      type: "space"
    }, {
      type: "button",
      icon: faTimes,
      title: "Cancel repair",
      className: "jse-cancel",
      onClick: p2()
    }]);
  }), xo(() => faArrowDown, () => {
    Xt(r2, {
      icon: faArrowDown,
      text: "Show me",
      title: "Scroll to the error location",
      onClick: m
    });
  }), xo(() => faWrench, () => {
    Xt(a2, {
      icon: faWrench,
      text: "Auto repair",
      title: "Automatically repair JSON",
      onClick: j
    });
  }), xo(() => (Sr(o2), Sr(r2), Sr(a2)), () => {
    Xt(i2, Sr(o2) ? [Sr(r2), Sr(a2)] : [Sr(r2)]);
  }), xo(() => Ar(c()), () => {
    Xt(s2, [{
      icon: faCheck,
      text: "Apply",
      title: "Apply fixed JSON",
      disabled: c(),
      onClick: b
    }]);
  }), yo(), Ka(true);
  var y = Kf(), w = uo(y);
  Qf(w, {
    get items() {
      return Sr(x);
    },
    $$slots: {
      left: (e3, n3) => {
        Hr(e3, Yf());
      }
    }
  });
  var k = fo(w, 2), S = (e3) => {
    var n3 = Lt(() => (Sr(t3), Or(() => "Cannot parse JSON: ".concat(Sr(t3).message))));
    Rf(e3, {
      type: "error",
      get icon() {
        return faExclamationTriangle;
      },
      get message() {
        return Sr(n3);
      },
      get actions() {
        return Sr(i2);
      }
    });
  }, C3 = (e3) => {
    Rf(e3, {
      type: "success",
      message: "JSON is valid now and can be parsed.",
      get actions() {
        return Sr(s2);
      }
    });
  };
  sa(k, (e3) => {
    Sr(t3) ? e3(S) : e3(C3, false);
  });
  var z3 = fo(k, 2);
  Ha(z3, (e3) => Xt(g, e3), () => Sr(g)), ko(() => {
    z3.readOnly = c(), Na(z3, l());
  }), Dr("input", z3, function(e3) {
    h2("handleChange");
    var n3 = e3.target.value;
    l() !== n3 && (l(n3), v() && v()(l()));
  }), Hr(e2, y), Nt();
}
function Xf(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "text", 13), o2 = ai(n2, "onParse", 9), r2 = ai(n2, "onRepair", 9), a2 = ai(n2, "onApply", 9), i2 = ai(n2, "onClose", 9);
  function s2(e3) {
    a2()(e3), i2()();
  }
  function l() {
    i2()();
  }
  Ka(true), _f(e2, {
    get onClose() {
      return i2();
    },
    className: "jse-repair-modal",
    children: (e3, n3) => {
      Zf(e3, {
        get onParse() {
          return o2();
        },
        get onRepair() {
          return r2();
        },
        onApply: s2,
        onCancel: l,
        get text() {
          return t3();
        },
        set text(e4) {
          t3(e4);
        },
        $$legacy: true
      });
    },
    $$slots: {
      default: true
    }
  }), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\ndiv.jse-collapsed-items.svelte-1h6hzoq {\n  margin-left: calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  color: var(--jse-collapsed-items-link-color, rgba(0, 0, 0, 0.38));\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  border: 8px solid transparent;\n  border-width: 8px 0;\n  background-color: var(--jse-contents-background-color, transparent);\n  background-image: linear-gradient(var(--jse-collapsed-items-background-color, #f5f5f5), var(--jse-collapsed-items-background-color, #f5f5f5)), linear-gradient(to bottom right, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to bottom left, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to top right, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%), linear-gradient(to top left, transparent 50.5%, var(--jse-collapsed-items-background-color, #f5f5f5) 50.5%);\n  background-repeat: repeat, repeat-x, repeat-x, repeat-x, repeat-x;\n  background-position: 0 0, 8px 0, 8px 0, 8px 100%, 8px 100%;\n  background-size: auto auto, 16px 16px, 16px 16px, 16px 16px, 16px 16px;\n  background-clip: padding-box, border-box, border-box, border-box, border-box;\n  background-origin: padding-box, border-box, border-box, border-box, border-box;\n  display: flex;\n}\ndiv.jse-collapsed-items.jse-selected.svelte-1h6hzoq {\n  background-color: var(--jse-selection-background-color, #d3d3d3);\n  --jse-collapsed-items-background-color: var(--jse-collapsed-items-selected-background-color, #c2c2c2);\n}\ndiv.jse-collapsed-items.svelte-1h6hzoq div.jse-text:where(.svelte-1h6hzoq),\ndiv.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items:where(.svelte-1h6hzoq) {\n  margin: 0 calc(0.5 * var(--jse-padding, 10px));\n}\ndiv.jse-collapsed-items.svelte-1h6hzoq div.jse-text:where(.svelte-1h6hzoq) {\n  display: inline;\n}\ndiv.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items:where(.svelte-1h6hzoq) {\n  font-family: inherit;\n  font-size: inherit;\n  color: var(--jse-collapsed-items-link-color, rgba(0, 0, 0, 0.38));\n  background: none;\n  border: none;\n  padding: 0;\n  text-decoration: underline;\n  cursor: pointer;\n}\ndiv.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items:where(.svelte-1h6hzoq):hover, div.jse-collapsed-items.svelte-1h6hzoq button.jse-expand-items:where(.svelte-1h6hzoq):focus {\n  color: var(--jse-collapsed-items-link-color-highlight, #ee5341);\n}');
var Gf = Lr('<button type="button" class="jse-expand-items svelte-1h6hzoq"> </button>');
var ep = Lr('<div role="none"><div><div class="jse-text svelte-1h6hzoq"> </div> <!></div></div>');
function np(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), r2 = Kt(void 0, true), a2 = Kt(void 0, true), i2 = Kt(void 0, true), s2 = ai(n2, "visibleSections", 9), l = ai(n2, "sectionIndex", 9), c = ai(n2, "total", 9), d = ai(n2, "path", 9), u = ai(n2, "selection", 9), v = ai(n2, "onExpandSection", 9), f = ai(n2, "context", 9);
  xo(() => (Ar(s2()), Ar(l())), () => {
    Xt(t3, s2()[l()]);
  }), xo(() => Sr(t3), () => {
    Xt(o2, Sr(t3).end);
  }), xo(() => (Ar(s2()), Ar(l()), Ar(c())), () => {
    Xt(r2, s2()[l() + 1] ? s2()[l() + 1].start : c());
  }), xo(() => (Ar(f()), Ar(u()), Ar(d()), Sr(o2)), () => {
    Xt(a2, dd(f().getJson(), u(), d().concat(String(Sr(o2)))));
  }), xo(() => (Sr(o2), Sr(r2)), () => {
    Xt(i2, function(e3, n3) {
      var t4 = {
        start: e3,
        end: Math.min(Ml(e3), n3)
      }, o3 = Math.max(El((e3 + n3) / 2), e3), r3 = {
        start: o3,
        end: Math.min(Ml(o3), n3)
      }, a3 = El(n3), i3 = a3 === n3 ? a3 - cl : a3, s3 = {
        start: Math.max(i3, e3),
        end: n3
      }, l2 = [t4], c2 = r3.start >= t4.end && r3.end <= s3.start;
      return c2 && l2.push(r3), s3.start >= (c2 ? r3.end : t4.end) && l2.push(s3), l2;
    }(Sr(o2), Sr(r2)));
  }), yo(), Ka(true);
  var p2, h2, g = ep(), m = uo(g), b = uo(m), j = uo(b);
  da(fo(b, 2), 1, () => Sr(i2), ca, (e3, n3) => {
    var t4 = Gf(), o3 = uo(t4);
    ko(() => {
      var e4, t5;
      return Xr(o3, "show ".concat(null !== (Sr(n3), e4 = Or(() => Sr(n3).start)) && void 0 !== e4 ? e4 : "", "-").concat(null !== (Sr(n3), t5 = Or(() => Sr(n3).end)) && void 0 !== t5 ? t5 : ""));
    }), Dr("click", t4, () => v()(d(), Sr(n3))), Hr(e3, t4);
  }), ko((e3, n3) => {
    var t4, a3;
    p2 = Ca(g, 1, "jse-collapsed-items svelte-1h6hzoq", null, p2, e3), h2 = Oa(g, "", h2, n3), Xr(j, "Items ".concat(null !== (t4 = Sr(o2)) && void 0 !== t4 ? t4 : "", "-").concat(null !== (a3 = Sr(r2)) && void 0 !== a3 ? a3 : ""));
  }, [() => ({
    "jse-selected": Sr(a2)
  }), () => ({
    "--level": (Ar(d()), Or(() => d().length + 2))
  })], Lt), Dr("mousemove", g, function(e3) {
    e3.stopPropagation();
  }), Hr(e2, g), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-context-menu-pointer.svelte-137iwnw {\n  position: absolute;\n  top: calc(-0.5 * var(--jse-context-menu-pointer-size, calc(1em + 4px)));\n  right: calc(-0.5 * var(--jse-context-menu-pointer-size, calc(1em + 4px)));\n  width: var(--jse-context-menu-pointer-size, calc(1em + 4px));\n  height: var(--jse-context-menu-pointer-size, calc(1em + 4px));\n  padding: 0;\n  margin: 0;\n  cursor: pointer;\n  background: transparent;\n  border-radius: 2px;\n  background: var(--jse-context-menu-pointer-hover-background, #b2b2b2);\n  color: var(--jse-context-menu-pointer-color, var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff)));\n  border: none;\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n}\n.jse-context-menu-pointer.jse-root.svelte-137iwnw {\n  top: 0;\n  right: calc(-2px - var(--jse-context-menu-pointer-size, calc(1em + 4px)));\n}\n.jse-context-menu-pointer.jse-insert.svelte-137iwnw {\n  right: -1px;\n}\n.jse-context-menu-pointer.svelte-137iwnw:hover {\n  background: var(--jse-context-menu-pointer-background-highlight, var(--jse-context-menu-background-highlight, #7a7a7a));\n}\n.jse-context-menu-pointer.jse-selected.svelte-137iwnw {\n  background: var(--jse-context-menu-pointer-background, var(--jse-context-menu-background, #656565));\n}\n.jse-context-menu-pointer.jse-selected.svelte-137iwnw:hover {\n  background: var(--jse-context-menu-pointer-background-highlight, var(--jse-context-menu-background-highlight, #7a7a7a));\n}');
var tp = Lr('<button type="button"><!></button>');
function op(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "root", 9, false), o2 = ai(n2, "insert", 9, false), r2 = ai(n2, "selected", 9), a2 = ai(n2, "onContextMenu", 9);
  Ka(true);
  var i2, s2 = tp();
  nl(uo(s2), {
    get data() {
      return faCaretDown;
    }
  }), ko((e3) => {
    i2 = Ca(s2, 1, "jse-context-menu-pointer svelte-137iwnw", null, i2, e3), Ia(s2, "title", ml);
  }, [() => ({
    "jse-root": t3(),
    "jse-insert": o2(),
    "jse-selected": r2()
  })], Lt), Dr("click", s2, function(e3) {
    for (var n3 = e3.target; n3 && "BUTTON" !== n3.nodeName; ) n3 = n3.parentNode;
    n3 && a2()({
      anchor: n3,
      left: 0,
      top: 0,
      width: Sl,
      height: kl,
      offsetTop: 2,
      offsetLeft: 0,
      showTip: true
    });
  }), Hr(e2, s2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-key.svelte-2iqnqn {\n  display: inline-block;\n  min-width: 2em;\n  padding: 0 5px;\n  box-sizing: border-box;\n  outline: none;\n  border-radius: 1px;\n  vertical-align: top;\n  color: var(--jse-key-color, #1a1a1a);\n  word-break: normal;\n  overflow-wrap: normal;\n  white-space: pre-wrap;\n}\n.jse-key.jse-empty.svelte-2iqnqn {\n  min-width: 3em;\n  outline: 1px dotted var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  -moz-outline-radius: 2px;\n}\n.jse-key.jse-empty.svelte-2iqnqn::after {\n  pointer-events: none;\n  color: var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  content: "key";\n}');
var rp = Lr('<div role="none" data-type="selectable-key"><!></div>');
var ap = Lr("<!> <!>", 1);
var ip = Lr('<div role="button" tabindex="-1" class="jse-value" data-type="selectable-value"></div>');
function sp(e2, n2) {
  Tt(n2, true);
  var t3 = Ft(() => qc(n2.selection) && rd(n2.selection)), o2 = Ft(() => n2.context.onRenderValue({
    path: n2.path,
    value: n2.value,
    mode: n2.context.mode,
    truncateTextSize: n2.context.truncateTextSize,
    readOnly: n2.context.readOnly,
    enforceString: n2.enforceString,
    isEditing: Sr(t3),
    parser: n2.context.parser,
    normalization: n2.context.normalization,
    selection: n2.selection,
    searchResultItems: n2.searchResultItems,
    onPatch: n2.context.onPatch,
    onPasteJson: n2.context.onPasteJson,
    onSelect: n2.context.onSelect,
    onFind: n2.context.onFind,
    findNextInside: n2.context.findNextInside,
    focus: n2.context.focus
  })), r2 = $r();
  da(vo(r2), 17, () => Sr(o2), ca, (e3, n3) => {
    var t4 = $r(), o3 = vo(t4), r3 = (e4) => {
      var t5 = ip(), o4 = Ft(() => Sr(n3).action);
      ba(t5, (e5, n4) => {
        var t6;
        return null === (t6 = Sr(o4)) || void 0 === t6 ? void 0 : t6(e5, n4);
      }, () => Sr(n3).props), Hr(e4, t5);
    }, a2 = (e4) => {
      var t5 = $r(), o4 = Ft(() => Sr(n3).component);
      ma(vo(t5), () => Sr(o4), (e5, t6) => {
        t6(e5, ri(() => Sr(n3).props));
      }), Hr(e4, t5);
    };
    sa(o3, (e4) => {
      Fl(Sr(n3)) ? e4(r3) : e4(a2, false);
    }), Hr(e3, t4);
  }), Hr(e2, r2), Nt();
}
var lp = {
  selecting: false,
  selectionAnchor: void 0,
  selectionAnchorType: void 0,
  selectionFocus: void 0,
  dragging: false
};
function cp(e2) {
  var {
    json: n2,
    selection: t3,
    deltaY: o2,
    items: r2
  } = e2;
  if (!t3) return {
    operations: void 0,
    updatedSelection: void 0,
    offset: 0
  };
  var a2 = o2 < 0 ? function(e3) {
    var {
      json: n3,
      items: t4,
      selection: o3,
      deltaY: r3
    } = e3, a3 = Jc(n3, o3), i3 = t4.findIndex((e4) => isEqual_default(e4.path, a3)), s3 = () => {
      var e4;
      return null === (e4 = t4[l2 - 1]) || void 0 === e4 ? void 0 : e4.height;
    }, l2 = i3, c = 0;
    for (; void 0 !== s3() && Math.abs(r3) > c + s3() / 2; ) c += s3(), l2 -= 1;
    var d = t4[l2].path, u2 = l2 - i3;
    return l2 !== i3 && void 0 !== t4[l2] ? {
      beforePath: d,
      offset: u2
    } : void 0;
  }({
    json: n2,
    selection: t3,
    deltaY: o2,
    items: r2
  }) : function(e3) {
    var n3, {
      json: t4,
      items: o3,
      selection: r3,
      deltaY: a3
    } = e3, i3 = Bc(t4, r3), s3 = o3.findIndex((e4) => isEqual_default(e4.path, i3)), l2 = 0, c = s3, u2 = () => {
      var e4;
      return null === (e4 = o3[c + 1]) || void 0 === e4 ? void 0 : e4.height;
    };
    for (; void 0 !== u2() && Math.abs(a3) > l2 + u2() / 2; ) l2 += u2(), c += 1;
    var v = initial_default(i3), f = getIn(t4, v), p2 = Array.isArray(f) ? c : c + 1, h2 = null === (n3 = o3[p2]) || void 0 === n3 ? void 0 : n3.path, g = c - s3;
    return h2 ? {
      beforePath: h2,
      offset: g
    } : {
      append: true,
      offset: g
    };
  }({
    json: n2,
    selection: t3,
    deltaY: o2,
    items: r2
  });
  if (!a2 || 0 === a2.offset) return {
    operations: void 0,
    updatedSelection: void 0,
    offset: 0
  };
  var i2 = function(e3, n3, t4) {
    if (!n3) return [];
    var o3 = "beforePath" in t4 ? t4.beforePath : void 0, r3 = "append" in t4 ? t4.append : void 0, a3 = initial_default(vd(n3)), i3 = getIn(e3, a3);
    if (!(r3 || o3 && Qc(o3, a3) && o3.length > a3.length)) return [];
    var s3 = Jc(e3, n3), l2 = Bc(e3, n3), u2 = last_default(s3), v = last_default(l2), f = o3 ? o3[a3.length] : void 0;
    if (!isJSONObject(i3)) {
      if (isJSONArray(i3)) {
        var p2 = ui(u2), h2 = ui(v), g = void 0 !== f ? ui(f) : i3.length;
        return times_default(h2 - p2 + 1, g < p2 ? (e4) => ({
          op: "move",
          from: compileJSONPointer(a3.concat(String(p2 + e4))),
          path: compileJSONPointer(a3.concat(String(g + e4)))
        }) : () => ({
          op: "move",
          from: compileJSONPointer(a3.concat(String(p2))),
          path: compileJSONPointer(a3.concat(String(g)))
        }));
      }
      throw new Error("Cannot create move operations: parent must be an Object or Array");
    }
    var m = Object.keys(i3), b = m.indexOf(u2), j = m.indexOf(v), w = r3 ? m.length : void 0 !== f ? m.indexOf(f) : -1;
    return -1 !== b && -1 !== j && -1 !== w ? w > b ? [...m.slice(b, j + 1), ...m.slice(w, m.length)].map((e4) => zd(a3, e4)) : [...m.slice(w, b), ...m.slice(j + 1, m.length)].map((e4) => zd(a3, e4)) : [];
  }(n2, t3, a2), s2 = initial_default(Jc(n2, t3)), l = getIn(n2, s2);
  if (Array.isArray(l)) {
    var u = function(e3) {
      var n3, t4, {
        items: o3,
        json: r3,
        selection: a3,
        offset: i3
      } = e3, s3 = Jc(r3, a3), l2 = Bc(r3, a3), c = o3.findIndex((e4) => isEqual_default(e4.path, s3)), d = o3.findIndex((e4) => isEqual_default(e4.path, l2)), u2 = null === (n3 = o3[c + i3]) || void 0 === n3 ? void 0 : n3.path, v = null === (t4 = o3[d + i3]) || void 0 === t4 ? void 0 : t4.path;
      return td(u2, v);
    }({
      items: r2,
      json: n2,
      selection: t3,
      offset: a2.offset
    });
    return {
      operations: i2,
      updatedSelection: u,
      offset: a2.offset
    };
  }
  return {
    operations: i2,
    updatedSelection: void 0,
    offset: a2.offset
  };
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\nbutton.jse-validation-error.svelte-1a8aobl {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  padding: 0;\n  margin: 0;\n  vertical-align: top;\n  display: inline-flex;\n  color: var(--jse-error-color, #ee5341);\n}\n\nbutton.jse-validation-info.svelte-1a8aobl {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  padding: 0;\n  margin: 0;\n  vertical-align: top;\n  display: inline-flex;\n  color: var(--jse-info-color, #4f91ff);\n}\n\nbutton.jse-validation-warning.svelte-1a8aobl {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  padding: 0;\n  margin: 0;\n  vertical-align: top;\n  display: inline-flex;\n  color: var(--jse-warning-color, #fdc539);\n}');
var dp = Lr('<button type="button"><!></button>');
function up(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(), o2 = Pt("absolute-popup"), a2 = ai(n2, "validationError", 8), i2 = ai(n2, "onExpand", 8);
  xo(() => Ar(a2()), () => {
    Xt(t3, Bl(a2()) && a2().isChildError ? "Contains invalid data" : a2().message);
  }), yo(), Ka();
  var s2 = dp();
  nl(uo(s2), {
    get data() {
      return faExclamationTriangle;
    }
  }), jo(() => Dr("click", s2, function() {
    for (var e3, n3 = arguments.length, t4 = new Array(n3), o3 = 0; o3 < n3; o3++) t4[o3] = arguments[o3];
    null === (e3 = i2()) || void 0 === e3 || e3.apply(this, t4);
  })), ba(s2, (e3, n3) => null == nu ? void 0 : nu(e3, n3), () => r({
    text: Sr(t3)
  }, o2)), ko(() => {
    var e3;
    return Ca(s2, 1, "jse-validation-".concat(null !== (Ar(a2()), e3 = Or(() => a2().severity)) && void 0 !== e3 ? e3 : ""), "svelte-1a8aobl");
  }), Hr(e2, s2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-expand.svelte-oawf7x {\n  width: var(--jse-indent-size, calc(1em + 4px));\n  padding: 0;\n  margin: 0;\n  border: none;\n  cursor: pointer;\n  background: transparent;\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n  font-size: var(--jse-font-size-mono, 14px);\n  height: var(--jse-line-height, calc(1em + 4px));\n}\n.jse-expand.svelte-oawf7x:hover {\n  opacity: 0.8;\n}\n\n.jse-meta.svelte-oawf7x,\n.jse-separator.svelte-oawf7x,\n.jse-index.svelte-oawf7x,\n.jse-bracket.svelte-oawf7x {\n  vertical-align: top;\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n}\n\n.jse-index.svelte-oawf7x {\n  padding: 0 calc(0.5 * var(--jse-padding, 10px));\n}\n\n.jse-bracket.svelte-oawf7x {\n  padding: 0 2px;\n}\n.jse-bracket.jse-expanded.svelte-oawf7x {\n  padding-right: var(--jse-padding, 10px);\n}\n\n.jse-identifier.svelte-oawf7x {\n  vertical-align: top;\n  position: relative;\n}\n\n.jse-json-node.svelte-oawf7x {\n  position: relative;\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-json-node.jse-root.svelte-oawf7x {\n  min-height: 100%;\n  padding-bottom: 2px;\n  box-sizing: border-box;\n}\n.jse-json-node.jse-root.svelte-oawf7x > .jse-contents-outer:where(.svelte-oawf7x) > .jse-contents:where(.svelte-oawf7x) {\n  padding-left: 0;\n}\n.jse-json-node.svelte-oawf7x .jse-props:where(.svelte-oawf7x),\n.jse-json-node.svelte-oawf7x .jse-items:where(.svelte-oawf7x) {\n  position: relative;\n}\n.jse-json-node.svelte-oawf7x .jse-header-outer:where(.svelte-oawf7x),\n.jse-json-node.svelte-oawf7x .jse-footer-outer:where(.svelte-oawf7x) {\n  display: flex;\n  margin-left: calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));\n}\n.jse-json-node.svelte-oawf7x .jse-header:where(.svelte-oawf7x) {\n  position: relative;\n}\n.jse-json-node.svelte-oawf7x .jse-header:where(.svelte-oawf7x) .jse-meta:where(.svelte-oawf7x) > .jse-meta-inner:where(.svelte-oawf7x) {\n  display: flex;\n  justify-content: center;\n}\n.jse-json-node.svelte-oawf7x .jse-contents-outer:where(.svelte-oawf7x) {\n  display: flex;\n  margin-left: calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));\n}\n.jse-json-node.svelte-oawf7x .jse-header:where(.svelte-oawf7x),\n.jse-json-node.svelte-oawf7x .jse-contents:where(.svelte-oawf7x) {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-start;\n}\n.jse-json-node.svelte-oawf7x .jse-contents:where(.svelte-oawf7x) {\n  padding-left: var(--jse-indent-size, calc(1em + 4px));\n  cursor: var(--jse-contents-cursor, pointer);\n}\n.jse-json-node.svelte-oawf7x .jse-contents:where(.svelte-oawf7x) .jse-value-outer:where(.svelte-oawf7x) {\n  display: inline-flex;\n}\n.jse-json-node.svelte-oawf7x .jse-footer:where(.svelte-oawf7x) {\n  display: inline-flex;\n  padding-left: calc(var(--jse-indent-size, calc(1em + 4px)) + 5px);\n}\n.jse-json-node.svelte-oawf7x .jse-header:where(.svelte-oawf7x),\n.jse-json-node.svelte-oawf7x .jse-contents:where(.svelte-oawf7x),\n.jse-json-node.svelte-oawf7x .jse-footer:where(.svelte-oawf7x) {\n  background: var(--jse-contents-background-color, transparent);\n}\n.jse-json-node.svelte-oawf7x .jse-insert-selection-area:where(.svelte-oawf7x) {\n  padding: 0 calc(0.5 * var(--jse-padding, 10px));\n  flex: 1;\n}\n.jse-json-node.svelte-oawf7x .jse-insert-selection-area.jse-inside:where(.svelte-oawf7x) {\n  display: inline-flex;\n  align-items: center;\n}\n.jse-json-node.svelte-oawf7x .jse-insert-selection-area.jse-after:where(.svelte-oawf7x) {\n  display: flex;\n  align-items: flex-end;\n}\n.jse-json-node.svelte-oawf7x .jse-context-menu-pointer-anchor:where(.svelte-oawf7x) {\n  position: relative;\n}\n.jse-json-node.svelte-oawf7x .jse-insert-area:where(.svelte-oawf7x) {\n  display: flex;\n  position: relative;\n  z-index: 1;\n  margin-left: calc(var(--level) * var(--jse-indent-size, calc(1em + 4px)));\n  max-width: 250px;\n  min-width: 100px;\n  height: 0;\n  margin-right: calc(0.5 * var(--jse-padding, 10px));\n  outline: 1px solid;\n}\n.jse-json-node.svelte-oawf7x .jse-insert-area.jse-hovered:where(.svelte-oawf7x) {\n  outline-color: var(--jse-context-menu-pointer-hover-background, #b2b2b2);\n}\n.jse-json-node.svelte-oawf7x .jse-key-outer:where(.svelte-oawf7x) {\n  position: relative;\n}\n.jse-json-node.svelte-oawf7x .jse-key-outer:where(.svelte-oawf7x):hover,\n.jse-json-node.svelte-oawf7x .jse-value-outer:where(.svelte-oawf7x):hover,\n.jse-json-node.svelte-oawf7x .jse-meta:where(.svelte-oawf7x):hover,\n.jse-json-node.svelte-oawf7x .jse-footer:where(.svelte-oawf7x):hover {\n  background: var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));\n  cursor: var(--jse-contents-cursor, pointer);\n}\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-footer {\n  background: var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));\n  cursor: var(--jse-contents-cursor, pointer);\n}\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-value-outer .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-value-outer .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-meta .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-meta .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-header .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-items .jse-contents .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-header .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-props .jse-contents .jse-meta,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-footer .jse-value-outer,\n.jse-json-node.jse-hovered.svelte-oawf7x:not(.jse-selected):not(.jse-selected-value) .jse-footer .jse-meta {\n  background: none;\n}\n.jse-json-node.jse-selected.svelte-oawf7x .jse-header:where(.svelte-oawf7x),\n.jse-json-node.jse-selected.svelte-oawf7x .jse-contents:where(.svelte-oawf7x),\n.jse-json-node.jse-selected.svelte-oawf7x .jse-footer:where(.svelte-oawf7x) {\n  background: var(--jse-selection-background-color, #d3d3d3);\n  cursor: var(--jse-contents-selected-cursor, grab);\n}\n.jse-json-node.jse-selected.svelte-oawf7x .jse-key-outer:where(.svelte-oawf7x):hover,\n.jse-json-node.jse-selected.svelte-oawf7x .jse-value-outer:where(.svelte-oawf7x):hover,\n.jse-json-node.jse-selected.svelte-oawf7x .jse-meta:where(.svelte-oawf7x):hover,\n.jse-json-node.jse-selected.svelte-oawf7x .jse-footer:where(.svelte-oawf7x):hover {\n  background: inherit;\n  cursor: inherit;\n}\n.jse-json-node.svelte-oawf7x .jse-key-outer.jse-selected-key:where(.svelte-oawf7x) {\n  background: var(--jse-selection-background-color, #d3d3d3);\n  cursor: var(--jse-contents-selected-cursor, grab);\n}\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-value-outer,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-meta,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-items .jse-header,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-items .jse-contents,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-props .jse-header,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-props .jse-contents,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-footer {\n  background: var(--jse-selection-background-color, #d3d3d3);\n  cursor: var(--jse-contents-selected-cursor, grab);\n}\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-value-outer .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-meta .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-items .jse-header .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-items .jse-contents .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-props .jse-header .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-props .jse-contents .jse-key-outer:hover,\n.jse-json-node.jse-selected-value.svelte-oawf7x .jse-footer .jse-key-outer:hover {\n  background: inherit;\n  cursor: inherit;\n}\n.jse-json-node.jse-readonly.svelte-oawf7x {\n  --jse-contents-selected-cursor: pointer;\n}\n.jse-json-node.svelte-oawf7x .jse-insert-area.jse-selected:where(.svelte-oawf7x) {\n  outline-color: var(--jse-context-menu-pointer-background, var(--jse-context-menu-background, #656565));\n}');
var vp = Xa(() => lp);
var fp = Lr('<div class="jse-separator svelte-oawf7x">:</div>');
var pp = Lr('<div class="jse-bracket svelte-oawf7x">[</div> <!> &nbsp;', 1);
var hp = Lr('<div class="jse-bracket svelte-oawf7x">[</div> <!> <div class="jse-bracket svelte-oawf7x">]</div>', 1);
var gp = Lr('<div class="jse-context-menu-pointer-anchor svelte-oawf7x"><!></div>');
var mp = Lr('<div role="none" class="jse-insert-selection-area jse-inside svelte-oawf7x" data-type="insert-selection-area-inside"></div>');
var bp = Lr('<div role="none" class="jse-insert-selection-area jse-after svelte-oawf7x" data-type="insert-selection-area-after"></div>');
var jp = Lr('<div data-type="insert-selection-area-inside"><!></div>');
var xp = Lr('<div slot="identifier" class="jse-identifier svelte-oawf7x"><div class="jse-index svelte-oawf7x"> </div></div>');
var yp = Lr("<!> <!>", 1);
var wp = Lr('<div role="none" class="jse-insert-selection-area jse-after svelte-oawf7x" data-type="insert-selection-area-after"></div>');
var kp = Lr('<div class="jse-items svelte-oawf7x"><!> <!></div> <div class="jse-footer-outer svelte-oawf7x"><div data-type="selectable-value" class="jse-footer svelte-oawf7x"><span class="jse-bracket svelte-oawf7x">]</span></div> <!></div>', 1);
var Sp = Lr('<div class="jse-header-outer svelte-oawf7x"><div class="jse-header svelte-oawf7x"><button type="button" class="jse-expand svelte-oawf7x" title="Expand or collapse this array (Ctrl+Click to expand/collapse recursively)"><!></button> <!> <!> <div class="jse-meta svelte-oawf7x"><div class="jse-meta-inner svelte-oawf7x" data-type="selectable-value"><!></div></div> <!></div> <!> <!></div> <!>', 1);
var Cp = Lr('<div class="jse-separator svelte-oawf7x">:</div>');
var zp = Lr('<div class="jse-bracket jse-expanded svelte-oawf7x">&lbrace;</div>');
var Op = Lr('<div class="jse-bracket svelte-oawf7x">&lbrace;</div> <!> <div class="jse-bracket svelte-oawf7x">&rbrace;</div>', 1);
var Mp = Lr('<div class="jse-context-menu-pointer-anchor svelte-oawf7x"><!></div>');
var Ep = Lr('<div role="none" class="jse-insert-selection-area jse-inside svelte-oawf7x" data-type="insert-selection-area-inside"></div>');
var Ap = Lr('<div role="none" class="jse-insert-selection-area jse-after svelte-oawf7x" data-type="insert-selection-area-after"></div>');
var Rp = Lr('<div data-type="insert-selection-area-inside"><!></div>');
var qp = Lr('<div slot="identifier"><!></div>');
var Pp = Lr('<div role="none" class="jse-insert-selection-area jse-after svelte-oawf7x" data-type="insert-selection-area-after"></div>');
var Tp = Lr('<div class="jse-props svelte-oawf7x"><!> <!></div> <div class="jse-footer-outer svelte-oawf7x"><div data-type="selectable-value" class="jse-footer svelte-oawf7x"><div class="jse-bracket svelte-oawf7x">&rbrace;</div></div> <!></div>', 1);
var Np = Lr('<div class="jse-header-outer svelte-oawf7x"><div class="jse-header svelte-oawf7x"><button type="button" class="jse-expand svelte-oawf7x" title="Expand or collapse this object (Ctrl+Click to expand/collapse recursively)"><!></button> <!> <!> <div class="jse-meta svelte-oawf7x" data-type="selectable-value"><div class="jse-meta-inner svelte-oawf7x"><!></div></div> <!></div> <!> <!></div> <!>', 1);
var Ip = Lr('<div class="jse-separator svelte-oawf7x">:</div>');
var Up = Lr('<div class="jse-context-menu-pointer-anchor svelte-oawf7x"><!></div>');
var Dp = Lr('<div role="none" class="jse-insert-selection-area jse-after svelte-oawf7x" data-type="insert-selection-area-after"></div>');
var Jp = Lr('<div class="jse-contents-outer svelte-oawf7x"><div class="jse-contents svelte-oawf7x"><!> <!> <div class="jse-value-outer svelte-oawf7x"><!></div> <!></div> <!> <!></div>');
var Bp = Lr('<div data-type="insert-selection-area-after"><!></div>');
var _p = Lr('<div role="treeitem" tabindex="-1"><!> <!></div>');
function Fp(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), a2 = ai(n2, "pointer", 9), i2 = ai(n2, "value", 9), s2 = ai(n2, "state", 9), c = ai(n2, "validationErrors", 9), d = ai(n2, "searchResults", 9), u = ai(n2, "selection", 9), v = ai(n2, "context", 9), f = ai(n2, "onDragSelectionStart", 9), p2 = ii("jsoneditor:JSONNode"), h2 = Kt(void 0, true), g = void 0, m = Kt(void 0, true), b = Kt(void 0, true), j = Kt(void 0, true), x = Kt(void 0, true), y = Kt(void 0, true), w = Kt(void 0, true), k = Kt(void 0, true);
  function S(e3) {
    e3.stopPropagation();
    var n3 = Is(e3);
    v().onExpand(Sr(b), !Sr(j), n3);
  }
  function z3() {
    v().onExpand(Sr(b), true);
  }
  function O(e3, n3) {
    var t4 = yd(Sr(b), Object.keys(i2()), e3, n3);
    return v().onPatch(t4), last_default(parseJSONPointer(t4[0].path));
  }
  function M2(e3) {
    v().onDrag(e3);
  }
  function E(e3) {
    vp().selecting && (vp(vp().selecting = false), e3.stopPropagation()), v().onDragEnd(), document.removeEventListener("mousemove", M2, true), document.removeEventListener("mouseup", E);
  }
  function A2() {
    var e3;
    return (null === (e3 = v().findElement([])) || void 0 === e3 || null === (e3 = e3.getBoundingClientRect()) || void 0 === e3 ? void 0 : e3.top) || 0;
  }
  function R(e3, n3) {
    var t4 = A2() - e3.initialContentTop;
    return n3.clientY - e3.initialClientY - t4;
  }
  function N2(e3) {
    if (!v().readOnly && u()) {
      var n3 = initial_default(vd(u()));
      if (isEqual_default(Sr(b), n3)) {
        var t4 = function(e4, n4) {
          var t5 = [];
          function o4(e5) {
            var n5 = Sr(b).concat(e5), o5 = v().findElement(n5);
            void 0 !== o5 && t5.push({
              path: n5,
              height: o5.clientHeight
            });
          }
          if (Array.isArray(i2())) {
            var r3 = v().getJson();
            if (void 0 === r3) return;
            var a4 = Jc(r3, e4), s4 = Bc(r3, e4), l = parseInt(last_default(a4), 10), c2 = parseInt(last_default(s4), 10), d2 = n4.find((e5) => l >= e5.start && c2 <= e5.end);
            if (!d2) return;
            var {
              start: u2,
              end: f2
            } = d2;
            Ai(u2, Math.min(i2().length, f2), (e5) => o4(String(e5)));
          } else Object.keys(i2()).forEach(o4);
          return t5;
        }(u(), Sr(y) || vl);
        if (p2("dragSelectionStart", {
          selection: u(),
          items: t4
        }), t4) {
          var o3 = v().getJson();
          if (void 0 !== o3) {
            var r2 = Jc(o3, u()), a3 = t4.findIndex((e4) => isEqual_default(e4.path, r2)), {
              offset: s3
            } = cp({
              json: o3,
              selection: v().getSelection(),
              deltaY: 0,
              items: t4
            });
            Xt(m, {
              initialTarget: e3.target,
              initialClientY: e3.clientY,
              initialContentTop: A2(),
              selectionStartIndex: a3,
              selectionItemsCount: Uc(o3, u()).length,
              items: t4,
              offset: s3,
              didMoveItems: false
            }), vp(vp().dragging = true), document.addEventListener("mousemove", I, true), document.addEventListener("mouseup", U2);
          }
        } else p2("Cannot drag the current selection (probably spread over multiple sections)");
      } else f()(e3);
    }
  }
  function I(e3) {
    if (Sr(m)) {
      var n3 = v().getJson();
      if (void 0 === n3) return;
      var t4 = R(Sr(m), e3), {
        offset: o3
      } = cp({
        json: n3,
        selection: v().getSelection(),
        deltaY: t4,
        items: Sr(m).items
      });
      o3 !== Sr(m).offset && (p2("drag selection", o3, t4), Xt(m, r(r({}, Sr(m)), {}, {
        offset: o3,
        didMoveItems: true
      })));
    }
  }
  function U2(e3) {
    if (Sr(m)) {
      var n3 = v().getJson();
      if (void 0 === n3) return;
      var t4 = R(Sr(m), e3), {
        operations: o3,
        updatedSelection: r2
      } = cp({
        json: n3,
        selection: v().getSelection(),
        deltaY: t4,
        items: Sr(m).items
      });
      if (o3) v().onPatch(o3, (e4, n4) => ({
        state: n4,
        selection: null != r2 ? r2 : u()
      }));
      else if (e3.target === Sr(m).initialTarget && !Sr(m).didMoveItems) {
        var a3 = As(e3.target), i3 = qs(e3.target);
        i3 && v().onSelect(ld(a3, i3));
      }
      Xt(m, void 0), vp(vp().dragging = false), document.removeEventListener("mousemove", I, true), document.removeEventListener("mouseup", U2);
    }
  }
  function D2(e3) {
    e3.shiftKey || (e3.stopPropagation(), e3.preventDefault(), v().onSelect(ed(Sr(b))));
  }
  function J(e3) {
    e3.shiftKey || (e3.stopPropagation(), e3.preventDefault(), v().onSelect(nd(Sr(b))));
  }
  function B(e3) {
    v().onSelect(ed(Sr(b))), wr(), v().onContextMenu(e3);
  }
  function F2(e3) {
    v().onSelect(nd(Sr(b))), wr(), v().onContextMenu(e3);
  }
  xo(() => Ar(a2()), () => {
    Xt(b, parseJSONPointer(a2()));
  }), xo(() => Ar(a2()), () => {
    Xt(t3, encodeURIComponent(a2()));
  }), xo(() => Ar(s2()), () => {
    Xt(j, !!$l(s2()) && s2().expanded);
  }), xo(() => (Ar(i2()), Ar(s2())), () => {
    Xt(x, bc(i2(), s2(), []));
  }), xo(() => Ar(s2()), () => {
    Xt(y, Wl(s2()) ? s2().visibleSections : void 0);
  }), xo(() => Ar(c()), () => {
    var e3;
    Xt(w, null === (e3 = c()) || void 0 === e3 ? void 0 : e3.validationError);
  }), xo(() => (Ar(v()), Ar(u()), Sr(b)), () => {
    Xt(k, dd(v().getJson(), u(), Sr(b)));
  }), xo(() => Sr(b), () => {
    Xt(o2, 0 === Sr(b).length);
  }), yo(), Ka(true);
  var L, W2, V2 = _p(), $ = uo(V2), H2 = (e3) => {
    var t4 = Sp(), r2 = vo(t4), l = uo(r2), f2 = uo(l), p3 = uo(f2), g2 = (e4) => {
      nl(e4, {
        get data() {
          return faCaretDown;
        }
      });
    }, x2 = (e4) => {
      nl(e4, {
        get data() {
          return faCaretRight;
        }
      });
    };
    sa(p3, (e4) => {
      Sr(j) ? e4(g2) : e4(x2, false);
    });
    var O2 = fo(f2, 2);
    ga(O2, n2, "identifier", {}, null);
    var M3 = fo(O2, 2), E2 = (e4) => {
      Hr(e4, fp());
    };
    sa(M3, (e4) => {
      Sr(o2) || e4(E2);
    });
    var A3 = fo(M3, 2), R2 = uo(A3), q2 = uo(R2), P = (e4) => {
      var n3 = pp();
      Qd(fo(vo(n3), 2), {
        children: (e5, n4) => {
          var t5 = Vr();
          ko(() => {
            var e6, n5;
            return Xr(t5, "".concat(null !== (Ar(i2()), e6 = Or(() => i2().length)) && void 0 !== e6 ? e6 : "", "\n                ").concat(null !== (Ar(i2()), n5 = Or(() => 1 === i2().length ? "item" : "items")) && void 0 !== n5 ? n5 : ""));
          }), Hr(e5, t5);
        },
        $$slots: {
          default: true
        }
      }), Hr(e4, n3);
    }, I2 = (e4) => {
      var n3 = hp();
      Qd(fo(vo(n3), 2), {
        onclick: z3,
        children: (e5, n4) => {
          var t5 = Vr();
          ko(() => {
            var e6, n5;
            return Xr(t5, "".concat(null !== (Ar(i2()), e6 = Or(() => i2().length)) && void 0 !== e6 ? e6 : "", "\n                ").concat(null !== (Ar(i2()), n5 = Or(() => 1 === i2().length ? "item" : "items")) && void 0 !== n5 ? n5 : ""));
          }), Hr(e5, t5);
        },
        $$slots: {
          default: true
        }
      }), Hr(e4, n3);
    };
    sa(q2, (e4) => {
      Sr(j) ? e4(P) : e4(I2, false);
    });
    var U3 = fo(A3, 2), F3 = (e4) => {
      var n3 = gp();
      op(uo(n3), {
        get root() {
          return Sr(o2);
        },
        selected: true,
        get onContextMenu() {
          return Ar(v()), Or(() => v().onContextMenu);
        }
      }), Hr(e4, n3);
    };
    sa(U3, (e4) => {
      Ar(v()), Sr(k), Ar(u()), Ar(qc), Ar(Pc), Ar(rd), Ar(isEqual_default), Ar(vd), Sr(b), Or(() => !v().readOnly && Sr(k) && u() && (qc(u()) || Pc(u())) && !rd(u()) && isEqual_default(vd(u()), Sr(b))) && e4(F3);
    });
    var L2 = fo(l, 2), W3 = (e4) => {
      up(e4, {
        get validationError() {
          return Sr(w);
        },
        onExpand: z3
      });
    };
    sa(L2, (e4) => {
      Sr(w), Sr(j), Or(() => Sr(w) && (!Sr(j) || !Sr(w).isChildError)) && e4(W3);
    });
    var V3 = fo(L2, 2), $2 = (e4) => {
      var n3 = mp();
      Dr("click", n3, D2), Hr(e4, n3);
    }, H3 = (e4) => {
      var n3 = bp();
      Dr("click", n3, J), Hr(e4, n3);
    };
    sa(V3, (e4) => {
      Sr(j) ? e4($2) : e4(H3, false);
    });
    var Q2 = fo(r2, 2), Y3 = (e4) => {
      var n3 = kp(), t5 = vo(n3), r3 = uo(t5), l2 = (e5) => {
        var n4, t6, o3 = jp(), r4 = uo(o3), a3 = Lt(() => (Sr(k), Ar(Ac), Ar(u()), Or(() => Sr(k) && Ac(u()))));
        op(r4, {
          insert: true,
          get selected() {
            return Sr(a3);
          },
          onContextMenu: B
        }), ko((e6, r5) => {
          n4 = Ca(o3, 1, "jse-insert-area jse-inside svelte-oawf7x", null, n4, e6), Ia(o3, "title", gl), t6 = Oa(o3, "", t6, r5);
        }, [() => ({
          "jse-hovered": Sr(h2) === bl,
          "jse-selected": Sr(k) && Ac(u())
        }), () => ({
          "--level": (Sr(b), Or(() => Sr(b).length + 1))
        })], Lt), Hr(e5, o3);
      };
      sa(r3, (e5) => {
        Ar(v()), Sr(h2), Ar(bl), Sr(k), Ar(Ac), Ar(u()), Or(() => !v().readOnly && (Sr(h2) === bl || Sr(k) && Ac(u()))) && e5(l2);
      }), da(fo(r3, 2), 1, () => Sr(y) || vl, ca, (e5, n4, t6) => {
        var o3 = yp(), r4 = vo(o3);
        da(r4, 1, () => (Ar(i2()), Sr(n4), Sr(m), Or(() => function(e6, n5, t7) {
          var o4 = n5.start, r5 = Math.min(n5.end, e6.length), a3 = range_default(o4, r5);
          return t7 && 0 !== t7.offset ? Ti(a3, t7.selectionStartIndex, t7.selectionItemsCount, t7.offset).map((e7, n6) => ({
            index: e7,
            gutterIndex: n6
          })) : a3.map((e7) => ({
            index: e7,
            gutterIndex: e7
          }));
        }(i2(), Sr(n4), Sr(m)))), (e6) => e6.index, (e6, n5) => {
          var t7 = $r(), o4 = Lt(() => (Ar(Wl), Ar(c()), Sr(n5), Or(() => Wl(c()) ? c().items[Sr(n5).index] : void 0))), r5 = Lt(() => (Ar(cd), Ar(v()), Ar(u()), Sr(b), Sr(n5), Or(() => cd(v().getJson(), u(), Sr(b).concat(String(Sr(n5).index)))))), l4 = vo(t7), f5 = Lt(() => (Ar(appendToJSONPointer), Ar(a2()), Sr(n5), Or(() => appendToJSONPointer(a2(), Sr(n5).index)))), p5 = Lt(() => (Ar(Wl), Ar(s2()), Sr(n5), Or(() => Wl(s2()) ? s2().items[Sr(n5).index] : void 0))), h3 = Lt(() => (Ar(Wl), Ar(d()), Sr(n5), Or(() => Wl(d()) ? d().items[Sr(n5).index] : void 0)));
          Fp(l4, {
            get value() {
              return Ar(i2()), Sr(n5), Or(() => i2()[Sr(n5).index]);
            },
            get pointer() {
              return Sr(f5);
            },
            get state() {
              return Sr(p5);
            },
            get validationErrors() {
              return Sr(o4);
            },
            get searchResults() {
              return Sr(h3);
            },
            get selection() {
              return Sr(r5);
            },
            get context() {
              return v();
            },
            onDragSelectionStart: N2,
            $$slots: {
              identifier: (e7, t8) => {
                var o5 = xp(), r6 = uo(o5), a3 = uo(r6);
                ko(() => Xr(a3, (Sr(n5), Or(() => Sr(n5).gutterIndex)))), Hr(e7, o5);
              }
            }
          }), Hr(e6, t7);
        });
        var l3 = fo(r4, 2), f4 = (e6) => {
          var n5 = Lt(() => Sr(y) || vl);
          np(e6, {
            get visibleSections() {
              return Sr(n5);
            },
            sectionIndex: t6,
            get total() {
              return Ar(i2()), Or(() => i2().length);
            },
            get path() {
              return Sr(b);
            },
            get onExpandSection() {
              return Ar(v()), Or(() => v().onExpandSection);
            },
            get selection() {
              return u();
            },
            get context() {
              return v();
            }
          });
        };
        sa(l3, (e6) => {
          Sr(n4), Ar(i2()), Or(() => Sr(n4).end < i2().length) && e6(f4);
        }), Hr(e5, o3);
      });
      var f3 = fo(t5, 2), p4 = fo(uo(f3), 2), g3 = (e5) => {
        var n4 = wp();
        Dr("click", n4, J), Hr(e5, n4);
      };
      sa(p4, (e5) => {
        Sr(o2) || e5(g3);
      }), Hr(e4, n3);
    };
    sa(Q2, (e4) => {
      Sr(j) && e4(Y3);
    }), Dr("click", f2, S), Hr(e3, t4);
  }, Q = (e3, t4) => {
    var r2 = (e4) => {
      var t5 = Np(), r3 = vo(t5), f3 = uo(r3), p3 = uo(f3), g2 = uo(p3), x2 = (e5) => {
        nl(e5, {
          get data() {
            return faCaretDown;
          }
        });
      }, y2 = (e5) => {
        nl(e5, {
          get data() {
            return faCaretRight;
          }
        });
      };
      sa(g2, (e5) => {
        Sr(j) ? e5(x2) : e5(y2, false);
      });
      var M3 = fo(p3, 2);
      ga(M3, n2, "identifier", {}, null);
      var E2 = fo(M3, 2), A3 = (e5) => {
        Hr(e5, Cp());
      };
      sa(E2, (e5) => {
        Sr(o2) || e5(A3);
      });
      var R2 = fo(E2, 2), P = uo(R2), I2 = uo(P), U3 = (e5) => {
        Hr(e5, zp());
      }, _ = (e5) => {
        var n3 = Op();
        Qd(fo(vo(n3), 2), {
          onclick: z3,
          children: (e6, n4) => {
            var t6 = Vr();
            ko((e7, n5) => Xr(t6, "".concat(null != e7 ? e7 : "", "\n                ").concat(null != n5 ? n5 : "")), [() => (Ar(i2()), Or(() => Object.keys(i2()).length)), () => (Ar(i2()), Or(() => 1 === Object.keys(i2()).length ? "prop" : "props"))], Lt), Hr(e6, t6);
          },
          $$slots: {
            default: true
          }
        }), Hr(e5, n3);
      };
      sa(I2, (e5) => {
        Sr(j) ? e5(U3) : e5(_, false);
      });
      var F3 = fo(R2, 2), L2 = (e5) => {
        var n3 = Mp();
        op(uo(n3), {
          get root() {
            return Sr(o2);
          },
          selected: true,
          get onContextMenu() {
            return Ar(v()), Or(() => v().onContextMenu);
          }
        }), Hr(e5, n3);
      };
      sa(F3, (e5) => {
        Ar(v()), Sr(k), Ar(u()), Ar(qc), Ar(Pc), Ar(rd), Ar(isEqual_default), Ar(vd), Sr(b), Or(() => !v().readOnly && Sr(k) && u() && (qc(u()) || Pc(u())) && !rd(u()) && isEqual_default(vd(u()), Sr(b))) && e5(L2);
      });
      var W3 = fo(f3, 2), V3 = (e5) => {
        up(e5, {
          get validationError() {
            return Sr(w);
          },
          onExpand: z3
        });
      };
      sa(W3, (e5) => {
        Sr(w), Sr(j), Or(() => Sr(w) && (!Sr(j) || !Sr(w).isChildError)) && e5(V3);
      });
      var $2 = fo(W3, 2), H3 = (e5) => {
        var n3 = Ep();
        Dr("click", n3, D2), Hr(e5, n3);
      }, Q2 = (e5, n3) => {
        var t6 = (e6) => {
          var n4 = Ap();
          Dr("click", n4, J), Hr(e6, n4);
        };
        sa(e5, (e6) => {
          Sr(o2) || e6(t6);
        }, n3);
      };
      sa($2, (e5) => {
        Sr(j) ? e5(H3) : e5(Q2, false);
      });
      var Y3 = fo(r3, 2), K2 = (e5) => {
        var n3 = Tp(), t6 = vo(n3), r4 = uo(t6), f4 = (e6) => {
          var n4, t7, o3 = Rp(), r5 = uo(o3), a3 = Lt(() => (Sr(k), Ar(Ac), Ar(u()), Or(() => Sr(k) && Ac(u()))));
          op(r5, {
            insert: true,
            get selected() {
              return Sr(a3);
            },
            onContextMenu: B
          }), ko((e7, r6) => {
            n4 = Ca(o3, 1, "jse-insert-area jse-inside svelte-oawf7x", null, n4, e7), Ia(o3, "title", gl), t7 = Oa(o3, "", t7, r6);
          }, [() => ({
            "jse-hovered": Sr(h2) === bl,
            "jse-selected": Sr(k) && Ac(u())
          }), () => ({
            "--level": (Sr(b), Or(() => Sr(b).length + 1))
          })], Lt), Hr(e6, o3);
        };
        sa(r4, (e6) => {
          Ar(v()), Sr(h2), Ar(bl), Sr(k), Ar(Ac), Ar(u()), Or(() => !v().readOnly && (Sr(h2) === bl || Sr(k) && Ac(u()))) && e6(f4);
        }), da(fo(r4, 2), 1, () => (Ar(i2()), Sr(m), Or(() => function(e6, n4) {
          var t7 = Object.keys(e6);
          return n4 && 0 !== n4.offset ? Ti(t7, n4.selectionStartIndex, n4.selectionItemsCount, n4.offset) : t7;
        }(i2(), Sr(m)))), ca, (e6, n4) => {
          var t7 = $r(), o3 = Lt(() => (Ar(appendToJSONPointer), Ar(a2()), Sr(n4), Or(() => appendToJSONPointer(a2(), Sr(n4))))), r5 = Lt(() => (Ar(Ll), Ar(d()), Sr(n4), Or(() => Ll(d()) ? d().properties[Sr(n4)] : void 0))), f5 = Lt(() => (Ar(Ll), Ar(c()), Sr(n4), Or(() => Ll(c()) ? c().properties[Sr(n4)] : void 0))), p5 = Lt(() => (Sr(b), Sr(n4), Or(() => Sr(b).concat(Sr(n4))))), h3 = Lt(() => (Ar(cd), Ar(v()), Ar(u()), Ar(Sr(p5)), Or(() => cd(v().getJson(), u(), Sr(p5))))), g4 = vo(t7), m2 = Lt(() => (Ar(Ll), Ar(s2()), Sr(n4), Or(() => Ll(s2()) ? s2().properties[Sr(n4)] : void 0)));
          Fp(g4, {
            get value() {
              return Ar(i2()), Sr(n4), Or(() => i2()[Sr(n4)]);
            },
            get pointer() {
              return Sr(o3);
            },
            get state() {
              return Sr(m2);
            },
            get validationErrors() {
              return Sr(f5);
            },
            get searchResults() {
              return Sr(r5);
            },
            get selection() {
              return Sr(h3);
            },
            get context() {
              return v();
            },
            onDragSelectionStart: N2,
            $$slots: {
              identifier: (e7, t8) => {
                var a3, i3 = qp(), s3 = uo(i3), c2 = Lt(() => (Ar(Jd), Ar(Sr(r5)), Or(() => Jd(Sr(r5)))));
                !function(e8, n5) {
                  Tt(n5, false);
                  var t9 = Kt(void 0, true), o4 = Kt(void 0, true), r6 = ai(n5, "pointer", 9), a4 = ai(n5, "key", 9), i4 = ai(n5, "selection", 9), s4 = ai(n5, "searchResultItems", 9), c3 = ai(n5, "onUpdateKey", 9), d2 = ai(n5, "context", 9), u2 = Kt(void 0, true);
                  function v2(e9) {
                    Sr(o4) || d2().readOnly || (e9.preventDefault(), d2().onSelect(Zc(Sr(u2))));
                  }
                  function f6(e9, n6) {
                    var t10 = c3()(a4(), d2().normalization.unescapeValue(e9)), o5 = initial_default(Sr(u2)).concat(t10);
                    d2().onSelect(n6 === cs.nextInside ? Xc(o5) : Kc(o5)), n6 !== cs.self && d2().focus();
                  }
                  function p6() {
                    d2().onSelect(Kc(Sr(u2))), d2().focus();
                  }
                  xo(() => Ar(r6()), () => {
                    Xt(u2, parseJSONPointer(r6()));
                  }), xo(() => (Ar(i4()), Sr(u2)), () => {
                    Xt(t9, Rc(i4()) && isEqual_default(i4().path, Sr(u2)));
                  }), xo(() => (Sr(t9), Ar(i4())), () => {
                    Xt(o4, Sr(t9) && rd(i4()));
                  }), yo(), Ka(true);
                  var h4 = ap(), g5 = vo(h4), m3 = (e9) => {
                    var n6 = Lt(() => (Ar(d2()), Ar(a4()), Or(() => d2().normalization.escapeValue(a4())))), t10 = Lt(() => (Ar(rd), Ar(i4()), Or(() => rd(i4()) ? i4().initialValue : void 0)));
                    md(e9, {
                      get value() {
                        return Sr(n6);
                      },
                      get initialValue() {
                        return Sr(t10);
                      },
                      label: "Edit key",
                      shortText: true,
                      onChange: f6,
                      onCancel: p6,
                      get onFind() {
                        return Ar(d2()), Or(() => d2().onFind);
                      }
                    });
                  }, b2 = (e9) => {
                    var n6, t10 = rp(), o5 = uo(t10), r7 = (e10) => {
                      var n7 = Lt(() => (Ar(d2()), Ar(a4()), Or(() => d2().normalization.escapeValue(a4()))));
                      Vd(e10, {
                        get text() {
                          return Sr(n7);
                        },
                        get searchResultItems() {
                          return s4();
                        }
                      });
                    }, i5 = (e10) => {
                      var n7 = Vr();
                      ko((e11) => Xr(n7, e11), [() => (Ar(ws), Ar(d2()), Ar(a4()), Or(() => ws(d2().normalization.escapeValue(a4()))))], Lt), Hr(e10, n7);
                    };
                    sa(o5, (e10) => {
                      s4() ? e10(r7) : e10(i5, false);
                    }), ko((e10) => n6 = Ca(t10, 1, "jse-key svelte-2iqnqn", null, n6, e10), [() => ({
                      "jse-empty": "" === a4()
                    })], Lt), Dr("dblclick", t10, v2), Hr(e9, t10);
                  };
                  sa(g5, (e9) => {
                    Ar(d2()), Sr(o4), Or(() => !d2().readOnly && Sr(o4)) ? e9(m3) : e9(b2, false);
                  });
                  var j3 = fo(g5, 2), x3 = (e9) => {
                    op(e9, {
                      selected: true,
                      get onContextMenu() {
                        return Ar(d2()), Or(() => d2().onContextMenu);
                      }
                    });
                  };
                  sa(j3, (e9) => {
                    Ar(d2()), Sr(t9), Sr(o4), Or(() => !d2().readOnly && Sr(t9) && !Sr(o4)) && e9(x3);
                  }), Hr(e8, h4), Nt();
                }(s3, {
                  get pointer() {
                    return Sr(o3);
                  },
                  get key() {
                    return Sr(n4);
                  },
                  get selection() {
                    return Sr(h3);
                  },
                  get searchResultItems() {
                    return Sr(c2);
                  },
                  get context() {
                    return v();
                  },
                  onUpdateKey: O
                }), ko((e8) => a3 = Ca(i3, 1, "jse-key-outer svelte-oawf7x", null, a3, e8), [() => ({
                  "jse-selected-key": Rc(Sr(h3)) && isEqual_default(Sr(h3).path, Sr(p5))
                })], Lt), Hr(e7, i3);
              }
            }
          }), Hr(e6, t7);
        });
        var p4 = fo(t6, 2), g3 = fo(uo(p4), 2), j2 = (e6) => {
          var n4 = Pp();
          Dr("click", n4, J), Hr(e6, n4);
        };
        sa(g3, (e6) => {
          Sr(o2) || e6(j2);
        }), Hr(e5, n3);
      };
      sa(Y3, (e5) => {
        Sr(j) && e5(K2);
      }), Dr("click", p3, S), Hr(e4, t5);
    }, f2 = (e4) => {
      var t5 = Jp(), r3 = uo(t5), a3 = uo(r3);
      ga(a3, n2, "identifier", {}, null);
      var s3 = fo(a3, 2), l = (e5) => {
        Hr(e5, Ip());
      };
      sa(s3, (e5) => {
        Sr(o2) || e5(l);
      });
      var c2 = fo(s3, 2), f3 = uo(c2), p3 = Lt(() => Sr(k) ? u() : void 0), h3 = Lt(() => (Ar(Bd), Ar(d()), Or(() => Bd(d()))));
      sp(f3, {
        get path() {
          return Sr(b);
        },
        get value() {
          return i2();
        },
        get enforceString() {
          return Sr(x);
        },
        get selection() {
          return Sr(p3);
        },
        get searchResultItems() {
          return Sr(h3);
        },
        get context() {
          return v();
        }
      });
      var g2 = fo(c2, 2), m2 = (e5) => {
        var n3 = Up();
        op(uo(n3), {
          get root() {
            return Sr(o2);
          },
          selected: true,
          get onContextMenu() {
            return Ar(v()), Or(() => v().onContextMenu);
          }
        }), Hr(e5, n3);
      };
      sa(g2, (e5) => {
        Ar(v()), Sr(k), Ar(u()), Ar(qc), Ar(Pc), Ar(rd), Ar(isEqual_default), Ar(vd), Sr(b), Or(() => !v().readOnly && Sr(k) && u() && (qc(u()) || Pc(u())) && !rd(u()) && isEqual_default(vd(u()), Sr(b))) && e5(m2);
      });
      var j2 = fo(r3, 2), y2 = (e5) => {
        up(e5, {
          get validationError() {
            return Sr(w);
          },
          onExpand: z3
        });
      };
      sa(j2, (e5) => {
        Sr(w) && e5(y2);
      });
      var S2 = fo(j2, 2), C3 = (e5) => {
        var n3 = Dp();
        Dr("click", n3, J), Hr(e5, n3);
      };
      sa(S2, (e5) => {
        Sr(o2) || e5(C3);
      }), Hr(e4, t5);
    };
    sa(e3, (e4) => {
      Ar(pi), Ar(i2()), Or(() => pi(i2())) ? e4(r2) : e4(f2, false);
    }, t4);
  };
  sa($, (e3) => {
    Ar(i2()), Or(() => Array.isArray(i2())) ? e3(H2) : e3(Q, false);
  });
  var Y2 = fo($, 2), K = (e3) => {
    var n3, t4 = Bp(), o3 = uo(t4), r2 = Lt(() => (Sr(k), Ar(Ec), Ar(u()), Or(() => Sr(k) && Ec(u()))));
    op(o3, {
      insert: true,
      get selected() {
        return Sr(r2);
      },
      onContextMenu: F2
    }), ko((e4) => {
      n3 = Ca(t4, 1, "jse-insert-area jse-after svelte-oawf7x", null, n3, e4), Ia(t4, "title", gl);
    }, [() => ({
      "jse-hovered": Sr(h2) === jl,
      "jse-selected": Sr(k) && Ec(u())
    })], Lt), Hr(e3, t4);
  };
  sa(Y2, (e3) => {
    Ar(v()), Sr(h2), Ar(jl), Sr(k), Ar(Ec), Ar(u()), Or(() => !v().readOnly && (Sr(h2) === jl || Sr(k) && Ec(u()))) && e3(K);
  }), ko((e3, n3, o3) => {
    L = Ca(V2, 1, e3, "svelte-oawf7x", L, n3), Ia(V2, "data-path", Sr(t3)), Ia(V2, "aria-selected", Sr(k)), W2 = Oa(V2, "", W2, o3);
  }, [() => ya((Ar(pd), Sr(j), Ar(v()), Sr(b), Ar(i2()), Or(() => pd("jse-json-node", {
    "jse-expanded": Sr(j)
  }, v().onClassName(Sr(b), i2()))))), () => ({
    "jse-root": Sr(o2),
    "jse-selected": Sr(k) && Pc(u()),
    "jse-selected-value": Sr(k) && qc(u()),
    "jse-readonly": v().readOnly,
    "jse-hovered": Sr(h2) === xl
  }), () => ({
    "--level": (Sr(b), Or(() => Sr(b).length))
  })], Lt), Dr("mousedown", V2, function(e3) {
    if ((1 === e3.buttons || 2 === e3.buttons) && !("DIV" === (n3 = e3.target).nodeName && "true" === n3.contentEditable || 1 === e3.buttons && ks(e3.target, "BUTTON"))) {
      var n3;
      e3.stopPropagation(), e3.preventDefault(), v().focus(), document.addEventListener("mousemove", M2, true), document.addEventListener("mouseup", E);
      var t4 = As(e3.target), r2 = v().getJson(), a3 = v().getDocumentState();
      if (!u() || t4 === rs.after || t4 === rs.inside || u().type !== t4 && u().type !== rs.multi || !dd(r2, u(), Sr(b))) {
        if (vp(vp().selecting = true), vp(vp().selectionAnchor = Sr(b)), vp(vp().selectionAnchorType = t4), vp(vp().selectionFocus = Sr(b)), e3.shiftKey) {
          var s3 = v().getSelection();
          s3 && v().onSelect(td(fd(s3), Sr(b)));
        } else if (t4 === rs.multi) {
          if (Sr(o2) && e3.target.hasAttribute("data-path")) {
            var l = last_default(yc(i2(), a3));
            v().onSelect(sd(l));
          } else v().onSelect(td(Sr(b), Sr(b)));
        } else void 0 !== r2 && v().onSelect(ld(t4, Sr(b)));
      } else 0 === e3.button && f()(e3);
    }
  }), Dr("mousemove", V2, function(e3) {
    if (vp().selecting) {
      e3.preventDefault(), e3.stopPropagation(), void 0 === vp().selectionFocus && window.getSelection && window.getSelection().empty();
      var n3 = As(e3.target);
      isEqual_default(Sr(b), vp().selectionFocus) && n3 === vp().selectionAnchorType || (vp(vp().selectionFocus = Sr(b)), vp(vp().selectionAnchorType = n3), v().onSelect(td(vp().selectionAnchor || vp().selectionFocus, vp().selectionFocus)));
    }
  }), Dr("mouseover", V2, function(e3) {
    vp().selecting || vp().dragging || (e3.stopPropagation(), Ss(e3.target, "data-type", "selectable-value") ? Xt(h2, xl) : Ss(e3.target, "data-type", "selectable-key") ? Xt(h2, void 0) : Ss(e3.target, "data-type", "insert-selection-area-inside") ? Xt(h2, bl) : Ss(e3.target, "data-type", "insert-selection-area-after") && Xt(h2, jl), clearTimeout(g));
  }), Dr("mouseout", V2, function(e3) {
    e3.stopPropagation(), g = window.setTimeout(() => Xt(h2, void 0));
  }), Hr(e2, V2), Nt();
}
var Lp = {
  prefix: "fas",
  iconName: "jsoneditor-expand",
  icon: [512, 512, [], "", "M 0,448 V 512 h 512 v -64 z M 0,0 V 64 H 512 V 0 Z M 256,96 128,224 h 256 z M 256,416 384,288 H 128 Z"]
};
var Wp = {
  prefix: "fas",
  iconName: "jsoneditor-collapse",
  icon: [512, 512, [], "", "m 0,224 v 64 h 512 v -64 z M 256,192 384,64 H 128 Z M 256,320 128,448 h 256 z"]
};
var Vp = {
  prefix: "fas",
  iconName: "jsoneditor-format",
  icon: [512, 512, [], "", "M 0,32 v 64 h 416 v -64 z M 160,160 v 64 h 352 v -64 z M 160,288 v 64 h 288 v -64 z M 0,416 v 64 h 320 v -64 z"]
};
var $p = {
  prefix: "fas",
  iconName: "jsoneditor-compact",
  icon: [512, 512, [], "", "M 0,32 v 64 h 512 v -64 z M 0,160 v 64 h 512 v -64 z M 0,288 v 64 h 352 v -64 z"]
};
function Hp(e2, n2) {
  e2.stopPropagation(), n2.onCreateObject();
}
function Qp(e2, n2) {
  e2.stopPropagation(), n2.onCreateArray();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-welcome.svelte-1eamlhk {\n  flex: 1;\n  overflow: auto;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-welcome.svelte-1eamlhk:last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-welcome.svelte-1eamlhk .jse-space.jse-before:where(.svelte-1eamlhk) {\n  flex: 1;\n}\n.jse-welcome.svelte-1eamlhk .jse-space.jse-after:where(.svelte-1eamlhk) {\n  flex: 2;\n}\n.jse-welcome.svelte-1eamlhk .jse-contents:where(.svelte-1eamlhk) {\n  display: flex;\n  flex-direction: column;\n  max-width: 300px;\n  margin: 2em var(--jse-padding, 10px);\n  gap: var(--jse-padding, 10px);\n}\n.jse-welcome.svelte-1eamlhk .jse-contents:where(.svelte-1eamlhk) .jse-welcome-info:where(.svelte-1eamlhk) {\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n}\n.jse-welcome.svelte-1eamlhk .jse-contents:where(.svelte-1eamlhk) button:where(.svelte-1eamlhk) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-welcome.svelte-1eamlhk .jse-contents:where(.svelte-1eamlhk) button:where(.svelte-1eamlhk):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-welcome.svelte-1eamlhk .jse-contents:where(.svelte-1eamlhk) button:where(.svelte-1eamlhk):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}');
var Yp = (e2, n2) => n2.onClick();
var Kp = Lr('<div class="jse-welcome-info svelte-1eamlhk">You can paste clipboard data using <b>Ctrl+V</b>, or use the following options:</div> <button class="svelte-1eamlhk">Create object</button> <button class="svelte-1eamlhk">Create array</button>', 1);
var Zp = Lr('<div class="jse-welcome svelte-1eamlhk" role="none"><div class="jse-space jse-before svelte-1eamlhk"></div> <div class="jse-contents svelte-1eamlhk"><div class="jse-welcome-title">Empty document</div> <!></div> <div class="jse-space jse-after svelte-1eamlhk"></div></div>');
function Xp(e2, n2) {
  var t3 = "string" == typeof e2 ? e2.toLowerCase() : e2, o2 = "string" == typeof n2 ? n2.toLowerCase() : n2;
  return (0, import_natural_compare_lite.default)(t3, o2);
}
function Gp(e2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, r2 = getIn(e2, n2);
  if (isJSONArray(r2)) {
    if (void 0 === t3) throw new Error("Cannot sort: no property selected by which to sort the array");
    return function(e3) {
      var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], t4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], o3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, r3 = /* @__PURE__ */ function(e4, n4) {
        var t5 = {
          boolean: 0,
          number: 1,
          string: 2,
          undefined: 4
        }, o4 = 3;
        return function(r4, a3) {
          var i2 = getIn(r4, e4), s2 = getIn(a3, e4);
          if (typeof i2 != typeof s2) {
            var l, c, u = null !== (l = t5[typeof i2]) && void 0 !== l ? l : o4, v = null !== (c = t5[typeof s2]) && void 0 !== c ? c : o4;
            return u > v ? n4 : u < v ? -n4 : 0;
          }
          return "number" == typeof i2 || "boolean" == typeof i2 ? i2 > s2 ? n4 : i2 < s2 ? -n4 : 0 : hi(i2) ? 0 : n4 * Xp(i2, s2);
        };
      }(t4, o3), a2 = getIn(e3, n3);
      return [{
        op: "replace",
        path: compileJSONPointer(n3),
        value: a2.slice(0).sort(r3)
      }];
    }(e2, n2, t3, o2);
  }
  if (pi(r2)) return function(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], t4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o3 = getIn(e3, n3), r3 = Object.keys(o3).slice();
    r3.sort((e4, n4) => t4 * Xp(e4, n4));
    var a2 = {};
    return r3.forEach((e4) => a2[e4] = o3[e4]), [{
      op: "replace",
      path: compileJSONPointer(n3),
      value: a2
    }];
  }(e2, n2, o2);
  throw new Error("Cannot sort: no array or object");
}
Jr(["click"]);
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-navigation-bar-dropdown.svelte-2nnd2m {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  z-index: 3;\n  background: var(--jse-navigation-bar-background, var(--jse-background-color, #fff));\n  color: var(--jse-navigation-bar-dropdown-color, #656565);\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n  display: flex;\n  flex-direction: column;\n  max-height: 300px;\n  overflow: auto;\n  min-width: 80px;\n}\n.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item:where(.svelte-2nnd2m) {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  outline: none;\n  text-align: left;\n  white-space: nowrap;\n  box-sizing: border-box;\n  padding: calc(0.5 * var(--jse-padding, 10px)) 36px;\n}\n.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item:where(.svelte-2nnd2m):focus, .jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item:where(.svelte-2nnd2m):hover {\n  background: var(--jse-navigation-bar-background-highlight, #e5e5e5);\n}\n.jse-navigation-bar-dropdown.svelte-2nnd2m button.jse-navigation-bar-dropdown-item.jse-selected:where(.svelte-2nnd2m) {\n  background: var(--jse-navigation-bar-dropdown-color, #656565);\n  color: var(--jse-navigation-bar-background, var(--jse-background-color, #fff));\n}');
var eh = Lr('<button type="button"> </button>');
var nh = Lr('<button type="button" class="jse-navigation-bar-dropdown-item svelte-2nnd2m">...</button>');
var th = Lr('<div class="jse-navigation-bar-dropdown svelte-2nnd2m"><!> <!></div>');
function oh(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "items", 9), o2 = ai(n2, "selectedItem", 9), r2 = ai(n2, "onSelect", 9);
  Ka(true);
  var a2 = th(), i2 = uo(a2);
  da(i2, 1, () => (Ar(Ri), Ar(t3()), Or(() => Ri(t3(), 100))), (e3) => e3, (e3, n3) => {
    var t4, a3 = eh(), i3 = uo(a3);
    ko((e4, n4, o3) => {
      t4 = Ca(a3, 1, "jse-navigation-bar-dropdown-item svelte-2nnd2m", null, t4, e4), Ia(a3, "title", n4), Xr(i3, o3);
    }, [() => ({
      "jse-selected": Sr(n3) === o2()
    }), () => (Sr(n3), Or(() => Sr(n3).toString())), () => (Ar(Vs), Sr(n3), Or(() => Vs(Sr(n3).toString(), 30)))], Lt), Dr("click", a3, Qa(() => r2()(Sr(n3)))), Hr(e3, a3);
  });
  var s2 = fo(i2, 2), l = (e3) => {
    var n3 = nh();
    Ia(n3, "title", "Limited to 100 items"), Hr(e3, n3);
  };
  sa(s2, (e3) => {
    Ar(t3()), Or(() => t3().length > 100) && e3(l);
  }), Hr(e2, a2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-navigation-bar-item.svelte-752ro1 {\n  position: relative;\n  display: flex;\n}\n.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button:where(.svelte-752ro1) {\n  font-family: inherit;\n  font-size: inherit;\n  padding: calc(0.5 * var(--jse-padding, 10px)) 2px;\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  outline: none;\n  min-width: 2em;\n  white-space: nowrap;\n}\n.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button:where(.svelte-752ro1):focus, .jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button:where(.svelte-752ro1):hover {\n  background: var(--jse-panel-button-background-highlight, #e0e0e0);\n  color: var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));\n}\n.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.jse-navigation-bar-arrow:where(.svelte-752ro1) {\n  padding: 2px var(--jse-padding, 10px) 0;\n}\n.jse-navigation-bar-item.svelte-752ro1 button.jse-navigation-bar-button.jse-navigation-bar-arrow.jse-open:where(.svelte-752ro1) {\n  background: var(--jse-navigation-bar-background, var(--jse-background-color, #fff));\n  color: var(--jse-navigation-bar-dropdown-color, #656565);\n}\n.jse-navigation-bar-item.svelte-752ro1:last-child {\n  padding-right: var(--jse-padding, 10px);\n}');
var rh = Lr('<button type="button" class="jse-navigation-bar-button svelte-752ro1"> </button>');
var ah = Lr('<div class="jse-navigation-bar-item svelte-752ro1"><button type="button"><!></button> <!></div>');
function ih(e2, n2) {
  Tt(n2, false);
  var t3, o2 = Kt(void 0, true), r2 = Kt(void 0, true), {
    openAbsolutePopup: a2,
    closeAbsolutePopup: i2
  } = Pt("absolute-popup"), s2 = ai(n2, "path", 9), l = ai(n2, "index", 9), c = ai(n2, "onSelect", 9), d = ai(n2, "getItems", 9), u = Kt(void 0, true), v = Kt(false, true);
  function f(e3) {
    i2(t3), c()(Sr(o2).concat(e3));
  }
  xo(() => (Ar(s2()), Ar(l())), () => {
    Xt(o2, s2().slice(0, l()));
  }), xo(() => (Ar(s2()), Ar(l())), () => {
    Xt(r2, s2()[l()]);
  }), yo(), Ka(true);
  var p2, h2 = ah(), g = uo(h2);
  nl(uo(g), {
    get data() {
      return faAngleRight;
    }
  });
  var m = fo(g, 2), b = (e3) => {
    var n3 = rh(), t4 = uo(n3);
    ko(() => Xr(t4, Sr(r2))), Dr("click", n3, () => f(Sr(r2))), Hr(e3, n3);
  };
  sa(m, (e3) => {
    void 0 !== Sr(r2) && e3(b);
  }), Ha(h2, (e3) => Xt(u, e3), () => Sr(u)), ko((e3) => p2 = Ca(g, 1, "jse-navigation-bar-button jse-navigation-bar-arrow svelte-752ro1", null, p2, e3), [() => ({
    "jse-open": Sr(v)
  })], Lt), Dr("click", g, function() {
    if (Sr(u)) {
      Xt(v, true);
      var e3 = {
        items: d()(Sr(o2)),
        selectedItem: Sr(r2),
        onSelect: f
      };
      t3 = a2(oh, e3, {
        anchor: Sr(u),
        closeOnOuterClick: true,
        onClose: () => {
          Xt(v, false);
        }
      });
    }
  }), Hr(e2, h2), Nt();
}
function sh(e2) {
  var n2, t3;
  if (navigator.clipboard) return navigator.clipboard.writeText(e2);
  if (null !== (n2 = (t3 = document).queryCommandSupported) && void 0 !== n2 && n2.call(t3, "copy")) {
    var o2 = document.createElement("textarea");
    o2.value = e2, o2.style.position = "fixed", o2.style.opacity = "0", document.body.appendChild(o2), o2.select();
    try {
      document.execCommand("copy");
    } catch (e3) {
      console.error(e3);
    } finally {
      document.body.removeChild(o2);
    }
    return Promise.resolve();
  }
  return console.error("Copy failed."), Promise.resolve();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-navigation-bar-path-editor.svelte-zc2wx7 {\n  flex: 1;\n  display: flex;\n  border: var(--jse-edit-outline, 2px solid #656565);\n  background: var(--jse-background-color, #fff);\n}\n.jse-navigation-bar-path-editor.svelte-zc2wx7 input.jse-navigation-bar-text:where(.svelte-zc2wx7) {\n  flex: 1;\n  font-family: inherit;\n  font-size: inherit;\n  padding: 0 5px 1px;\n  background: var(--jse-background-color, #fff);\n  color: var(--jse-text-color, #4d4d4d);\n  border: none;\n  outline: none;\n}\n.jse-navigation-bar-path-editor.svelte-zc2wx7 button:where(.svelte-zc2wx7) {\n  border: none;\n  background: var(--jse-background-color, #fff);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: 80%;\n  color: inherit;\n}\n.jse-navigation-bar-path-editor.svelte-zc2wx7 button.jse-navigation-bar-copy.copied:where(.svelte-zc2wx7) {\n  color: var(--message-success-background, #9ac45d);\n}\n.jse-navigation-bar-path-editor.svelte-zc2wx7 button.jse-navigation-bar-validation-error:where(.svelte-zc2wx7) {\n  color: var(--jse-error-color, #ee5341);\n}\n.jse-navigation-bar-path-editor.error.svelte-zc2wx7 {\n  border-color: var(--jse-error-color, #ee5341);\n}\n.jse-navigation-bar-path-editor.error.svelte-zc2wx7 input.jse-navigation-bar-text:where(.svelte-zc2wx7) {\n  color: var(--jse-error-color, #ee5341);\n}\n.jse-navigation-bar-path-editor.svelte-zc2wx7 .jse-copied-text:where(.svelte-zc2wx7) {\n  background: var(--message-success-background, #9ac45d);\n  color: var(--jse-message-success-color, #fff);\n  position: relative;\n  margin: 2px;\n  padding: 0 5px;\n  border-radius: 3px;\n}');
var lh = Lr('<button type="button" class="jse-navigation-bar-validation-error svelte-zc2wx7"><!></button>');
var ch = Lr('<div class="jse-copied-text svelte-zc2wx7">Copied!</div>');
var dh = Lr('<div><input type="text" class="jse-navigation-bar-text svelte-zc2wx7"/> <!> <!> <button type="button" title="Copy selected path to the clipboard"><!></button></div>');
function uh(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(), o2 = Pt("absolute-popup"), a2 = ai(n2, "path", 8), i2 = ai(n2, "pathParser", 8), s2 = ai(n2, "onChange", 8), l = ai(n2, "onClose", 8), c = ai(n2, "onError", 8), d = ai(n2, "pathExists", 8), u = Kt(), v = Kt(), f = Kt(false), p2 = void 0, h2 = Kt(false);
  function g() {
    Sr(u).focus();
  }
  function m(e3) {
    try {
      var n3 = i2().parse(e3);
      return function(e4) {
        if (!d()(e4)) throw new Error("Path does not exist in current document");
      }(n3), {
        path: n3,
        error: void 0
      };
    } catch (e4) {
      return {
        path: void 0,
        error: e4
      };
    }
  }
  ta(() => {
    g();
  }), oa(() => {
    clearTimeout(p2);
  }), xo(() => (Ar(i2()), Ar(a2())), () => {
    Xt(v, i2().stringify(a2()));
  }), xo(() => (Sr(f), Sr(v)), () => {
    Xt(t3, Sr(f) ? m(Sr(v)).error : void 0);
  }), yo(), Ka();
  var b, j = dh(), x = uo(j);
  Ha(x, (e3) => Xt(u, e3), () => Sr(u));
  var y = fo(x, 2), w = (e3) => {
    var n3 = lh();
    nl(uo(n3), {
      get data() {
        return faExclamationTriangle;
      }
    }), ba(n3, (e4, n4) => null == nu ? void 0 : nu(e4, n4), () => r({
      text: String(Sr(t3) || "")
    }, o2)), Hr(e3, n3);
  };
  sa(y, (e3) => {
    Sr(t3) && e3(w);
  });
  var k = fo(y, 2), S = (e3) => {
    Hr(e3, ch());
  };
  sa(k, (e3) => {
    Sr(h2) && e3(S);
  });
  var C3, z3 = fo(k, 2);
  nl(uo(z3), {
    get data() {
      return faCopy;
    }
  }), ko((e3, n3) => {
    b = Ca(j, 1, "jse-navigation-bar-path-editor svelte-zc2wx7", null, b, e3), Na(x, Sr(v)), C3 = Ca(z3, 1, "jse-navigation-bar-copy svelte-zc2wx7", null, C3, n3);
  }, [() => ({
    error: Sr(t3)
  }), () => ({
    copied: Sr(h2)
  })], Lt), Dr("keydown", x, Qa(function(e3) {
    var n3 = Ns(e3);
    if ("Escape" === n3 && (e3.preventDefault(), l()()), "Enter" === n3) {
      e3.preventDefault(), Xt(f, true);
      var t4 = m(Sr(v));
      void 0 !== t4.path ? s2()(t4.path) : c()(t4.error);
    }
  })), Dr("input", x, function(e3) {
    Xt(v, e3.currentTarget.value);
  }), Dr("click", z3, function() {
    sh(Sr(v)), Xt(h2, true), p2 = window.setTimeout(() => Xt(h2, false), 1e3), g();
  }), Hr(e2, j), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-navigation-bar.svelte-xs03gj {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  background: var(--jse-panel-background, #ebebeb);\n  color: var(--jse-panel-button-color, inherit);\n  padding: 0;\n  margin: 0;\n  display: flex;\n  overflow: auto;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit:where(.svelte-xs03gj) {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  background: transparent;\n  border: none;\n  display: flex;\n  cursor: pointer;\n  outline: none;\n  align-items: center;\n}\n.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.flex:where(.svelte-xs03gj) {\n  flex: 1;\n}\n.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit:where(.svelte-xs03gj):focus, .jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit:where(.svelte-xs03gj):hover, .jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit.editing:where(.svelte-xs03gj) {\n  background: var(--jse-panel-button-background-highlight, #e0e0e0);\n  color: var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));\n  transition: color 0.2s ease-in, background 0.2s ease-in;\n}\n.jse-navigation-bar.svelte-xs03gj .jse-navigation-bar-edit:where(.svelte-xs03gj) .jse-navigation-bar-space:where(.svelte-xs03gj) {\n  flex: 1;\n  text-align: left;\n}');
var vh = Lr("<!> <!>", 1);
var fh = Lr('<div class="jse-navigation-bar svelte-xs03gj"><!> <button type="button"><span class="jse-navigation-bar-space svelte-xs03gj"> </span> <!></button></div>');
function ph(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), r2 = ii("jsoneditor:NavigationBar"), a2 = ai(n2, "json", 9), i2 = ai(n2, "selection", 9), s2 = ai(n2, "onSelect", 9), l = ai(n2, "onError", 9), c = ai(n2, "pathParser", 9), u = Kt(void 0, true), v = Kt(false, true);
  function f(e3) {
    r2("get items for path", e3);
    var n3 = getIn(a2(), e3);
    if (Array.isArray(n3)) return range_default(0, n3.length).map(String);
    if (pi(n3)) {
      var t4 = Object.keys(n3).slice(0);
      return t4.sort(Xp), t4;
    }
    return [];
  }
  function p2(e3) {
    return existsIn(a2(), e3);
  }
  function h2(e3) {
    r2("select path", JSON.stringify(e3)), s2()(td(e3, e3));
  }
  function g() {
    Xt(v, false);
  }
  function m(e3) {
    g(), h2(e3);
  }
  xo(() => (Ar(i2()), vd), () => {
    Xt(t3, i2() ? vd(i2()) : []);
  }), xo(() => (Ar(a2()), Sr(t3)), () => {
    Xt(o2, hi(getIn(a2(), Sr(t3))));
  }), xo(() => Sr(t3), () => {
    Sr(t3), setTimeout(() => {
      if (Sr(u) && Sr(u).scrollTo) {
        var e3 = Sr(u).scrollWidth - Sr(u).clientWidth;
        e3 > 0 && (r2("scrollTo ", e3), Sr(u).scrollTo({
          left: e3,
          behavior: "smooth"
        }));
      }
    });
  }), yo(), Ka(true);
  var b = fh(), j = uo(b), x = (e3) => {
    var n3 = vh(), r3 = vo(n3);
    da(r3, 1, () => Sr(t3), ca, (e4, n4, o3) => {
      ih(e4, {
        getItems: f,
        get path() {
          return Sr(t3);
        },
        index: o3,
        onSelect: h2
      });
    });
    var a3 = fo(r3, 2), i3 = (e4) => {
      ih(e4, {
        getItems: f,
        get path() {
          return Sr(t3);
        },
        get index() {
          return Sr(t3), Or(() => Sr(t3).length);
        },
        onSelect: h2
      });
    };
    sa(a3, (e4) => {
      Sr(o2) && e4(i3);
    }), Hr(e3, n3);
  }, y = (e3) => {
    uh(e3, {
      get path() {
        return Sr(t3);
      },
      onClose: g,
      onChange: m,
      get onError() {
        return l();
      },
      pathExists: p2,
      get pathParser() {
        return c();
      }
    });
  };
  sa(j, (e3) => {
    Sr(v) ? e3(y, false) : e3(x);
  });
  var w, S = fo(j, 2), C3 = uo(S), z3 = uo(C3), O = fo(C3, 2), M2 = Lt(() => Sr(v) ? faClose : faEdit);
  nl(O, {
    get data() {
      return Sr(M2);
    }
  }), Ha(b, (e3) => Xt(u, e3), () => Sr(u)), ko((e3, n3) => {
    w = Ca(S, 1, "jse-navigation-bar-edit svelte-xs03gj", null, w, e3), Ia(S, "title", Sr(v) ? "Cancel editing the selected path" : "Edit the selected path"), Xr(z3, n3);
  }, [() => ({
    flex: !Sr(v),
    editing: Sr(v)
  }), () => (Ar(hi), Ar(a2()), Sr(v), Or(() => hi(a2()) || Sr(v) ? "" : "Navigation bar"))], Lt), Dr("click", S, function() {
    Xt(v, !Sr(v));
  }), Hr(e2, b), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-search-box.svelte-1mxl2uo {\n  border: var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));\n  border-radius: 3px;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  background: var(--jse-panel-background, #ebebeb);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n  display: inline-block;\n  width: 400px;\n  max-width: 100%;\n  overflow: auto;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) {\n  display: flex;\n  align-items: stretch;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) button:where(.svelte-1mxl2uo),\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) input:where(.svelte-1mxl2uo) {\n  font-family: inherit;\n  font-size: inherit;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) button:where(.svelte-1mxl2uo) {\n  display: block;\n  text-align: center;\n  border: none;\n  padding: 0 5px;\n  margin: 0;\n  cursor: pointer;\n  color: var(--jse-panel-button-color, inherit);\n  background: var(--jse-panel-button-background, transparent);\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) button:where(.svelte-1mxl2uo):hover {\n  color: var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));\n  background: var(--jse-panel-button-background-highlight, #e0e0e0);\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) input:where(.svelte-1mxl2uo) {\n  color: var(--jse-panel-color, var(--jse-text-color, #4d4d4d));\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  border-radius: 3px;\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n  height: 28px;\n  padding: 0 5px;\n  margin: 0;\n  flex: 1;\n  width: 0;\n  min-width: 50px;\n  outline: none;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-replace-toggle:where(.svelte-1mxl2uo) {\n  padding: var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px));\n  min-width: 20px;\n  background: var(--jse-panel-button-background-highlight, #e0e0e0);\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  gap: calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-search-section:where(.svelte-1mxl2uo) {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  position: relative;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-search-section:where(.svelte-1mxl2uo) .jse-search-icon:where(.svelte-1mxl2uo) {\n  color: inherit;\n  cursor: inherit;\n  background: inherit;\n  width: 32px;\n  text-align: center;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-search-section:where(.svelte-1mxl2uo) label.jse-search-input-label:where(.svelte-1mxl2uo) {\n  flex: 1;\n  display: flex;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-search-section:where(.svelte-1mxl2uo) .jse-search-count:where(.svelte-1mxl2uo) {\n  color: inherit;\n  font-size: 80%;\n  visibility: hidden;\n  padding: 0 5px;\n  min-width: 36px;\n  text-align: center;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-search-section:where(.svelte-1mxl2uo) .jse-search-count.jse-visible:where(.svelte-1mxl2uo) {\n  visibility: visible;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-replace-section:where(.svelte-1mxl2uo) {\n  flex: 1;\n  display: flex;\n  padding-left: 32px;\n}\n.jse-search-box.svelte-1mxl2uo .jse-search-form:where(.svelte-1mxl2uo) .jse-search-contents:where(.svelte-1mxl2uo) .jse-replace-section:where(.svelte-1mxl2uo) button:where(.svelte-1mxl2uo) {\n  width: auto;\n}');
var hh = Lr('<button type="button" class="jse-replace-toggle svelte-1mxl2uo" title="Toggle visibility of replace options (Ctrl+H)"><!></button>');
var gh = Lr('<div class="jse-replace-section svelte-1mxl2uo"><input class="jse-replace-input svelte-1mxl2uo" title="Enter replacement text" type="text" placeholder="Replace"/> <button type="button" title="Replace current occurrence (Ctrl+Enter)" class="svelte-1mxl2uo">Replace</button> <button type="button" title="Replace all occurrences" class="svelte-1mxl2uo">All</button></div>');
var mh = Lr('<div class="jse-search-box svelte-1mxl2uo"><form class="jse-search-form svelte-1mxl2uo"><!> <div class="jse-search-contents svelte-1mxl2uo"><div class="jse-search-section svelte-1mxl2uo"><div class="jse-search-icon svelte-1mxl2uo"><!></div> <label class="jse-search-input-label svelte-1mxl2uo" about="jse-search input"><input class="jse-search-input svelte-1mxl2uo" title="Enter text to search" type="text" placeholder="Find"/></label> <div> </div> <button type="button" class="jse-search-next svelte-1mxl2uo" title="Go to next search result (Enter)"><!></button> <button type="button" class="jse-search-previous svelte-1mxl2uo" title="Go to previous search result (Shift+Enter)"><!></button> <button type="button" class="jse-search-clear svelte-1mxl2uo" title="Close search box (Esc)"><!></button></div> <!></div></form></div>');
function bh(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), a2 = Kt(void 0, true), s2 = ii("jsoneditor:SearchBox"), l = ai(n2, "json", 9), u = ai(n2, "documentState", 9), v = ai(n2, "parser", 9), f = ai(n2, "showSearch", 9), p2 = ai(n2, "showReplace", 13), h2 = ai(n2, "readOnly", 9), g = ai(n2, "columns", 9), m = ai(n2, "onSearch", 9), b = ai(n2, "onFocus", 9), j = ai(n2, "onPatch", 9), x = ai(n2, "onClose", 9), y = Kt("", true), w = "", k = Kt("", true), S = Kt(false, true), C3 = Kt(void 0, true), z3 = debounce_default(function(e3) {
    return Y2.apply(this, arguments);
  }, 300), O = debounce_default(function(e3) {
    return K.apply(this, arguments);
  }, 300);
  function M2() {
    p2(!p2() && !h2());
  }
  function E(e3) {
    e3.stopPropagation();
    var n3 = Ns(e3);
    "Enter" === n3 && (e3.preventDefault(), Sr(y) !== w ? z3.flush() : _());
    "Shift+Enter" === n3 && (e3.preventDefault(), W2()), "Ctrl+Enter" === n3 && (e3.preventDefault(), p2() ? I() : _()), "Ctrl+H" === n3 && (e3.preventDefault(), M2()), "Escape" === n3 && (e3.preventDefault(), G2());
  }
  function A2(e3) {
    "Enter" === Ns(e3) && (e3.preventDefault(), e3.stopPropagation(), I());
  }
  function R() {
    return N2.apply(this, arguments);
  }
  function N2() {
    return (N2 = i(function* () {
      wr(), yield z3.flush();
    })).apply(this, arguments);
  }
  function I() {
    return U2.apply(this, arguments);
  }
  function U2() {
    return (U2 = i(function* () {
      var e3;
      if (!h2()) {
        var n3 = null === (e3 = Sr(C3)) || void 0 === e3 ? void 0 : e3.activeItem;
        if (s2("handleReplace", {
          replaceText: Sr(k),
          activeItem: n3
        }), Sr(C3) && n3 && void 0 !== l()) {
          Xt(C3, r(r({}, qd(Sr(C3))), {}, {
            activeIndex: Sr(o2)
          }));
          var {
            operations: t4,
            newSelection: a3
          } = Ud(l(), u(), Sr(k), n3, v());
          j()(t4, (e4, n4) => ({
            state: n4,
            selection: a3
          })), wr(), yield O.flush(), yield $();
        }
      }
    })).apply(this, arguments);
  }
  function D2() {
    return J.apply(this, arguments);
  }
  function J() {
    return (J = i(function* () {
      if (!h2()) {
        s2("handleReplaceAll", {
          text: Sr(y),
          replaceText: Sr(k)
        });
        var {
          operations: e3,
          newSelection: n3
        } = function(e4, n4, t4, o3, r2) {
          for (var a3 = Pd(t4, e4, {
            maxResults: 1 / 0
          }), i2 = [], s3 = 0; s3 < a3.length; s3++) {
            var l2 = a3[s3 - 1], u2 = a3[s3];
            0 !== s3 && u2.field === l2.field && isEqual_default(u2.path, l2.path) ? last_default(i2).items.push(u2) : i2.push({
              path: u2.path,
              field: u2.field,
              items: [u2]
            });
          }
          i2.sort((e5, n5) => e5.field !== n5.field ? e5.field === ss.key ? 1 : -1 : n5.path.length - e5.path.length);
          var v2, f2 = [];
          return i2.forEach((t5) => {
            var {
              field: a4,
              path: i3,
              items: s4
            } = t5;
            if (a4 === ss.key) {
              var l3 = initial_default(i3), u3 = getIn(e4, l3), p3 = last_default(i3), h3 = yd(l3, Object.keys(u3), p3, Id(p3, o3, s4));
              f2 = f2.concat(h3), v2 = Wc(e4, h3);
            } else {
              if (a4 !== ss.value) throw new Error("Cannot replace: unknown type of search result field ".concat(a4));
              var g2 = getIn(e4, i3);
              if (void 0 === g2) throw new Error("Cannot replace: path not found ".concat(compileJSONPointer(i3)));
              var m2 = "string" == typeof g2 ? g2 : String(g2), b2 = bc(e4, n4, i3), j2 = Id(m2, o3, s4), x2 = [{
                op: "replace",
                path: compileJSONPointer(i3),
                value: b2 ? j2 : Si(j2, r2)
              }];
              f2 = f2.concat(x2), v2 = Wc(e4, x2);
            }
          }), {
            operations: f2,
            newSelection: v2
          };
        }(l(), u(), Sr(y), Sr(k), v());
        j()(e3, (e4, t4) => ({
          state: t4,
          selection: n3
        })), yield $();
      }
    })).apply(this, arguments);
  }
  function B(e3) {
    e3.select();
  }
  function _() {
    return L.apply(this, arguments);
  }
  function L() {
    return (L = i(function* () {
      Xt(C3, Sr(C3) ? qd(Sr(C3)) : void 0), yield $();
    })).apply(this, arguments);
  }
  function W2() {
    return V2.apply(this, arguments);
  }
  function V2() {
    return V2 = i(function* () {
      Xt(C3, Sr(C3) ? function(e3) {
        var n3 = e3.activeIndex > 0 ? e3.activeIndex - 1 : e3.items.length - 1, t4 = e3.items[n3], o3 = e3.items.map((e4, t5) => r(r({}, e4), {}, {
          active: t5 === n3
        }));
        return r(r({}, e3), {}, {
          items: o3,
          activeItem: t4,
          activeIndex: n3
        });
      }(Sr(C3)) : void 0), yield $();
    }), V2.apply(this, arguments);
  }
  function $() {
    return H2.apply(this, arguments);
  }
  function H2() {
    return (H2 = i(function* () {
      var e3;
      s2("handleFocus", Sr(C3));
      var n3 = null === (e3 = Sr(C3)) || void 0 === e3 ? void 0 : e3.activeItem;
      n3 && void 0 !== l() && (yield b()(n3.path, n3.resultIndex));
    })).apply(this, arguments);
  }
  function Q() {
    return Q = i(function* (e3) {
      yield Z2(e3, Sr(y), l());
    }), Q.apply(this, arguments);
  }
  function Y2() {
    return Y2 = i(function* (e3) {
      yield Z2(f(), e3, l()), yield $();
    }), Y2.apply(this, arguments);
  }
  function K() {
    return K = i(function* (e3) {
      yield Z2(f(), Sr(y), e3);
    }), K.apply(this, arguments);
  }
  function Z2(e3, n3, t4) {
    return X2.apply(this, arguments);
  }
  function X2() {
    return X2 = i(function* (e3, n3, t4) {
      return e3 ? (s2("applySearch", {
        showSearch: e3,
        text: n3
      }), "" === n3 ? (s2("clearing search result"), void 0 !== Sr(C3) && Xt(C3, void 0), Promise.resolve()) : (w = n3, Xt(S, true), new Promise((e4) => {
        setTimeout(() => {
          var o3 = Pd(n3, t4, {
            maxResults: ll,
            columns: g()
          });
          Xt(C3, function(e5, n4) {
            var t5 = null != n4 && n4.activeItem ? Dd(n4.activeItem) : void 0, o4 = e5.findIndex((e6) => isEqual_default(t5, Dd(e6))), a3 = -1 !== o4 ? o4 : void 0 !== (null == n4 ? void 0 : n4.activeIndex) && (null == n4 ? void 0 : n4.activeIndex) < e5.length ? null == n4 ? void 0 : n4.activeIndex : e5.length > 0 ? 0 : -1, i2 = e5.map((e6, n5) => r(r({
              resultIndex: n5
            }, e6), {}, {
              active: n5 === a3
            }));
            return {
              items: i2,
              activeItem: i2[a3],
              activeIndex: a3
            };
          }(o3, Sr(C3))), Xt(S, false), e4();
        });
      }))) : (Sr(C3) && Xt(C3, void 0), Promise.resolve());
    }), X2.apply(this, arguments);
  }
  function G2() {
    s2("handleClose"), z3.cancel(), O.cancel(), Z2(false, Sr(y), l()), x()();
  }
  xo(() => Sr(C3), () => {
    var e3;
    Xt(t3, (null === (e3 = Sr(C3)) || void 0 === e3 || null === (e3 = e3.items) || void 0 === e3 ? void 0 : e3.length) || 0);
  }), xo(() => Sr(C3), () => {
    var e3;
    Xt(o2, (null === (e3 = Sr(C3)) || void 0 === e3 ? void 0 : e3.activeIndex) || 0);
  }), xo(() => (Sr(t3), ll), () => {
    Xt(a2, Sr(t3) >= ll ? "".concat(999, "+") : String(Sr(t3)));
  }), xo(() => (Ar(m()), Sr(C3)), () => {
    m()(Sr(C3));
  }), xo(() => Ar(f()), () => {
    !function(e3) {
      Q.apply(this, arguments);
    }(f());
  }), xo(() => Sr(y), () => {
    z3(Sr(y));
  }), xo(() => Ar(l()), () => {
    O(l());
  }), yo(), Ka(true);
  var ee = $r(), te = vo(ee), oe = (e3) => {
    var n3 = mh(), r2 = uo(n3), i2 = uo(r2), s3 = (e4) => {
      var n4 = hh(), t4 = uo(n4), o3 = Lt(() => p2() ? faCaretDown : faCaretRight);
      nl(t4, {
        get data() {
          return Sr(o3);
        }
      }), Dr("click", n4, M2), Hr(e4, n4);
    };
    sa(i2, (e4) => {
      h2() || e4(s3);
    });
    var l2 = uo(fo(i2, 2)), c = uo(l2), d = uo(c), u2 = (e4) => {
      nl(e4, {
        get data() {
          return faCircleNotch;
        },
        spin: true
      });
    }, v2 = (e4) => {
      nl(e4, {
        get data() {
          return faSearch;
        }
      });
    };
    sa(d, (e4) => {
      Sr(S) ? e4(u2) : e4(v2, false);
    });
    var f2 = fo(c, 2), g2 = uo(f2);
    jo(() => Fa(g2, () => Sr(y), (e4) => Xt(y, e4))), ba(g2, (e4) => null == B ? void 0 : B(e4)), jo(() => Dr("paste", g2, R));
    var m2, b2 = fo(f2, 2), j2 = uo(b2), x2 = fo(b2, 2);
    nl(uo(x2), {
      get data() {
        return faChevronDown;
      }
    });
    var w2 = fo(x2, 2);
    nl(uo(w2), {
      get data() {
        return faChevronUp;
      }
    });
    var C4 = fo(w2, 2);
    nl(uo(C4), {
      get data() {
        return faTimes;
      }
    });
    var z4 = fo(l2, 2), O2 = (e4) => {
      var n4 = gh(), t4 = uo(n4), o3 = fo(t4, 2), r3 = fo(o3, 2);
      Fa(t4, () => Sr(k), (e5) => Xt(k, e5)), Dr("keydown", t4, A2), Dr("click", o3, I), Dr("click", r3, D2), Hr(e4, n4);
    };
    sa(z4, (e4) => {
      p2() && !h2() && e4(O2);
    }), ko((e4) => {
      var n4;
      m2 = Ca(b2, 1, "jse-search-count svelte-1mxl2uo", null, m2, e4), Xr(j2, "".concat(-1 !== Sr(o2) && Sr(o2) < Sr(t3) ? "".concat(Sr(o2) + 1, "/") : "").concat(null !== (n4 = Sr(a2)) && void 0 !== n4 ? n4 : ""));
    }, [() => ({
      "jse-visible": "" !== Sr(y)
    })], Lt), Dr("click", x2, _), Dr("click", w2, W2), Dr("click", C4, G2), Dr("keydown", r2, E), Hr(e3, n3);
  };
  sa(te, (e3) => {
    f() && e3(oe);
  }), Hr(e2, ee), Nt();
}
var jh = Symbol("path");
function xh(e2, n2) {
  var t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0, o2 = {};
  Array.isArray(e2) && function(e3, n3, t4) {
    if (e3.length < n3) e3.forEach(t4);
    else for (var o3 = n3 > 1 ? (e3.length - 1) / (n3 - 1) : e3.length, r3 = 0; r3 < n3; r3++) {
      var a2 = Math.floor(r3 * o3);
      t4(e3[a2], a2, e3);
    }
  }(e2, t3, (e3) => {
    pi(e3) ? yh(e3, o2, n2) : o2[jh] = true;
  });
  var r2 = [];
  return jh in o2 && r2.push([]), wh(o2, [], r2, n2), r2;
}
function yh(e2, n2, t3) {
  for (var o2 in e2) {
    var r2 = e2[o2], a2 = n2[o2] || (n2[o2] = {});
    pi(r2) && t3 ? yh(r2, a2, t3) : void 0 === a2[jh] && (a2[jh] = true);
  }
}
function wh(e2, n2, t3, o2) {
  for (var r2 in e2) {
    var a2 = n2.concat(r2), i2 = e2[r2];
    i2 && true === i2[jh] && t3.push(a2), isJSONObject(i2) && o2 && wh(i2, a2, t3, o2);
  }
}
function kh(e2, n2, t3, o2, r2, a2) {
  for (var i2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 80, s2 = isJSONArray(t3) ? t3.length : 0, l = function(e3, n3) {
    var t4 = Object.values(e3);
    if (isEmpty_default(t4)) return n3;
    var o3 = (e4, n4) => e4 + n4;
    return t4.reduce(o3) / t4.length;
  }(o2, r2), c = e2 - i2, d = n2 + 2 * i2, u = (e3) => o2[e3] || r2, v = 0, f = a2; f < c && v < s2; ) f += u(v), v++;
  v > 0 && (f -= u(--v));
  for (var p2 = v, h2 = 0; h2 < d && p2 < s2; ) h2 += u(p2), p2++;
  for (var g = 0, m = p2; m < s2; m++) g += u(m);
  return {
    startIndex: v,
    endIndex: p2,
    startHeight: f,
    endHeight: g,
    averageItemHeight: l,
    visibleHeight: h2,
    visibleItems: isJSONArray(t3) ? t3.slice(v, p2) : []
  };
}
function Sh(e2, n2, t3, o2) {
  for (var {
    rowIndex: r2
  } = Ch(e2, n2), a2 = 0, i2 = 0; i2 < r2; i2++) a2 += t3[i2] || o2;
  return a2;
}
function Ch(e2, n2) {
  var [t3, ...o2] = e2, r2 = parseInt(t3, 10);
  return {
    rowIndex: isNaN(r2) ? -1 : r2,
    columnIndex: n2.findIndex((e3) => Qc(o2, e3))
  };
}
function zh(e2, n2) {
  var {
    rowIndex: t3,
    columnIndex: o2
  } = e2;
  return [String(t3), ...n2[o2]];
}
function Oh(e2, n2) {
  var [t3, o2] = partition_default(e2, (e3) => vi(e3.path[0])), r2 = groupBy_default(t3, Eh), a2 = mapValues_default(r2, (e3) => {
    var t4 = {
      row: [],
      columns: {}
    };
    return e3.forEach((e4) => {
      var o3 = function(e5, n3) {
        var t5 = Ch(e5.path, n3);
        if (-1 !== t5.columnIndex) return t5.columnIndex;
        return -1;
      }(e4, n2);
      -1 !== o3 ? (void 0 === t4.columns[o3] && (t4.columns[o3] = []), t4.columns[o3].push(e4)) : t4.row.push(e4);
    }), t4;
  });
  return {
    root: o2,
    rows: a2
  };
}
function Mh(e2, n2) {
  if (n2 && 0 !== n2.length) return 1 === n2.length ? n2[0] : {
    path: e2,
    message: "Multiple validation issues: " + n2.map((e3) => au(e3.path) + " " + e3.message).join(", "),
    severity: is.warning
  };
}
function Eh(e2) {
  return parseInt(e2.path[0], 10);
}
function Ah(e2, n2, t3) {
  var o2 = n2.some((n3) => function(e3, n4, t4) {
    if (!e3) return false;
    if ("replace" === n4.op) {
      var o3 = parseJSONPointer(n4.path), {
        rowIndex: r2,
        columnIndex: a2
      } = Ch(o3, t4), i2 = t4.findIndex((n5) => isEqual_default(n5, e3.path));
      if (-1 !== r2 && -1 !== a2 && a2 !== i2) return false;
    }
    return true;
  }(e2, n3, t3));
  return o2 ? void 0 : e2;
}
var Rh = ii("jsoneditor:actions");
function qh(e2) {
  return Ph.apply(this, arguments);
}
function Ph() {
  return Ph = i(function* (e2) {
    var {
      json: n2,
      selection: t3,
      indentation: o2,
      readOnly: r2,
      parser: a2,
      onPatch: i2
    } = e2;
    if (!r2 && void 0 !== n2 && t3 && ad(t3)) {
      var s2 = od(n2, t3, o2, a2);
      if (void 0 !== s2) {
        Rh("cut", {
          selection: t3,
          clipboard: s2,
          indentation: o2
        }), yield sh(s2);
        var {
          operations: l,
          newSelection: c
        } = Md(n2, t3);
        i2(l, (e3, n3) => ({
          state: n3,
          selection: c
        }));
      }
    }
  }), Ph.apply(this, arguments);
}
function Th(e2) {
  return Nh.apply(this, arguments);
}
function Nh() {
  return Nh = i(function* (e2) {
    var {
      json: n2,
      selection: t3,
      indentation: o2,
      parser: r2
    } = e2, a2 = od(n2, t3, o2, r2);
    void 0 !== a2 && (Rh("copy", {
      clipboard: a2,
      indentation: o2
    }), yield sh(a2));
  }), Nh.apply(this, arguments);
}
function Ih(e2) {
  var {
    clipboardText: n2,
    json: t3,
    selection: o2,
    readOnly: r2,
    parser: a2,
    onPatch: i2,
    onChangeText: s2,
    onPasteMultilineText: l,
    openRepairModal: c
  } = e2;
  if (!r2) try {
    d(n2);
  } catch (e3) {
    c(n2, (e4) => {
      Rh("repaired pasted text: ", e4), d(e4);
    });
  }
  function d(e3) {
    if (void 0 !== t3) {
      var r3 = o2 || Xc([]), c2 = Sd(t3, r3, e3, a2), d2 = function(e4, n3, t4) {
        var o3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : pl;
        if (e4.length > o3) return false;
        var r4 = /\n/.test(e4);
        if (!r4) return false;
        var a3 = n3.some((e5) => "replace" === e5.op && Array.isArray(e5.value)), i3 = n3.filter((e5) => "add" === e5.op).length > 1;
        if (!a3 && !i3) return false;
        try {
          return Di(e4, t4.parse), false;
        } catch (e5) {
          return true;
        }
      }(n2, c2, a2);
      Rh("paste", {
        pastedText: e3,
        operations: c2,
        ensureSelection: r3,
        pasteMultilineText: d2
      }), i2(c2, (e4, n3) => {
        var o3 = n3;
        return c2.filter((e5) => (isJSONPatchAdd(e5) || isJSONPatchReplace(e5)) && hi(e5.value)).forEach((n4) => {
          var r4 = parsePath(t3, n4.path);
          o3 = kc(e4, o3, r4);
        }), {
          state: o3
        };
      }), d2 && l(e3);
    } else Rh("paste text", {
      pastedText: e3
    }), s2(n2, (e4, n3) => {
      if (e4) {
        return {
          state: kc(e4, n3, [])
        };
      }
    });
  }
}
function Uh(e2) {
  var {
    json: n2,
    text: t3,
    selection: o2,
    keepSelection: r2,
    readOnly: a2,
    onChange: i2,
    onPatch: s2
  } = e2;
  if (!a2 && o2) {
    var l = void 0 !== n2 && (Rc(o2) || qc(o2)) ? td(o2.path, o2.path) : o2;
    if (isEmpty_default(vd(o2))) Rh("remove root", {
      selection: o2
    }), i2 && i2({
      text: "",
      json: void 0
    }, void 0 !== n2 ? {
      text: void 0,
      json: n2
    } : {
      text: t3 || "",
      json: n2
    }, {
      contentErrors: void 0,
      patchResult: void 0
    });
    else if (void 0 !== n2) {
      var {
        operations: c,
        newSelection: d
      } = Md(n2, l);
      Rh("remove", {
        operations: c,
        selection: o2,
        newSelection: d
      }), s2(c, (e3, n3) => ({
        state: n3,
        selection: r2 ? o2 : d
      }));
    }
  }
}
function Dh(e2) {
  var {
    insertType: n2,
    selectInside: t3,
    initialValue: o2,
    json: r2,
    selection: a2,
    readOnly: i2,
    parser: s2,
    onPatch: l,
    onReplaceJson: c
  } = e2;
  if (!i2) {
    var u = function(e3, n3, t4) {
      if ("object" === t4) return {};
      if ("array" === t4) return [];
      if ("structure" === t4 && void 0 !== e3) {
        var o3 = n3 ? Dc(n3) : [], r3 = getIn(e3, o3);
        if (Array.isArray(r3) && !isEmpty_default(r3)) {
          var a3 = head_default(r3);
          return hi(a3) ? cloneDeepWith_default(a3, (e4) => Array.isArray(e4) ? [] : pi(e4) ? void 0 : "") : "";
        }
      }
      return "";
    }(r2, a2, n2);
    if (void 0 !== r2) {
      var v = s2.stringify(u), f = Sd(r2, a2, v, s2);
      Rh("onInsert", {
        insertType: n2,
        operations: f,
        newValue: u,
        data: v
      });
      var p2 = last_default(f.filter((e3) => "add" === e3.op || "replace" === e3.op));
      l(f, (e3, n3, r3) => {
        if (p2) {
          var a3 = parsePath(e3, p2.path);
          if (hi(u)) return {
            state: ic(e3, n3, a3, Oc),
            selection: t3 ? ed(a3) : r3
          };
          if ("" === u) {
            var i3 = isEmpty_default(a3) ? void 0 : getIn(e3, initial_default(a3));
            return {
              state: ic(e3, n3, a3, Mc),
              selection: pi(i3) ? Zc(a3, o2) : Gc(a3, o2)
            };
          }
        }
      }), Rh("after patch");
    } else {
      Rh("onInsert", {
        insertType: n2,
        newValue: u
      });
      var h2 = [];
      c(u, (e3, n3) => ({
        state: kc(e3, n3, h2),
        selection: hi(u) ? ed(h2) : Gc(h2)
      }));
    }
  }
}
function Jh(e2) {
  return Bh.apply(this, arguments);
}
function Bh() {
  return Bh = i(function* (e2) {
    var {
      char: n2,
      selectInside: t3,
      json: o2,
      selection: a2,
      readOnly: i2,
      parser: s2,
      onPatch: l,
      onReplaceJson: c,
      onSelect: u
    } = e2;
    i2 || (Rc(a2) ? u(r(r({}, a2), {}, {
      edit: true,
      initialValue: n2
    })) : "{" === n2 ? Dh({
      insertType: "object",
      selectInside: t3,
      initialValue: void 0,
      json: o2,
      selection: a2,
      readOnly: i2,
      parser: s2,
      onPatch: l,
      onReplaceJson: c
    }) : "[" === n2 ? Dh({
      insertType: "array",
      selectInside: t3,
      initialValue: void 0,
      json: o2,
      selection: a2,
      readOnly: i2,
      parser: s2,
      onPatch: l,
      onReplaceJson: c
    }) : qc(a2) && void 0 !== o2 ? hi(getIn(o2, a2.path)) || u(r(r({}, a2), {}, {
      edit: true,
      initialValue: n2
    })) : (Rh("onInsertValueWithCharacter", {
      char: n2
    }), yield function(e3) {
      return _h.apply(this, arguments);
    }({
      char: n2,
      json: o2,
      selection: a2,
      readOnly: i2,
      parser: s2,
      onPatch: l,
      onReplaceJson: c
    })));
  }), Bh.apply(this, arguments);
}
function _h() {
  return _h = i(function* (e2) {
    var {
      char: n2,
      json: t3,
      selection: o2,
      readOnly: r2,
      parser: a2,
      onPatch: i2,
      onReplaceJson: s2
    } = e2;
    r2 || Dh({
      insertType: "value",
      selectInside: false,
      initialValue: n2,
      json: t3,
      selection: o2,
      readOnly: r2,
      parser: a2,
      onPatch: i2,
      onReplaceJson: s2
    });
  }), _h.apply(this, arguments);
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-json-preview.svelte-1vjn89h {\n  flex: 1;\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  overflow: auto;\n  white-space: pre-wrap;\n  padding: 2px;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}');
var Fh = Lr('<div class="jse-json-preview svelte-1vjn89h"> </div>');
function Lh(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(), o2 = Kt(), r2 = ai(n2, "text", 8), a2 = ai(n2, "json", 8), i2 = ai(n2, "indentation", 8), s2 = ai(n2, "parser", 8);
  xo(() => (Ar(a2()), Ar(r2())), () => {
    Xt(t3, void 0 !== a2() ? {
      json: a2()
    } : {
      text: r2() || ""
    });
  }), xo(() => (Sr(t3), Ar(i2()), Ar(s2()), ul), () => {
    Xt(o2, Vs(Yi(Sr(t3), i2(), s2()), ul));
  }), yo(), Ka();
  var l = Fh(), c = uo(l);
  ko(() => Xr(c, Sr(o2))), Hr(e2, l), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\nbutton.jse-context-menu-button.svelte-1idfykj {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  flex: 1;\n  white-space: nowrap;\n  padding: var(--jse-padding, 10px);\n  color: inherit;\n}\nbutton.jse-context-menu-button.svelte-1idfykj:hover {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n}\nbutton.jse-context-menu-button.svelte-1idfykj:focus {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n  z-index: 1;\n}\nbutton.jse-context-menu-button.svelte-1idfykj:disabled {\n  color: var(--jse-context-menu-color-disabled, #9d9d9d);\n  background: unset;\n}\nbutton.jse-context-menu-button.left.svelte-1idfykj {\n  text-align: left;\n}\nbutton.jse-context-menu-button.svelte-1idfykj svg {\n  width: 16px;\n}');
var Wh = Lr('<button type="button"><!> <!></button>');
function Vh(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "item", 8), o2 = ai(n2, "className", 8, void 0), r2 = ai(n2, "onRequestClose", 8);
  Ka();
  var a2 = Wh(), i2 = uo(a2), s2 = (e3) => {
    nl(e3, {
      get data() {
        return Ar(t3()), Or(() => t3().icon);
      }
    });
  };
  sa(i2, (e3) => {
    Ar(t3()), Or(() => t3().icon) && e3(s2);
  });
  var l = fo(i2, 2), c = (e3) => {
    var n3 = Vr();
    ko(() => Xr(n3, (Ar(t3()), Or(() => t3().text)))), Hr(e3, n3);
  };
  sa(l, (e3) => {
    Ar(t3()), Or(() => t3().text) && e3(c);
  }), ko((e3) => {
    Ca(a2, 1, e3, "svelte-1idfykj"), Ia(a2, "title", (Ar(t3()), Or(() => t3().title))), a2.disabled = (Ar(t3()), Or(() => t3().disabled || false));
  }, [() => ya((Ar(pd), Ar(o2()), Ar(t3()), Or(() => pd("jse-context-menu-button", o2(), t3().className))))], Lt), Dr("click", a2, (e3) => {
    r2()(), t3().onClick(e3);
  }), Hr(e2, a2), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-dropdown-button.svelte-11rxb2m {\n  flex: 1;\n  line-height: normal;\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  position: relative;\n  padding: 0;\n  display: flex;\n}\n.jse-dropdown-button.svelte-11rxb2m ul:where(.svelte-11rxb2m) {\n  margin: 0;\n  padding: 0;\n}\n.jse-dropdown-button.svelte-11rxb2m ul:where(.svelte-11rxb2m) li:where(.svelte-11rxb2m) {\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n}\n.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown:where(.svelte-11rxb2m) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  width: 2em;\n  background: var(--jse-context-menu-background, #656565);\n  color: var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));\n  border-radius: 0;\n}\n.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown.jse-visible:where(.svelte-11rxb2m) {\n  background: var(--jse-context-menu-background, #656565);\n}\n.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown:where(.svelte-11rxb2m):hover {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n}\n.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown:where(.svelte-11rxb2m):focus {\n  z-index: 1;\n}\n.jse-dropdown-button.svelte-11rxb2m button.jse-open-dropdown:where(.svelte-11rxb2m):disabled {\n  color: var(--jse-context-menu-color-disabled, #9d9d9d);\n  background: unset;\n}\n.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items:where(.svelte-11rxb2m) {\n  display: none;\n  position: absolute;\n  top: 100%;\n  left: 0;\n  z-index: 1;\n  background: var(--jse-context-menu-background, #656565);\n  color: var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n}\n.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items.jse-visible:where(.svelte-11rxb2m) {\n  display: block;\n}\n.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items:where(.svelte-11rxb2m) button:where(.svelte-11rxb2m) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  width: 100%;\n  text-align: left;\n  padding: var(--jse-padding, 10px);\n  margin: 0;\n}\n.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items:where(.svelte-11rxb2m) button:where(.svelte-11rxb2m):hover {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n}\n.jse-dropdown-button.svelte-11rxb2m .jse-dropdown-items:where(.svelte-11rxb2m) button:where(.svelte-11rxb2m):disabled {\n  color: var(--jse-context-menu-color-disabled, #9d9d9d);\n  background: unset;\n}');
var $h = Lr('<li class="svelte-11rxb2m"><button type="button"><!> </button></li>');
var Hh = Lr('<div role="button" tabindex="0" class="jse-dropdown-button svelte-11rxb2m"><!> <button type="button" data-type="jse-open-dropdown"><!></button> <div><ul class="svelte-11rxb2m"></ul></div></div>');
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\nbutton.jse-context-menu-button.svelte-1idfykj {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  flex: 1;\n  white-space: nowrap;\n  padding: var(--jse-padding, 10px);\n  color: inherit;\n}\nbutton.jse-context-menu-button.svelte-1idfykj:hover {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n}\nbutton.jse-context-menu-button.svelte-1idfykj:focus {\n  background: var(--jse-context-menu-background-highlight, #7a7a7a);\n  z-index: 1;\n}\nbutton.jse-context-menu-button.svelte-1idfykj:disabled {\n  color: var(--jse-context-menu-color-disabled, #9d9d9d);\n  background: unset;\n}\nbutton.jse-context-menu-button.left.svelte-1idfykj {\n  text-align: left;\n}\nbutton.jse-context-menu-button.svelte-1idfykj svg {\n  width: 16px;\n}');
var Qh = Lr('<button type="button" slot="defaultItem"><!> </button>');
function Yh(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(), o2 = ai(n2, "item", 8), a2 = ai(n2, "className", 8, void 0), i2 = ai(n2, "onRequestClose", 8);
  xo(() => (Ar(o2()), Ar(i2())), () => {
    Xt(t3, o2().items.map((e3) => r(r({}, e3), {}, {
      onClick: (n3) => {
        i2()(), e3.onClick(n3);
      }
    })));
  }), yo(), Ka(), function(e3, n3) {
    Tt(n3, false);
    var t4 = Kt(void 0, true), o3 = ai(n3, "items", 25, () => []), r2 = ai(n3, "title", 9, void 0), a3 = ai(n3, "width", 9, "120px"), i3 = Kt(false, true);
    function s2() {
      Xt(i3, false);
    }
    function l(e4) {
      "Escape" === Ns(e4) && (e4.preventDefault(), Xt(i3, false));
    }
    ta(() => {
      document.addEventListener("click", s2), document.addEventListener("keydown", l);
    }), oa(() => {
      document.removeEventListener("click", s2), document.removeEventListener("keydown", l);
    }), xo(() => Ar(o3()), () => {
      Xt(t4, o3().every((e4) => true === e4.disabled));
    }), yo(), Ka(true);
    var c = Hh(), d = uo(c);
    ga(d, n3, "defaultItem", {}, null);
    var u, v = fo(d, 2);
    nl(uo(v), {
      get data() {
        return faCaretDown;
      }
    });
    var f, p2 = fo(v, 2);
    da(uo(p2), 5, o3, ca, (e4, n4) => {
      var t5 = $h(), o4 = uo(t5), r3 = uo(o4), a4 = (e5) => {
        nl(e5, {
          get data() {
            return Sr(n4), Or(() => Sr(n4).icon);
          }
        });
      };
      sa(r3, (e5) => {
        Sr(n4), Or(() => Sr(n4).icon) && e5(a4);
      });
      var i4 = fo(r3);
      ko(() => {
        var e5;
        Ia(o4, "title", (Sr(n4), Or(() => Sr(n4).title))), o4.disabled = (Sr(n4), Or(() => Sr(n4).disabled)), Ca(o4, 1, ya((Sr(n4), Or(() => Sr(n4).className))), "svelte-11rxb2m"), Xr(i4, " ".concat(null !== (Sr(n4), e5 = Or(() => Sr(n4).text)) && void 0 !== e5 ? e5 : ""));
      }), Dr("click", o4, (e5) => Sr(n4).onClick(e5)), Hr(e4, t5);
    }), ko((e4, n4) => {
      var o4;
      Ia(c, "title", r2()), u = Ca(v, 1, "jse-open-dropdown svelte-11rxb2m", null, u, e4), v.disabled = Sr(t4), f = Ca(p2, 1, "jse-dropdown-items svelte-11rxb2m", null, f, n4), Oa(p2, "width: ".concat(null !== (o4 = a3()) && void 0 !== o4 ? o4 : "", ";"));
    }, [() => ({
      "jse-visible": Sr(i3)
    }), () => ({
      "jse-visible": Sr(i3)
    })], Lt), Dr("click", v, function() {
      var e4 = Sr(i3);
      setTimeout(() => Xt(i3, !e4));
    }), Dr("click", c, s2), Hr(e3, c), Nt();
  }(e2, {
    get width() {
      return Ar(o2()), Or(() => o2().width);
    },
    get items() {
      return Sr(t3);
    },
    $$slots: {
      defaultItem: (e3, n3) => {
        var t4 = Qh(), r2 = uo(t4), s2 = (e4) => {
          nl(e4, {
            get data() {
              return Ar(o2()), Or(() => o2().main.icon);
            }
          });
        };
        sa(r2, (e4) => {
          Ar(o2()), Or(() => o2().main.icon) && e4(s2);
        });
        var l = fo(r2);
        ko((e4) => {
          var n4;
          Ca(t4, 1, e4, "svelte-1idfykj"), Ia(t4, "title", (Ar(o2()), Or(() => o2().main.title))), t4.disabled = (Ar(o2()), Or(() => o2().main.disabled || false)), Xr(l, " ".concat(null !== (Ar(o2()), n4 = Or(() => o2().main.text)) && void 0 !== n4 ? n4 : ""));
        }, [() => ya((Ar(pd), Ar(a2()), Ar(o2()), Or(() => pd("jse-context-menu-button", a2(), o2().main.className))))], Lt), Dr("click", t4, (e4) => {
          i2()(), o2().main.onClick(e4);
        }), Hr(e3, t4);
      }
    }
  }), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-contextmenu.svelte-12z7bz1 {\n  box-shadow: var(--jse-controls-box-shadow, 0 2px 6px 0 rgba(0, 0, 0, 0.24));\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  background: var(--jse-context-menu-background, #656565);\n  color: var(--jse-context-menu-color, var(--jse-text-color-inverse, #fff));\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-row:where(.svelte-12z7bz1) {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-start;\n  justify-content: stretch;\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-row:where(.svelte-12z7bz1) div.jse-label:where(.svelte-12z7bz1) {\n  flex: 1;\n  white-space: nowrap;\n  padding: var(--jse-padding, 10px);\n  color: var(--jse-context-menu-color-disabled, #9d9d9d);\n  line-height: normal;\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-row:where(.svelte-12z7bz1) div.jse-tip:where(.svelte-12z7bz1) {\n  flex: 1;\n  background: var(--jse-context-menu-tip-background, rgba(255, 255, 255, 0.2));\n  color: var(--context-menu-tip-color, inherit);\n  margin: calc(0.5 * var(--jse-padding, 10px));\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n  font-size: 80%;\n  line-height: 1.3em;\n  display: flex;\n  flex-direction: row;\n  align-items: flex-start;\n  gap: var(--jse-padding, 10px);\n  border-radius: 3px;\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-row:where(.svelte-12z7bz1) div.jse-tip:where(.svelte-12z7bz1) div.jse-tip-icon:where(.svelte-12z7bz1) {\n  padding-top: calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-column:where(.svelte-12z7bz1) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-column:where(.svelte-12z7bz1):not(:last-child) {\n  border-right: 1px solid var(--jse-context-menu-separator-color, #7a7a7a);\n}\n.jse-contextmenu.svelte-12z7bz1 .jse-separator:where(.svelte-12z7bz1) {\n  width: 100%;\n  height: 1px;\n  background: var(--jse-context-menu-separator-color, #7a7a7a);\n}');
var Kh = Lr('<div class="jse-separator svelte-12z7bz1"></div>');
var Zh = Lr('<div class="jse-label svelte-12z7bz1"> </div>');
var Xh = Lr('<div class="jse-column svelte-12z7bz1"></div>');
var Gh = Lr('<div class="jse-separator svelte-12z7bz1"></div>');
var eg = Lr('<div class="jse-row svelte-12z7bz1"></div>');
var ng = Lr('<div class="jse-separator svelte-12z7bz1"></div>');
var tg = Lr('<div class="jse-row svelte-12z7bz1"><div class="jse-tip svelte-12z7bz1"><div class="jse-tip-icon svelte-12z7bz1"><!></div> <div class="jse-tip-text"> </div></div></div>');
var og = Lr('<div role="menu" tabindex="-1" class="jse-contextmenu svelte-12z7bz1"><!> <!></div>');
function rg(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "items", 9), o2 = ai(n2, "onRequestClose", 9), r2 = ai(n2, "tip", 9), a2 = Kt(void 0, true);
  ta(() => {
    var e3 = Array.from(Sr(a2).querySelectorAll("button")).find((e4) => !e4.disabled);
    e3 && e3.focus();
  });
  var i2 = {
    ArrowUp: "Up",
    ArrowDown: "Down",
    ArrowLeft: "Left",
    ArrowRight: "Right"
  };
  function s2(e3) {
    return console.error("Unknown type of context menu item", e3), "???";
  }
  Ka(true);
  var l = og(), c = uo(l);
  da(c, 1, t3, ca, (e3, n3) => {
    var t4 = $r(), r3 = vo(t4), a3 = (e4) => {
      Vh(e4, {
        get item() {
          return Sr(n3);
        },
        get onRequestClose() {
          return o2();
        }
      });
    }, i3 = (e4, t5) => {
      var r4 = (e5) => {
        Yh(e5, {
          get item() {
            return Sr(n3);
          },
          get onRequestClose() {
            return o2();
          }
        });
      }, a4 = (e5, t6) => {
        var r5 = (e6) => {
          var t7 = eg();
          da(t7, 5, () => (Sr(n3), Or(() => Sr(n3).items)), ca, (e7, n4) => {
            var t8 = $r(), r6 = vo(t8), a6 = (e8) => {
              Vh(e8, {
                get item() {
                  return Sr(n4);
                },
                get onRequestClose() {
                  return o2();
                }
              });
            }, i4 = (e8, t9) => {
              var r7 = (e9) => {
                Yh(e9, {
                  get item() {
                    return Sr(n4);
                  },
                  get onRequestClose() {
                    return o2();
                  }
                });
              }, a7 = (e9, t10) => {
                var r8 = (e10) => {
                  var t11 = Xh();
                  da(t11, 5, () => (Sr(n4), Or(() => Sr(n4).items)), ca, (e11, n5) => {
                    var t12 = $r(), r9 = vo(t12), a9 = (e12) => {
                      Vh(e12, {
                        className: "left",
                        get item() {
                          return Sr(n5);
                        },
                        get onRequestClose() {
                          return o2();
                        }
                      });
                    }, i5 = (e12, t13) => {
                      var r10 = (e13) => {
                        Yh(e13, {
                          className: "left",
                          get item() {
                            return Sr(n5);
                          },
                          get onRequestClose() {
                            return o2();
                          }
                        });
                      }, a10 = (e13, t14) => {
                        var o3 = (e14) => {
                          Hr(e14, Kh());
                        }, r11 = (e14, t15) => {
                          var o4 = (e15) => {
                            var t16 = Zh(), o5 = uo(t16);
                            ko(() => Xr(o5, (Sr(n5), Or(() => Sr(n5).text)))), Hr(e15, t16);
                          }, r12 = (e15) => {
                            var t16 = Vr();
                            ko((e16) => Xr(t16, e16), [() => (Sr(n5), Or(() => s2(Sr(n5))))], Lt), Hr(e15, t16);
                          };
                          sa(e14, (e15) => {
                            Ar(ql), Sr(n5), Or(() => ql(Sr(n5))) ? e15(o4) : e15(r12, false);
                          }, t15);
                        };
                        sa(e13, (e14) => {
                          Ar(Rl), Sr(n5), Or(() => Rl(Sr(n5))) ? e14(o3) : e14(r11, false);
                        }, t14);
                      };
                      sa(e12, (e13) => {
                        Ar(Tl), Sr(n5), Or(() => Tl(Sr(n5))) ? e13(r10) : e13(a10, false);
                      }, t13);
                    };
                    sa(r9, (e12) => {
                      Ar(Pl), Sr(n5), Or(() => Pl(Sr(n5))) ? e12(a9) : e12(i5, false);
                    }), Hr(e11, t12);
                  }), Hr(e10, t11);
                }, a8 = (e10, t11) => {
                  var o3 = (e11) => {
                    Hr(e11, Gh());
                  }, r9 = (e11) => {
                    var t12 = Vr();
                    ko((e12) => Xr(t12, e12), [() => (Sr(n4), Or(() => s2(Sr(n4))))], Lt), Hr(e11, t12);
                  };
                  sa(e10, (e11) => {
                    Ar(Rl), Sr(n4), Or(() => Rl(Sr(n4))) ? e11(o3) : e11(r9, false);
                  }, t11);
                };
                sa(e9, (e10) => {
                  Ar(Il), Sr(n4), Or(() => Il(Sr(n4))) ? e10(r8) : e10(a8, false);
                }, t10);
              };
              sa(e8, (e9) => {
                Ar(Tl), Sr(n4), Or(() => Tl(Sr(n4))) ? e9(r7) : e9(a7, false);
              }, t9);
            };
            sa(r6, (e8) => {
              Ar(Pl), Sr(n4), Or(() => Pl(Sr(n4))) ? e8(a6) : e8(i4, false);
            }), Hr(e7, t8);
          }), Hr(e6, t7);
        }, a5 = (e6, t7) => {
          var o3 = (e7) => {
            Hr(e7, ng());
          }, r6 = (e7) => {
            var t8 = Vr();
            ko((e8) => Xr(t8, e8), [() => (Sr(n3), Or(() => s2(Sr(n3))))], Lt), Hr(e7, t8);
          };
          sa(e6, (e7) => {
            Ar(Rl), Sr(n3), Or(() => Rl(Sr(n3))) ? e7(o3) : e7(r6, false);
          }, t7);
        };
        sa(e5, (e6) => {
          Ar(Nl), Sr(n3), Or(() => Nl(Sr(n3))) ? e6(r5) : e6(a5, false);
        }, t6);
      };
      sa(e4, (e5) => {
        Ar(Tl), Sr(n3), Or(() => Tl(Sr(n3))) ? e5(r4) : e5(a4, false);
      }, t5);
    };
    sa(r3, (e4) => {
      Ar(Pl), Sr(n3), Or(() => Pl(Sr(n3))) ? e4(a3) : e4(i3, false);
    }), Hr(e3, t4);
  });
  var d = fo(c, 2), u = (e3) => {
    var n3 = tg(), t4 = uo(n3), o3 = uo(t4);
    nl(uo(o3), {
      get data() {
        return faLightbulb;
      }
    });
    var a3 = uo(fo(o3, 2));
    ko(() => Xr(a3, r2())), Hr(e3, n3);
  };
  sa(d, (e3) => {
    r2() && e3(u);
  }), Ha(l, (e3) => Xt(a2, e3), () => Sr(a2)), Dr("keydown", l, function(e3) {
    var n3 = Ns(e3), t4 = i2[n3];
    if (t4 && e3.target) {
      e3.preventDefault();
      var o3 = Ps({
        allElements: Array.from(Sr(a2).querySelectorAll("button:not([disabled])")),
        currentElement: e3.target,
        direction: t4,
        hasPrio: (e4) => "jse-open-dropdown" !== e4.getAttribute("data-type")
      });
      o3 && o3.focus();
    }
  }), Hr(e2, l), Nt();
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-value.jse-string.svelte-6ttr41 {\n  color: var(--jse-value-color-string, #008000);\n}\n.jse-value.jse-object.svelte-6ttr41, .jse-value.jse-array.svelte-6ttr41 {\n  min-width: 16px;\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n}\n.jse-value.jse-number.svelte-6ttr41 {\n  color: var(--jse-value-color-number, #ee422e);\n}\n.jse-value.jse-boolean.svelte-6ttr41 {\n  color: var(--jse-value-color-boolean, #ff8c00);\n}\n.jse-value.jse-null.svelte-6ttr41 {\n  color: var(--jse-value-color-null, #004ed0);\n}\n.jse-value.jse-invalid.svelte-6ttr41 {\n  color: var(--jse-text-color, #4d4d4d);\n}\n.jse-value.jse-url.svelte-6ttr41 {\n  color: var(--jse-value-color-url, #008000);\n  text-decoration: underline;\n}\n\n.jse-enum-value.svelte-6ttr41 {\n  background: var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));\n  border: none;\n  padding: 0;\n  font-family: inherit;\n  font-size: inherit;\n  cursor: pointer;\n  outline: none;\n}\n.jse-enum-value.jse-selected.svelte-6ttr41 {\n  background: var(--jse-selection-background-color, #d3d3d3);\n  color: inherit;\n}\n.jse-enum-value.jse-value.svelte-6ttr41:focus {\n  color: var(--jse-text-color, #4d4d4d);\n}');
var ag = Lr("<option> </option>");
var ig = Lr("<select></select>");
function sg(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "path", 9), o2 = ai(n2, "value", 9), r2 = ai(n2, "mode", 9), a2 = ai(n2, "parser", 9), i2 = ai(n2, "readOnly", 9), s2 = ai(n2, "selection", 9), l = ai(n2, "onPatch", 9), d = ai(n2, "options", 9), u = Kt(void 0, true), v = Kt(o2(), true);
  xo(() => Ar(o2()), () => {
    Xt(v, o2());
  }), xo(() => Ar(s2()), () => {
    !function(e3) {
      e3 && Sr(u) && Sr(u).focus();
    }(s2());
  }), yo(), Ka(true);
  var f, p2 = ig();
  ko(() => {
    Sr(v), zr(() => {
      r2(), a2(), s2(), Sr(u), d();
    });
  }), da(p2, 5, d, ca, (e3, n3) => {
    var t4 = ag(), o3 = uo(t4), r3 = {};
    ko(() => {
      var e4;
      (Xr(o3, (Sr(n3), Or(() => Sr(n3).text))), r3 !== (Sr(n3), r3 = Or(() => Sr(n3).value))) && (t4.value = null !== (e4 = t4.__value = (Sr(n3), Or(() => Sr(n3).value))) && void 0 !== e4 ? e4 : "");
    }), Hr(e3, t4);
  }), Ha(p2, (e3) => Xt(u, e3), () => Sr(u)), ko((e3, n3) => f = Ca(p2, 1, e3, "svelte-6ttr41", f, n3), [() => (Ar(hd), Sr(v), Ar(r2()), Ar(a2()), Or(() => "jse-enum-value ".concat(hd(Sr(v), r2(), a2())))), () => ({
    "jse-selected": qc(s2())
  })], Lt), function(e3, n3) {
    var t4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : n3, o3 = true;
    Tr(e3, "change", (n4) => {
      var o4, r3 = n4 ? "[selected]" : ":checked";
      if (e3.multiple) o4 = [].map.call(e3.querySelectorAll(r3), Aa);
      else {
        var a3, i3 = null !== (a3 = e3.querySelector(r3)) && void 0 !== a3 ? a3 : e3.querySelector("option:not([disabled])");
        o4 = i3 && Aa(i3);
      }
      t4(o4);
    }), jo(() => {
      var r3 = n3();
      if (Ma(e3, r3, o3), o3 && void 0 === r3) {
        var a3 = e3.querySelector(":checked");
        null !== a3 && (r3 = Aa(a3), t4(r3));
      }
      e3.__value = r3, o3 = false;
    }), Ea(e3);
  }(p2, () => Sr(v), (e3) => Xt(v, e3)), Dr("change", p2, function(e3) {
    e3.stopPropagation(), i2() || l()([{
      op: "replace",
      path: compileJSONPointer(t3()),
      value: Sr(v)
    }]);
  }), Dr("mousedown", p2, function(e3) {
    e3.stopPropagation();
  }), Hr(e2, p2), Nt();
}
function lg(e2, n2, t3) {
  var o2 = cg(e2, n2 || {}, t3);
  return o2 ? function(e3) {
    if (Array.isArray(e3.enum)) return e3.enum;
    var n3 = e3.oneOf || e3.anyOf || e3.allOf;
    if (Array.isArray(n3)) {
      var t4 = n3.filter((e4) => e4.enum);
      if (t4.length > 0) return t4[0].enum;
    }
    return;
  }(o2) : void 0;
}
function cg(e2, n2, t3) {
  var o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e2, r2 = t3.slice(1, t3.length), a2 = t3[0], i2 = [o2];
  for (var s2 of [o2.oneOf, o2.anyOf, o2.allOf]) Array.isArray(s2) && (i2 = i2.concat(s2));
  for (var l of i2) {
    if ("$ref" in (o2 = l) && "string" == typeof o2.$ref) {
      var c, d = o2.$ref;
      if (d in n2) o2 = n2[d];
      else {
        if (!d.startsWith("#/")) {
          if (1 === (null === (c = d.match(/#\//g)) || void 0 === c ? void 0 : c.length)) {
            var [u, v] = d.split("#/");
            if (u in n2) {
              var f = n2[u], p2 = {
                $ref: "#/".concat(v)
              }, h2 = [];
              return h2.push(a2), r2.length > 0 && h2.push(...r2), cg(f, n2, h2, p2);
            }
            throw Error("Unable to resolve reference ".concat(d));
          }
          throw Error("Unable to resolve reference ".concat(d));
        }
        var g = d.substring(2).split("/");
        for (var m of (o2 = e2, g)) {
          if (!(m in o2)) throw Error("Unable to resolve reference ".concat(d));
          o2 = o2[m];
        }
      }
    }
    if (void 0 === a2) return o2;
    if ("object" == typeof o2.properties && o2.properties && a2 in o2.properties) return cg(e2, n2, r2, o2 = o2.properties[a2]);
    if ("object" == typeof o2.patternProperties && o2.patternProperties) {
      for (var b in o2.patternProperties) if (a2.match(b)) return cg(e2, n2, r2, o2 = o2.patternProperties[b]);
    }
    if ("object" == typeof o2.additionalProperties) return cg(e2, n2, r2, o2 = o2.additionalProperties);
    if ("object" == typeof o2.items && o2.items) return cg(e2, n2, r2, o2 = o2.items);
  }
}
function dg(e2, n2, t3) {
  var o2 = lg(n2, t3, e2.path);
  if (o2) {
    var a2 = o2.map((e3) => ({
      value: e3,
      text: e3
    })), i2 = o2.includes(e2.value) ? a2 : [{
      value: e2.value,
      text: e2.value
    }].concat(a2);
    return [{
      component: sg,
      props: r(r({}, e2), {}, {
        options: i2
      })
    }];
  }
}
function ug(e2) {
  return hg(pg(e2).compile(e2.schema), e2);
}
function vg(e2) {
  return fg.apply(this, arguments);
}
function fg() {
  return (fg = i(function* (e2) {
    var n2 = pg(e2);
    return hg(yield n2.compileAsync(e2.schema), e2);
  })).apply(this, arguments);
}
function pg(e2) {
  var n2, t3, {
    schemaDefinitions: o2,
    ajvOptions: a2
  } = e2, i2 = new import_ajv.default(r({
    allErrors: true,
    verbose: true,
    $data: true
  }, a2));
  if (o2 && Object.keys(o2).forEach((e3) => {
    i2.addSchema(o2[e3], e3);
  }), false === (i2 = null !== (n2 = null === (t3 = e2.onCreateAjv) || void 0 === t3 ? void 0 : t3.call(e2, i2)) && void 0 !== n2 ? n2 : i2).opts.verbose) throw new Error("Ajv must be configured with the option verbose=true");
  return i2;
}
function hg(e2, n2) {
  if (e2.errors) throw e2.errors[0];
  return function(t3) {
    var o2;
    return e2(t3), (null !== (o2 = e2.errors) && void 0 !== o2 ? o2 : []).map(gg).map((e3) => function(e4, n3, t4) {
      var o3, r2;
      return {
        path: parsePath(e4, n3.instancePath),
        message: null !== (o3 = n3.message) && void 0 !== o3 ? o3 : "Unknown error",
        severity: null !== (r2 = t4.errorSeverity) && void 0 !== r2 ? r2 : is.warning
      };
    }(t3, e3, n2));
  };
}
function gg(e2) {
  var n2 = void 0;
  if ("enum" === e2.keyword && Array.isArray(e2.schema)) {
    var t3 = e2.schema;
    if (t3) {
      if ((t3 = t3.map((e3) => JSON.stringify(e3))).length > 5) {
        var o2 = ["(" + (t3.length - 5) + " more...)"];
        (t3 = t3.slice(0, 5)).push(o2);
      }
      n2 = "should be equal to one of: " + t3.join(", ");
    }
  }
  return "additionalProperties" === e2.keyword && (n2 = "should NOT have additional property: " + e2.params.additionalProperty), n2 ? r(r({}, e2), {}, {
    message: n2
  }) : e2;
}
var mg = {
  id: "jmespath",
  name: "JMESPath",
  description: '\n<p>\n  Enter a <a href="https://jmespath.org" target="_blank" rel="noopener noreferrer">JMESPath</a> query \n  to filter, sort, or transform the JSON data.\n To learn JMESPath, go to <a href="https://jmespath.org/tutorial.html" target="_blank" rel="noopener noreferrer">the interactive tutorial</a>.\n</p>\n',
  createQuery: function(e2, n2) {
    var {
      sort: t3,
      filter: o2,
      projection: r2
    } = n2, a2 = "";
    if (o2 && o2.path && o2.relation && o2.value) {
      var i2 = ["0"].concat(o2.path), s2 = getIn(e2, i2), l = $s(o2.value), c = "string" == typeof s2 && null != l ? '"'.concat(o2.value, '"') : l;
      a2 += "[? " + bg(o2.path) + " " + o2.relation + " `" + c + "`]";
    } else a2 += Array.isArray(e2) ? "[*]" : "@";
    t3 && t3.path && t3.direction && ("desc" === t3.direction ? a2 += " | reverse(sort_by(@, &" + bg(t3.path) + "))" : a2 += " | sort_by(@, &" + bg(t3.path) + ")");
    if (r2 && r2.paths) if ("]" !== a2[a2.length - 1] && (a2 += " | [*]"), 1 === r2.paths.length) {
      var u = r2.paths[0];
      a2 += 0 === u.length ? "" : "." + bg(u);
    } else r2.paths.length > 1 && (a2 += ".{" + r2.paths.map((e3) => jg(e3[e3.length - 1]) + ": " + bg(e3)).join(", ") + "}");
    return a2;
  },
  executeQuery: function(e2, n2, t3) {
    var o2 = ns(t3, JSON) ? e2 : function(e3) {
      var n3 = t3.stringify(e3);
      return void 0 !== n3 ? JSON.parse(n3) : void 0;
    }(e2);
    return import_jmespath.default.search(o2, n2);
  }
};
function bg(e2) {
  if (0 === e2.length) return "@";
  var n2 = e2.map((e3) => "number" == typeof e3 ? "[" + e3 + "]" : "." + jg(String(e3))).join("");
  return "." === n2[0] ? n2.slice(1) : n2;
}
function jg(e2) {
  return e2.match(/^[A-Za-z\d_$]+$/) ? e2 : JSON.stringify(e2);
}
var xg = {
  id: "jsonpath",
  name: "JSONPath",
  description: '\n<p>\n  Enter a <a href="https://github.com/JSONPath-Plus/JSONPath" target="_blank" \n  rel="noopener noreferrer"><code>JSONPath</code></a> expression to filter, sort, or transform the data.\n</p>',
  createQuery: function(e2, n2) {
    var {
      filter: t3,
      sort: o2,
      projection: r2
    } = n2, a2 = "$";
    if (t3 && t3.path && t3.relation && t3.value) {
      var i2 = $s(t3.value), s2 = JSON.stringify(i2);
      a2 += "[?(@".concat(yg(t3.path), " ").concat(t3.relation, " ").concat(s2, ")]");
    }
    if (o2 && o2.path && o2.direction) throw new Error("Sorting is not supported by JSONPath. Please clear the sorting fields");
    if (r2 && r2.paths) {
      if (r2.paths.length > 1) throw new Error("Picking multiple fields is not supported by JSONPath. Please select only one field");
      a2.endsWith("]") || (a2 += "[*]"), a2 += "".concat(yg(r2.paths[0])).replace(/^\.\.\./, "..");
    }
    return a2;
  },
  executeQuery: function(e2, n2) {
    var t3 = JSONPath({
      json: e2,
      path: n2
    });
    return void 0 !== t3 ? t3 : null;
  }
};
function yg(e2) {
  var n2 = /^[A-z]+$/;
  return e2.map((e3) => n2.test(e3) ? ".".concat(e3) : JSON.stringify([e3])).join("");
}
var wg = {
  id: "lodash",
  name: "Lodash",
  description: '\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n  You can use <a href="https://lodash.com" target="_blank" rel="noopener noreferrer">Lodash</a>\n  functions like <code>_.map</code>, <code>_.filter</code>,\n  <code>_.orderBy</code>, <code>_.sortBy</code>, <code>_.groupBy</code>,\n  <code>_.pick</code>, <code>_.uniq</code>, <code>_.get</code>, etcetera.\n</p>\n',
  createQuery: function(e2, n2) {
    var {
      filter: t3,
      sort: o2,
      projection: r2
    } = n2, a2 = ["  return _.chain(data)\n"];
    if (t3 && t3.path && t3.relation && t3.value) {
      var i2 = "item => item".concat(cu(t3.path)), s2 = $s(t3.value), l = "string" == typeof s2 ? "'".concat(t3.value, "'") : Ci(t3.value) && !Number.isSafeInteger(s2) ? "".concat(t3.value, "n") : t3.value;
      a2.push("    .filter(".concat(i2, " ").concat(t3.relation, " ").concat(l, ")\n"));
    }
    o2 && o2.path && o2.direction && a2.push("    .orderBy([".concat(function(e3) {
      return 0 === e3.length ? "" : e3.every((e4) => uu.test(e4) || du.test(e4)) ? "'" + e3.map(lu).join("").replace(/^\./, "") + "'" : JSON.stringify(e3);
    }(o2.path), "], ['").concat(o2.direction, "'])\n"));
    if (r2 && r2.paths) if (r2.paths.length > 1) {
      var c = r2.paths.map((e3) => {
        var n3 = last_default(e3) || "item";
        return "      ".concat(JSON.stringify(n3), ": item").concat(cu(e3));
      });
      a2.push("    .map(item => ({\n".concat(c.join(",\n"), "\n    }))\n"));
    } else {
      var d = r2.paths[0];
      a2.push("    .map(item => item".concat(cu(d), ")\n"));
    }
    return a2.push("    .value()\n"), "function query (data) {\n".concat(a2.join(""), "}");
  },
  executeQuery: function(e2, n2) {
    !function(e3) {
      var n3, t4, o2 = null === (n3 = e3.match(/_\.chain\(/g)) || void 0 === n3 ? void 0 : n3.length, r2 = null === (t4 = e3.match(/\.value\(\)/g)) || void 0 === t4 ? void 0 : t4.length;
      if (o2 !== r2) throw new Error("Cannot execute query: Lodash _.chain(...) must end with .value()");
    }(n2);
    var t3 = new Function("_", '"use strict";\n\n' + n2 + `

if (typeof query !== "function") {
  throw new Error("Cannot execute query: expecting a function named 'query' but is undefined")
}

return query;
`)(lodash_exports)(e2);
    return void 0 !== t3 ? t3 : null;
  }
};
var kg;
var Sg;
var Cg = {
  id: "javascript",
  name: "JavaScript",
  description: "\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n</p>\n",
  createQuery: function(e2, n2) {
    var {
      filter: t3,
      sort: o2,
      projection: r2
    } = n2, a2 = ["  return data\n"];
    if (t3 && t3.path && t3.relation && t3.value) {
      var i2 = "item => item".concat(cu(t3.path)), s2 = $s(t3.value), l = "string" == typeof s2 ? "'".concat(t3.value, "'") : Ci(t3.value) && !Number.isSafeInteger(s2) ? "".concat(t3.value, "n") : t3.value;
      a2.push("    .filter(".concat(i2, " ").concat(t3.relation, " ").concat(l, ")\n"));
    }
    o2 && o2.path && o2.direction && ("desc" === o2.direction ? a2.push("    .slice()\n    .sort((a, b) => {\n      // sort descending\n" + "      const valueA = a".concat(cu(o2.path), "\n") + "      const valueB = b".concat(cu(o2.path), "\n") + "      return valueA > valueB ? -1 : valueA < valueB ? 1 : 0\n    })\n") : a2.push("    .slice()\n    .sort((a, b) => {\n      // sort ascending\n" + "      const valueA = a".concat(cu(o2.path), "\n") + "      const valueB = b".concat(cu(o2.path), "\n") + "      return valueA > valueB ? 1 : valueA < valueB ? -1 : 0\n    })\n"));
    if (r2 && r2.paths) if (r2.paths.length > 1) {
      var c = r2.paths.map((e3) => {
        var n3 = e3[e3.length - 1] || "item", t4 = "item".concat(cu(e3));
        return "      ".concat(JSON.stringify(n3), ": ").concat(t4);
      });
      a2.push("    .map(item => ({\n".concat(c.join(",\n"), "})\n    )\n"));
    } else {
      var d = "item".concat(cu(r2.paths[0]));
      a2.push("    .map(item => ".concat(d, ")\n"));
    }
    return "function query (data) {\n".concat(a2.join(""), "}");
  },
  executeQuery: function(e2, n2) {
    var t3 = new Function('"use strict";\n\n' + n2 + `

if (typeof query !== "function") {
  throw new Error("Cannot execute query: expecting a function named 'query' but is undefined")
}

return query;
`)()(e2);
    return void 0 !== t3 ? t3 : null;
  }
};
function zg(e2, n2) {
  return kg || (Sg = /* @__PURE__ */ new WeakMap(), kg = new ResizeObserver((e3) => {
    for (var n3 of e3) {
      var t3 = Sg.get(n3.target);
      t3 && t3(n3.target);
    }
  })), Sg.set(e2, n2), kg.observe(e2), {
    destroy: () => {
      Sg.delete(e2), kg.unobserve(e2);
    }
  };
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-tree-mode.svelte-vrx1dr {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  background: var(--jse-background-color, #fff);\n  min-width: 0;\n  min-height: 0;\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: var(--jse-text-color, #4d4d4d);\n  line-height: var(--jse-line-height, calc(1em + 4px));\n}\n.jse-tree-mode.svelte-vrx1dr .jse-hidden-input-label:where(.svelte-vrx1dr) .jse-hidden-input:where(.svelte-vrx1dr) {\n  position: fixed;\n  top: -10px;\n  left: -10px;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  border: 0;\n  outline: none;\n}\n.jse-tree-mode.no-main-menu.svelte-vrx1dr {\n  border-top: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-tree-mode.svelte-vrx1dr .jse-search-box-container:where(.svelte-vrx1dr) {\n  position: relative;\n  height: 0;\n  top: var(--jse-padding, 10px);\n  margin-right: calc(var(--jse-padding, 10px) + 20px);\n  margin-left: var(--jse-padding, 10px);\n  text-align: right;\n  z-index: 3;\n}\n.jse-tree-mode.svelte-vrx1dr .jse-contents:where(.svelte-vrx1dr) {\n  flex: 1;\n  overflow: auto;\n  position: relative;\n  padding: 2px;\n  display: flex;\n  flex-direction: column;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-tree-mode.svelte-vrx1dr .jse-contents:where(.svelte-vrx1dr):last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-tree-mode.svelte-vrx1dr .jse-contents:where(.svelte-vrx1dr) .jse-loading-space:where(.svelte-vrx1dr) {\n  flex: 1;\n}\n.jse-tree-mode.svelte-vrx1dr .jse-contents:where(.svelte-vrx1dr) .jse-loading:where(.svelte-vrx1dr) {\n  flex: 2;\n  text-align: center;\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  box-sizing: border-box;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n}\n.jse-tree-mode.svelte-vrx1dr .jse-contents:where(.svelte-vrx1dr) .jse-search-box-background:where(.svelte-vrx1dr) {\n  border: 50px solid var(--jse-modal-background, #f5f5f5);\n  margin: -2px;\n  margin-bottom: 2px;\n  display: inline-block;\n}');
var Og = Lr("<!> <!>", 1);
var Mg = Lr('<div class="jse-search-box-background svelte-vrx1dr"></div>');
var Eg = Lr('<div class="jse-search-box-container svelte-vrx1dr"><!></div> <div class="jse-contents svelte-vrx1dr"><!> <!></div> <!> <!> <!> <!>', 1);
var Ag = Lr('<label class="jse-hidden-input-label svelte-vrx1dr"><input type="text" tabindex="-1" class="jse-hidden-input svelte-vrx1dr"/></label> <!>', 1);
var Rg = Lr('<div class="jse-contents svelte-vrx1dr"><div class="jse-loading-space svelte-vrx1dr"></div> <div class="jse-loading svelte-vrx1dr">loading...</div></div>');
var qg = Lr('<div role="tree" tabindex="-1"><!> <!> <!></div> <!> <!>', 1);
function Pg(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = ii("jsoneditor:TreeMode"), a2 = "undefined" == typeof window;
  o2("isSSR:", a2);
  var s2 = uniqueId_default(), l = uniqueId_default(), {
    openAbsolutePopup: u,
    closeAbsolutePopup: v
  } = Pt("absolute-popup"), p2 = Kt(void 0, true), h2 = Kt(void 0, true), g = Kt(void 0, true), m = false, b = xf(), j = ai(n2, "readOnly", 9), x = ai(n2, "externalContent", 9), y = ai(n2, "externalSelection", 9), w = ai(n2, "history", 9), S = ai(n2, "truncateTextSize", 9), C3 = ai(n2, "mainMenuBar", 9), z3 = ai(n2, "navigationBar", 9), M2 = ai(n2, "escapeControlCharacters", 9), E = ai(n2, "escapeUnicodeCharacters", 9), A2 = ai(n2, "parser", 9), R = ai(n2, "parseMemoizeOne", 9), N2 = ai(n2, "validator", 9), D2 = ai(n2, "validationParser", 9), J = ai(n2, "pathParser", 9), B = ai(n2, "indentation", 9), _ = ai(n2, "onError", 9), F2 = ai(n2, "onChange", 9), L = ai(n2, "onChangeMode", 9), W2 = ai(n2, "onSelect", 9), V2 = ai(n2, "onUndo", 9), H2 = ai(n2, "onRedo", 9), Q = ai(n2, "onRenderValue", 9), Y2 = ai(n2, "onRenderMenu", 9), K = ai(n2, "onRenderContextMenu", 9), Z2 = ai(n2, "onClassName", 9), X2 = ai(n2, "onFocus", 9), G2 = ai(n2, "onBlur", 9), ee = ai(n2, "onSortModal", 9), ne = ai(n2, "onTransformModal", 9), te = ai(n2, "onJSONEditorModal", 9), oe = false, re = Kt(false, true), ae = Kt(void 0, true);
  Mf({
    onMount: ta,
    onDestroy: oa,
    getWindow: () => Os(Sr(g)),
    hasFocus: () => oe && document.hasFocus() || Ms(Sr(g)),
    onFocus: () => {
      m = true, X2() && X2()();
    },
    onBlur: () => {
      m = false, G2() && G2()();
    }
  });
  var ie3 = Kt(void 0, true), se = Kt(void 0, true), le = void 0, ue = false, ve = Kt(Zl({
    json: Sr(ie3)
  }), true), xe = Kt(Nc(y()) ? y() : void 0, true);
  function ye(e3) {
    Xt(xe, e3);
  }
  ta(() => {
    if (Sr(xe)) {
      var e3 = vd(Sr(xe));
      Xt(ve, ic(Sr(ie3), Sr(ve), e3, Mc)), setTimeout(() => $n2(e3));
    }
  });
  var we, ke = Kt(void 0, true), Se = Kt(void 0, true), De = Kt(void 0, true), Je = Kt(void 0, true), Be = Kt(false, true), _e = Kt(false, true);
  function Fe2(e3) {
    Xt(Je, (we = e3) ? Fd(Sr(ie3), we.items) : void 0);
  }
  function We2(e3, n3) {
    return Ve2.apply(this, arguments);
  }
  function Ve2() {
    return (Ve2 = i(function* (e3, n3) {
      Xt(ve, ic(Sr(ie3), Sr(ve), e3, Mc));
      var t4 = Vn2(n3);
      yield Fn2(e3, {
        element: t4
      });
    })).apply(this, arguments);
  }
  function $e() {
    Xt(Be, false), Xt(_e, false), ht3();
  }
  function He(e3) {
    o2("select validation error", e3), Xt(xe, Xc(e3.path)), Fn2(e3.path);
  }
  function Qe(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : zc;
    o2("expand"), Xt(ve, ic(Sr(ie3), Sr(ve), e3, n3));
  }
  function Ye(e3, n3) {
    Xt(ve, sc(Sr(ie3), Sr(ve), e3, n3)), Sr(xe) && function(e4, n4) {
      return Qc(vd(e4), n4) && (vd(e4).length > n4.length || Ac(e4));
    }(Sr(xe), e3) && Xt(xe, void 0);
  }
  var Ke = Kt(false, true), Ze = Kt([], true), Xe = Kt(void 0, true), Ge = memoizeOne(Cf);
  function en(e3, n3, t4, a3) {
    yf(() => {
      var i2;
      try {
        i2 = Ge(e3, n3, t4, a3);
      } catch (e4) {
        i2 = [{
          path: [],
          message: "Failed to validate: " + e4.message,
          severity: is.warning
        }];
      }
      isEqual_default(i2, Sr(Ze)) || (o2("validationErrors changed:", i2), Xt(Ze, i2), Xt(Xe, function(e4, n4) {
        var t5;
        return n4.forEach((n5) => {
          t5 = Sf(e4, t5, n5.path, (e5, t6) => r(r({}, t6), {}, {
            validationError: n5
          }));
        }), n4.forEach((n5) => {
          for (var o3 = n5.path; o3.length > 0; ) o3 = initial_default(o3), t5 = Sf(e4, t5, o3, (e5, n6) => n6.validationError ? n6 : r(r({}, n6), {}, {
            validationError: {
              isChildError: true,
              path: o3,
              message: "Contains invalid data",
              severity: is.warning
            }
          }));
        }), t5;
      }(e3, Sr(Ze))));
    }, (e4) => o2("validationErrors updated in ".concat(e4, " ms")));
  }
  function nn() {
    return o2("validate"), le ? {
      parseError: le,
      isRepairable: false
    } : (en(Sr(ie3), N2(), A2(), D2()), isEmpty_default(Sr(Ze)) ? void 0 : {
      validationErrors: Sr(Ze)
    });
  }
  function tn() {
    return Sr(ie3);
  }
  function on() {
    return Sr(ve);
  }
  function rn() {
    return Sr(xe);
  }
  function an(e3) {
    o2("applyExternalContent", {
      updatedContent: e3
    }), $i(e3) ? function(e4) {
      if (void 0 === e4) return;
      var n3 = !isEqual_default(Sr(ie3), e4);
      if (o2("update external json", {
        isChanged: n3,
        currentlyText: void 0 === Sr(ie3)
      }), !n3) return;
      var t4 = {
        documentState: Sr(ve),
        selection: Sr(xe),
        json: Sr(ie3),
        text: Sr(se),
        textIsRepaired: Sr(Ke)
      };
      Xt(ie3, e4), Xt(ve, tc(e4, Sr(ve))), sn(Sr(ie3)), Xt(se, void 0), Xt(Ke, false), le = void 0, ln(Sr(ie3)), cn(t4);
    }(e3.json) : Vi(e3) && function(e4) {
      if (void 0 === e4 || $i(x())) return;
      var n3 = e4 !== Sr(se);
      if (o2("update external text", {
        isChanged: n3
      }), !n3) return;
      var t4 = {
        documentState: Sr(ve),
        selection: Sr(xe),
        json: Sr(ie3),
        text: Sr(se),
        textIsRepaired: Sr(Ke)
      };
      try {
        Xt(ie3, R()(e4)), Xt(ve, tc(Sr(ie3), Sr(ve))), sn(Sr(ie3)), Xt(se, e4), Xt(Ke, false), le = void 0;
      } catch (n4) {
        try {
          Xt(ie3, R()(jsonrepair(e4))), Xt(ve, tc(Sr(ie3), Sr(ve))), sn(Sr(ie3)), Xt(se, e4), Xt(Ke, true), le = void 0, ln(Sr(ie3));
        } catch (e5) {
          Xt(ie3, void 0), Xt(ve, void 0), Xt(se, x().text), Xt(Ke, false), le = void 0 !== Sr(se) && "" !== Sr(se) ? _i(Sr(se), n4.message || String(n4)) : void 0;
        }
      }
      ln(Sr(ie3)), cn(t4);
    }(e3.text);
  }
  function sn(e3) {
    ue || (ue = true, Xt(ve, kc(e3, Sr(ve), [])));
  }
  function ln(e3) {
    Sr(xe) && (existsIn(e3, fd(Sr(xe))) && existsIn(e3, vd(Sr(xe))) || (o2("clearing selection: path does not exist anymore", Sr(xe)), Xt(xe, Lc(e3, Sr(ve)))));
  }
  function cn(e3) {
    if (void 0 !== e3.json || void 0 !== e3.text) {
      var n3 = void 0 !== Sr(ie3) && void 0 !== e3.json;
      w().add({
        type: "tree",
        undo: {
          patch: n3 ? [{
            op: "replace",
            path: "",
            value: e3.json
          }] : void 0,
          json: e3.json,
          text: e3.text,
          documentState: e3.documentState,
          textIsRepaired: e3.textIsRepaired,
          selection: Yc(e3.selection),
          sortedColumn: void 0
        },
        redo: {
          patch: n3 ? [{
            op: "replace",
            path: "",
            value: Sr(ie3)
          }] : void 0,
          json: Sr(ie3),
          text: Sr(se),
          documentState: Sr(ve),
          textIsRepaired: Sr(Ke),
          selection: Yc(Sr(xe)),
          sortedColumn: void 0
        }
      });
    }
  }
  function dn(e3, n3) {
    var t4;
    if (o2("patch", e3, n3), void 0 === Sr(ie3)) throw new Error("Cannot apply patch: no JSON");
    var a3 = Sr(ie3), i2 = {
      json: void 0,
      text: Sr(se),
      documentState: Sr(ve),
      selection: Yc(Sr(xe)),
      textIsRepaired: Sr(Ke),
      sortedColumn: void 0
    }, s3 = Ed(Sr(ie3), e3), l2 = cc(Sr(ie3), Sr(ve), e3), c = null !== (t4 = Wc(Sr(ie3), e3)) && void 0 !== t4 ? t4 : Sr(xe), d = "function" == typeof n3 ? n3(l2.json, l2.documentState, c) : void 0;
    return Xt(ie3, void 0 !== (null == d ? void 0 : d.json) ? d.json : l2.json), Xt(ve, void 0 !== (null == d ? void 0 : d.state) ? d.state : l2.documentState), Xt(xe, void 0 !== (null == d ? void 0 : d.selection) ? d.selection : c), Xt(se, void 0), Xt(Ke, false), Xt(Se, void 0), Xt(De, void 0), le = void 0, ln(Sr(ie3)), w().add({
      type: "tree",
      undo: r({
        patch: s3
      }, i2),
      redo: {
        patch: e3,
        json: void 0,
        text: Sr(se),
        documentState: Sr(ve),
        selection: Yc(Sr(xe)),
        sortedColumn: void 0,
        textIsRepaired: Sr(Ke)
      }
    }), {
      json: Sr(ie3),
      previousJson: a3,
      undo: s3,
      redo: e3
    };
  }
  function un() {
    !j() && Sr(xe) && Xt(xe, Zc(vd(Sr(xe))));
  }
  function vn() {
    if (!j() && Sr(xe)) {
      var e3 = vd(Sr(xe)), n3 = getIn(Sr(ie3), e3);
      hi(n3) ? function(e4, n4) {
        o2("openJSONEditorModal", {
          path: e4,
          value: n4
        }), oe = true, te()({
          content: {
            json: n4
          },
          path: e4,
          onPatch: Sr(jt2).onPatch,
          onClose: () => {
            oe = false, setTimeout(ht3);
          }
        });
      }(e3, n3) : Xt(xe, Gc(e3));
    }
  }
  function fn() {
    if (!j() && qc(Sr(xe))) {
      var e3 = vd(Sr(xe)), n3 = compileJSONPointer(e3), t4 = getIn(Sr(ie3), e3), r2 = !bc(Sr(ie3), Sr(ve), e3), a3 = r2 ? String(t4) : Si(String(t4), A2());
      o2("handleToggleEnforceString", {
        enforceString: r2,
        value: t4,
        updatedValue: a3
      }), Qn2([{
        op: "replace",
        path: n3,
        value: a3
      }], (n4, t5) => ({
        state: fc(Sr(ie3), t5, e3, {
          type: "value",
          enforceString: r2
        })
      }));
    }
  }
  function pn() {
    return Sr(Ke) && void 0 !== Sr(ie3) && Yn2(Sr(ie3)), void 0 !== Sr(ie3) ? {
      json: Sr(ie3)
    } : {
      text: Sr(se) || ""
    };
  }
  function hn() {
    return gn.apply(this, arguments);
  }
  function gn() {
    return gn = i(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      yield qh({
        json: Sr(ie3),
        selection: Sr(xe),
        indentation: e3 ? B() : void 0,
        readOnly: j(),
        parser: A2(),
        onPatch: Qn2
      });
    }), gn.apply(this, arguments);
  }
  function mn() {
    return bn.apply(this, arguments);
  }
  function bn() {
    return bn = i(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      void 0 !== Sr(ie3) && (yield Th({
        json: Sr(ie3),
        selection: Sr(xe),
        indentation: e3 ? B() : void 0,
        parser: A2()
      }));
    }), bn.apply(this, arguments);
  }
  function jn(e3) {
    var n3;
    e3.preventDefault(), wn(null === (n3 = e3.clipboardData) || void 0 === n3 ? void 0 : n3.getData("text/plain"));
  }
  function xn() {
    return yn.apply(this, arguments);
  }
  function yn() {
    return (yn = i(function* () {
      try {
        wn(yield navigator.clipboard.readText());
      } catch (e3) {
        console.error(e3), Xt(re, true);
      }
    })).apply(this, arguments);
  }
  function wn(e3) {
    void 0 !== e3 && Ih({
      clipboardText: e3,
      json: Sr(ie3),
      selection: Sr(xe),
      readOnly: j(),
      parser: A2(),
      onPatch: Qn2,
      onChangeText: Kn2,
      onPasteMultilineText: ot3,
      openRepairModal: kn
    });
  }
  function kn(e3, n3) {
    Xt(ae, {
      text: e3,
      onParse: (e4) => Di(e4, (e5) => Ii(e5, A2())),
      onRepair: Ji,
      onApply: n3,
      onClose: ht3
    });
  }
  function Sn() {
    Uh({
      json: Sr(ie3),
      text: Sr(se),
      selection: Sr(xe),
      keepSelection: false,
      readOnly: j(),
      onChange: F2(),
      onPatch: Qn2
    });
  }
  function Cn() {
    !j() && void 0 !== Sr(ie3) && Sr(xe) && ad && !isEmpty_default(vd(Sr(xe))) && (o2("duplicate", {
      selection: Sr(xe)
    }), Qn2(wd(Sr(ie3), Uc(Sr(ie3), Sr(xe)))));
  }
  function zn() {
    j() || !Sr(xe) || !Pc(Sr(xe)) && !qc(Sr(xe)) || isEmpty_default(vd(Sr(xe))) || (o2("extract", {
      selection: Sr(xe)
    }), Qn2(kd(Sr(ie3), Sr(xe)), (e3, n3) => {
      if (hi(e3)) {
        return {
          state: Sc(e3, n3, [])
        };
      }
    }));
  }
  function On(e3) {
    Dh({
      insertType: e3,
      selectInside: true,
      initialValue: void 0,
      json: Sr(ie3),
      selection: Sr(xe),
      readOnly: j(),
      parser: A2(),
      onPatch: Qn2,
      onReplaceJson: Yn2
    });
  }
  function Mn(e3) {
    Rc(Sr(xe)) && Xt(xe, Xc(Sr(xe).path)), Sr(xe) || Xt(xe, Lc(Sr(ie3), Sr(ve))), On(e3);
  }
  function En(e3) {
    if (!j() && Sr(xe)) if (id(Sr(xe))) try {
      var n3 = fd(Sr(xe)), t4 = getIn(Sr(ie3), n3), r2 = function(e4, n4, t5) {
        if ("array" === n4) {
          if (Array.isArray(e4)) return e4;
          if (pi(e4)) return Pi(e4);
          if ("string" == typeof e4) try {
            var o3 = t5.parse(e4);
            if (Array.isArray(o3)) return o3;
            if (pi(o3)) return Pi(o3);
          } catch (n5) {
            return [e4];
          }
          return [e4];
        }
        if ("object" === n4) {
          if (Array.isArray(e4)) return qi(e4);
          if (pi(e4)) return e4;
          if ("string" == typeof e4) try {
            var r3 = t5.parse(e4);
            if (pi(r3)) return r3;
            if (Array.isArray(r3)) return qi(r3);
          } catch (n5) {
            return {
              value: e4
            };
          }
          return {
            value: e4
          };
        }
        if ("value" === n4) return hi(e4) ? t5.stringify(e4) : e4;
        throw new Error("Cannot convert ".concat(yi(e4, t5), " to ").concat(n4));
      }(t4, e3, A2());
      if (r2 === t4) return;
      var a3 = [{
        op: "replace",
        path: compileJSONPointer(n3),
        value: r2
      }];
      o2("handleConvert", {
        selection: Sr(xe),
        path: n3,
        type: e3,
        operations: a3
      }), Qn2(a3, (e4, n4) => ({
        state: Sr(xe) ? kc(e4, n4, vd(Sr(xe))) : Sr(ve)
      }));
    } catch (e4) {
      _()(e4);
    }
    else _()(new Error("Cannot convert current selection to ".concat(e3)));
  }
  function An() {
    if (Sr(xe)) {
      var e3 = _c(Sr(ie3), Sr(ve), Sr(xe), false), n3 = initial_default(vd(Sr(xe)));
      e3 && !isEmpty_default(vd(e3)) && isEqual_default(n3, initial_default(vd(e3))) ? Xt(xe, nd(vd(e3))) : Xt(xe, ed(n3)), o2("insert before", {
        selection: Sr(xe),
        selectionBefore: e3,
        parentPath: n3
      }), wr(), at4();
    }
  }
  function Rn() {
    if (Sr(xe)) {
      var e3 = Bc(Sr(ie3), Sr(xe));
      o2("insert after", e3), Xt(xe, nd(e3)), wr(), at4();
    }
  }
  function qn(e3) {
    return Pn.apply(this, arguments);
  }
  function Pn() {
    return (Pn = i(function* (e3) {
      yield Jh({
        char: e3,
        selectInside: true,
        json: Sr(ie3),
        selection: Sr(xe),
        readOnly: j(),
        parser: A2(),
        onPatch: Qn2,
        onReplaceJson: Yn2,
        onSelect: ye
      });
    })).apply(this, arguments);
  }
  function Tn() {
    if (!j() && w().canUndo) {
      var e3 = w().undo();
      if (Ql(e3)) {
        var n3 = {
          json: Sr(ie3),
          text: Sr(se)
        };
        Xt(ie3, e3.undo.patch ? immutableJSONPatch(Sr(ie3), e3.undo.patch) : e3.undo.json), Xt(ve, e3.undo.documentState), Xt(xe, e3.undo.selection), Xt(se, e3.undo.text), Xt(Ke, e3.undo.textIsRepaired), le = void 0, o2("undo", {
          item: e3,
          json: Sr(ie3),
          documentState: Sr(ve),
          selection: Sr(xe)
        }), Hn2(n3, e3.undo.patch && e3.redo.patch ? {
          json: Sr(ie3),
          previousJson: n3.json,
          redo: e3.undo.patch,
          undo: e3.redo.patch
        } : void 0), ht3(), Sr(xe) && Fn2(vd(Sr(xe)), {
          scrollToWhenVisible: false
        });
      } else V2()(e3);
    }
  }
  function Nn() {
    if (!j() && w().canRedo) {
      var e3 = w().redo();
      if (Ql(e3)) {
        var n3 = {
          json: Sr(ie3),
          text: Sr(se)
        };
        Xt(ie3, e3.redo.patch ? immutableJSONPatch(Sr(ie3), e3.redo.patch) : e3.redo.json), Xt(ve, e3.redo.documentState), Xt(xe, e3.redo.selection), Xt(se, e3.redo.text), Xt(Ke, e3.redo.textIsRepaired), le = void 0, o2("redo", {
          item: e3,
          json: Sr(ie3),
          documentState: Sr(ve),
          selection: Sr(xe)
        }), Hn2(n3, e3.undo.patch && e3.redo.patch ? {
          json: Sr(ie3),
          previousJson: n3.json,
          redo: e3.redo.patch,
          undo: e3.undo.patch
        } : void 0), ht3(), Sr(xe) && Fn2(vd(Sr(xe)), {
          scrollToWhenVisible: false
        });
      } else H2()(e3);
    }
  }
  function In(e3) {
    var n3;
    j() || void 0 === Sr(ie3) || (oe = true, ee()({
      id: s2,
      json: Sr(ie3),
      rootPath: e3,
      onSort: (n3 = i(function* (n4) {
        var {
          operations: t4
        } = n4;
        o2("onSort", e3, t4), Qn2(t4, (n5, t5) => ({
          state: Sc(n5, t5, e3),
          selection: Xc(e3)
        }));
      }), function(e4) {
        return n3.apply(this, arguments);
      }),
      onClose: () => {
        oe = false, setTimeout(ht3);
      }
    }));
  }
  function Un() {
    Sr(xe) && In(Hc(Sr(ie3), Sr(xe)));
  }
  function Dn() {
    In([]);
  }
  function Jn(e3) {
    if (void 0 !== Sr(ie3)) {
      var {
        id: n3,
        onTransform: t4,
        onClose: r2
      } = e3, a3 = e3.rootPath || [];
      oe = true, ne()({
        id: n3 || l,
        json: Sr(ie3),
        rootPath: a3,
        onTransform: (e4) => {
          t4 ? t4({
            operations: e4,
            json: Sr(ie3),
            transformedJson: immutableJSONPatch(Sr(ie3), e4)
          }) : (o2("onTransform", a3, e4), Qn2(e4, (e5, n4) => ({
            state: Sc(e5, n4, a3),
            selection: Xc(a3)
          })));
        },
        onClose: () => {
          oe = false, setTimeout(ht3), r2 && r2();
        }
      });
    }
  }
  function Bn() {
    Sr(xe) && Jn({
      rootPath: Hc(Sr(ie3), Sr(xe))
    });
  }
  function _n() {
    Jn({
      rootPath: []
    });
  }
  function Fn2(e3) {
    return Ln2.apply(this, arguments);
  }
  function Ln2() {
    return Ln2 = i(function* (e3) {
      var {
        scrollToWhenVisible: n3 = true,
        element: t4
      } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Xt(ve, ic(Sr(ie3), Sr(ve), e3, Mc));
      var r2 = null != t4 ? t4 : Wn2(e3);
      if (o2("scrollTo", {
        path: e3,
        elem: r2,
        refContents: Sr(p2)
      }), !r2 || !Sr(p2)) return Promise.resolve();
      var a3 = Sr(p2).getBoundingClientRect(), i2 = r2.getBoundingClientRect();
      if (!n3 && i2.bottom > a3.top && i2.top < a3.bottom) return Promise.resolve();
      var s3 = -a3.height / 4;
      return new Promise((e4) => {
        b(r2, {
          container: Sr(p2),
          offset: s3,
          duration: 300,
          callback: () => e4()
        });
      });
    }), Ln2.apply(this, arguments);
  }
  function Wn2(e3) {
    var n3, t4;
    return wr(), null !== (n3 = null === (t4 = Sr(p2)) || void 0 === t4 ? void 0 : t4.querySelector('div[data-path="'.concat(Rs(e3), '"]'))) && void 0 !== n3 ? n3 : void 0;
  }
  function Vn2(e3) {
    var n3, t4;
    return wr(), null !== (n3 = null === (t4 = Sr(p2)) || void 0 === t4 ? void 0 : t4.querySelector('span[data-search-result-index="'.concat(e3, '"]'))) && void 0 !== n3 ? n3 : void 0;
  }
  function $n2(e3) {
    var n3 = Wn2(e3);
    if (n3 && Sr(p2)) {
      var t4 = Sr(p2).getBoundingClientRect(), o3 = n3.getBoundingClientRect(), r2 = hi(getIn(Sr(ie3), e3)) ? 20 : o3.height;
      o3.top < t4.top + 20 ? b(n3, {
        container: Sr(p2),
        offset: -20,
        duration: 0
      }) : o3.top + r2 > t4.bottom - 20 && b(n3, {
        container: Sr(p2),
        offset: -(t4.height - r2 - 20),
        duration: 0
      });
    }
  }
  function Hn2(e3, n3) {
    if (void 0 !== e3.json || void 0 !== (null == e3 ? void 0 : e3.text)) {
      if (void 0 !== Sr(se)) {
        var t4, o3 = {
          text: Sr(se),
          json: void 0
        };
        null === (t4 = F2()) || void 0 === t4 || t4(o3, e3, {
          contentErrors: nn(),
          patchResult: n3
        });
      } else if (void 0 !== Sr(ie3)) {
        var r2, a3 = {
          text: void 0,
          json: Sr(ie3)
        };
        null === (r2 = F2()) || void 0 === r2 || r2(a3, e3, {
          contentErrors: nn(),
          patchResult: n3
        });
      }
    }
  }
  function Qn2(e3, n3) {
    o2("handlePatch", e3, n3);
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, r2 = dn(e3, n3);
    return Hn2(t4, r2), r2;
  }
  function Yn2(e3, n3) {
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, o3 = {
      documentState: Sr(ve),
      selection: Sr(xe),
      json: Sr(ie3),
      text: Sr(se),
      textIsRepaired: Sr(Ke)
    }, r2 = ic(Sr(ie3), tc(e3, Sr(ve)), [], Cc), a3 = "function" == typeof n3 ? n3(e3, r2, Sr(xe)) : void 0;
    Xt(ie3, void 0 !== (null == a3 ? void 0 : a3.json) ? a3.json : e3), Xt(ve, void 0 !== (null == a3 ? void 0 : a3.state) ? a3.state : r2), Xt(xe, void 0 !== (null == a3 ? void 0 : a3.selection) ? a3.selection : Sr(xe)), Xt(se, void 0), Xt(Ke, false), le = void 0, ln(Sr(ie3)), cn(o3);
    Hn2(t4, void 0);
  }
  function Kn2(e3, n3) {
    o2("handleChangeText");
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, r2 = {
      documentState: Sr(ve),
      selection: Sr(xe),
      json: Sr(ie3),
      text: Sr(se),
      textIsRepaired: Sr(Ke)
    };
    try {
      Xt(ie3, R()(e3)), Xt(ve, ic(Sr(ie3), tc(Sr(ie3), Sr(ve)), [], Cc)), Xt(se, void 0), Xt(Ke, false), le = void 0;
    } catch (n4) {
      try {
        Xt(ie3, R()(jsonrepair(e3))), Xt(ve, ic(Sr(ie3), tc(Sr(ie3), Sr(ve)), [], Cc)), Xt(se, e3), Xt(Ke, true), le = void 0;
      } catch (t5) {
        Xt(ie3, void 0), Xt(ve, Zl({
          json: Sr(ie3),
          expand: Cc
        })), Xt(se, e3), Xt(Ke, false), le = "" !== Sr(se) ? _i(Sr(se), n4.message || String(n4)) : void 0;
      }
    }
    if ("function" == typeof n3) {
      var a3 = n3(Sr(ie3), Sr(ve), Sr(xe));
      Xt(ie3, void 0 !== (null == a3 ? void 0 : a3.json) ? a3.json : Sr(ie3)), Xt(ve, void 0 !== (null == a3 ? void 0 : a3.state) ? a3.state : Sr(ve)), Xt(xe, void 0 !== (null == a3 ? void 0 : a3.selection) ? a3.selection : Sr(xe));
    }
    ln(Sr(ie3)), cn(r2);
    Hn2(t4, void 0);
  }
  function Zn2(e3, n3) {
    var t4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    o2("handleExpand", {
      path: e3,
      expanded: n3,
      recursive: t4
    }), n3 ? Qe(e3, t4 ? Oc : zc) : Ye(e3, t4), ht3();
  }
  function Xn2() {
    Zn2([], true, true);
  }
  function Gn2() {
    Zn2([], false, true);
  }
  function et3(e3) {
    o2("openFind", {
      findAndReplace: e3
    }), Xt(Be, false), Xt(_e, false), wr(), Xt(Be, true), Xt(_e, e3);
  }
  function nt3(e3, n3) {
    o2("handleExpandSection", e3, n3), Xt(ve, function(e4, n4, t4, o3) {
      return pc(e4, n4, t4, (e5, n5) => {
        if (!Wl(n5)) return n5;
        var t5 = Ol(n5.visibleSections.concat(o3));
        return r(r({}, n5), {}, {
          visibleSections: t5
        });
      });
    }(Sr(ie3), Sr(ve), e3, n3));
  }
  function tt3(e3) {
    o2("pasted json as text", e3), Xt(Se, e3);
  }
  function ot3(e3) {
    o2("pasted multiline text", {
      pastedText: e3
    }), Xt(De, e3);
  }
  function rt3(e3) {
    var n3, {
      anchor: t4,
      left: o3,
      top: r2,
      width: a3,
      height: i2,
      offsetTop: s3,
      offsetLeft: l2,
      showTip: c
    } = e3, f = function(e4) {
      var {
        json: n4,
        documentState: t5,
        selection: o4,
        readOnly: r3,
        onEditKey: a4,
        onEditValue: i3,
        onToggleEnforceString: s4,
        onCut: l3,
        onCopy: c2,
        onPaste: u2,
        onRemove: v2,
        onDuplicate: f2,
        onExtract: p4,
        onInsertBefore: h4,
        onInsert: g3,
        onConvert: m2,
        onInsertAfter: b2,
        onSort: j2,
        onTransform: x2
      } = e4, y2 = void 0 !== n4, w2 = !!o4, k = !!o4 && isEmpty_default(vd(o4)), S2 = o4 ? getIn(n4, vd(o4)) : void 0, C4 = Array.isArray(S2) ? "Edit array" : pi(S2) ? "Edit object" : "Edit value", z4 = y2 && (Pc(o4) || Rc(o4) || qc(o4)), O = o4 && !k ? getIn(n4, initial_default(vd(o4))) : void 0, M3 = !r3 && y2 && $c(o4) && !k && !Array.isArray(O), E2 = !r3 && y2 && void 0 !== o4 && $c(o4), A3 = E2 && !hi(S2), R2 = !r3 && z4, P = z4, T2 = !r3 && w2, N3 = !r3 && y2 && z4 && !k, U2 = !r3 && y2 && void 0 !== o4 && (Pc(o4) || qc(o4)) && !k, D3 = z4, J2 = D3 ? "Convert to:" : "Insert:", B2 = !r3 && (Ac(o4) && Array.isArray(S2) || Ec(o4) && Array.isArray(O)), _2 = !r3 && (D3 ? id(o4) && !pi(S2) : w2), F3 = !r3 && (D3 ? id(o4) && !Array.isArray(S2) : w2), L2 = !r3 && (D3 ? id(o4) && hi(S2) : w2), W3 = void 0 !== o4 && bc(n4, t5, vd(o4));
      function V3(e5) {
        z4 ? "structure" !== e5 && m2(e5) : g3(e5);
      }
      return [{
        type: "row",
        items: [{
          type: "button",
          onClick: () => a4(),
          icon: faPen,
          text: "Edit key",
          title: "Edit the key (Double-click on the key)",
          disabled: !M3
        }, {
          type: "dropdown-button",
          main: {
            type: "button",
            onClick: () => i3(),
            icon: faPen,
            text: C4,
            title: "Edit the value (Double-click on the value)",
            disabled: !E2
          },
          width: "11em",
          items: [{
            type: "button",
            icon: faPen,
            text: C4,
            title: "Edit the value (Double-click on the value)",
            onClick: () => i3(),
            disabled: !E2
          }, {
            type: "button",
            icon: W3 ? faCheckSquare2 : faSquare2,
            text: "Enforce string",
            title: "Enforce keeping the value as string when it contains a numeric value",
            onClick: () => s4(),
            disabled: !A3
          }]
        }]
      }, {
        type: "separator"
      }, {
        type: "row",
        items: [{
          type: "dropdown-button",
          main: {
            type: "button",
            onClick: () => l3(true),
            icon: faCut,
            text: "Cut",
            title: "Cut selected contents, formatted with indentation (Ctrl+X)",
            disabled: !R2
          },
          width: "10em",
          items: [{
            type: "button",
            icon: faCut,
            text: "Cut formatted",
            title: "Cut selected contents, formatted with indentation (Ctrl+X)",
            onClick: () => l3(true),
            disabled: !R2
          }, {
            type: "button",
            icon: faCut,
            text: "Cut compacted",
            title: "Cut selected contents, without indentation (Ctrl+Shift+X)",
            onClick: () => l3(false),
            disabled: !R2
          }]
        }, {
          type: "dropdown-button",
          main: {
            type: "button",
            onClick: () => c2(true),
            icon: faCopy,
            text: "Copy",
            title: "Copy selected contents, formatted with indentation (Ctrl+C)",
            disabled: !P
          },
          width: "12em",
          items: [{
            type: "button",
            icon: faCopy,
            text: "Copy formatted",
            title: "Copy selected contents, formatted with indentation (Ctrl+C)",
            onClick: () => c2(true),
            disabled: !P
          }, {
            type: "button",
            icon: faCopy,
            text: "Copy compacted",
            title: "Copy selected contents, without indentation (Ctrl+Shift+C)",
            onClick: () => c2(false),
            disabled: !P
          }]
        }, {
          type: "button",
          onClick: () => u2(),
          icon: faPaste,
          text: "Paste",
          title: "Paste clipboard contents (Ctrl+V)",
          disabled: !T2
        }]
      }, {
        type: "separator"
      }, {
        type: "row",
        items: [{
          type: "column",
          items: [{
            type: "button",
            onClick: () => f2(),
            icon: faClone,
            text: "Duplicate",
            title: "Duplicate selected contents (Ctrl+D)",
            disabled: !N3
          }, {
            type: "button",
            onClick: () => p4(),
            icon: faCropAlt,
            text: "Extract",
            title: "Extract selected contents",
            disabled: !U2
          }, {
            type: "button",
            onClick: () => j2(),
            icon: faSortAmountDownAlt,
            text: "Sort",
            title: "Sort array or object contents",
            disabled: r3 || !z4
          }, {
            type: "button",
            onClick: () => x2(),
            icon: faFilter,
            text: "Transform",
            title: "Transform array or object contents (filter, sort, project)",
            disabled: r3 || !z4
          }, {
            type: "button",
            onClick: () => v2(),
            icon: faTrashCan,
            text: "Remove",
            title: "Remove selected contents (Delete)",
            disabled: r3 || !z4
          }]
        }, {
          type: "column",
          items: [{
            type: "label",
            text: J2
          }, {
            type: "button",
            onClick: () => V3("structure"),
            icon: D3 ? faArrowRightArrowLeft : faPlus,
            text: "Structure",
            title: J2 + " structure like the first item in the array",
            disabled: !B2
          }, {
            type: "button",
            onClick: () => V3("object"),
            icon: D3 ? faArrowRightArrowLeft : faPlus,
            text: "Object",
            title: J2 + " object",
            disabled: !_2
          }, {
            type: "button",
            onClick: () => V3("array"),
            icon: D3 ? faArrowRightArrowLeft : faPlus,
            text: "Array",
            title: J2 + " array",
            disabled: !F3
          }, {
            type: "button",
            onClick: () => V3("value"),
            icon: D3 ? faArrowRightArrowLeft : faPlus,
            text: "Value",
            title: J2 + " value",
            disabled: !L2
          }]
        }]
      }, {
        type: "separator"
      }, {
        type: "row",
        items: [{
          type: "button",
          onClick: () => h4(),
          icon: faCaretSquareUp,
          text: "Insert before",
          title: "Select area before current entry to insert or paste contents",
          disabled: r3 || !z4 || k
        }, {
          type: "button",
          onClick: () => b2(),
          icon: faCaretSquareDown,
          text: "Insert after",
          title: "Select area after current entry to insert or paste contents",
          disabled: r3 || !z4 || k
        }]
      }];
    }({
      json: Sr(ie3),
      documentState: Sr(ve),
      selection: Sr(xe),
      readOnly: j(),
      onEditKey: un,
      onEditValue: vn,
      onToggleEnforceString: fn,
      onCut: hn,
      onCopy: mn,
      onPaste: xn,
      onRemove: Sn,
      onDuplicate: Cn,
      onExtract: zn,
      onInsertBefore: An,
      onInsert: Mn,
      onInsertAfter: Rn,
      onConvert: En,
      onSort: Un,
      onTransform: Bn
    }), p3 = null !== (n3 = K()(f)) && void 0 !== n3 ? n3 : f;
    if (false !== p3) {
      var h3 = {
        left: o3,
        top: r2,
        offsetTop: s3,
        offsetLeft: l2,
        width: a3,
        height: i2,
        anchor: t4,
        closeOnOuterClick: true,
        onClose: () => {
          oe = false, ht3();
        }
      };
      oe = true;
      var g2 = u(rg, {
        tip: c ? "Tip: you can open this context menu via right-click or with Ctrl+Q" : void 0,
        items: p3,
        onRequestClose: () => v(g2)
      }, h3);
    }
  }
  function at4(e3) {
    if (!rd(Sr(xe))) if (e3 && (e3.stopPropagation(), e3.preventDefault()), e3 && "contextmenu" === e3.type && e3.target !== Sr(h2)) rt3({
      left: e3.clientX,
      top: e3.clientY,
      width: Sl,
      height: kl,
      showTip: false
    });
    else {
      var n3, t4 = null === (n3 = Sr(p2)) || void 0 === n3 ? void 0 : n3.querySelector(".jse-context-menu-pointer.jse-selected");
      if (t4) rt3({
        anchor: t4,
        offsetTop: 2,
        width: Sl,
        height: kl,
        showTip: false
      });
      else {
        var o3, r2 = null === (o3 = Sr(p2)) || void 0 === o3 ? void 0 : o3.getBoundingClientRect();
        r2 && rt3({
          top: r2.top + 2,
          left: r2.left + 2,
          width: Sl,
          height: kl,
          showTip: false
        });
      }
    }
  }
  function it3(e3) {
    rt3({
      anchor: Es(e3.target, "BUTTON"),
      offsetTop: 0,
      width: Sl,
      height: kl,
      showTip: true
    });
  }
  function st3() {
    return lt4.apply(this, arguments);
  }
  function lt4() {
    return (lt4 = i(function* () {
      if (o2("apply pasted json", Sr(Se)), Sr(Se)) {
        var {
          onPasteAsJson: e3
        } = Sr(Se);
        Xt(Se, void 0), e3(), setTimeout(ht3);
      }
    })).apply(this, arguments);
  }
  function ct3() {
    return dt3.apply(this, arguments);
  }
  function dt3() {
    return (dt3 = i(function* () {
      o2("apply pasted multiline text", Sr(De)), Sr(De) && (wn(JSON.stringify(Sr(De))), setTimeout(ht3));
    })).apply(this, arguments);
  }
  function ut3() {
    o2("clear pasted json"), Xt(Se, void 0), ht3();
  }
  function vt2() {
    o2("clear pasted multiline text"), Xt(De, void 0), ht3();
  }
  function ft3() {
    L()(os.text);
  }
  function pt3(e3) {
    Xt(xe, e3), ht3(), Fn2(vd(e3));
  }
  function ht3() {
    o2("focus"), Sr(h2) && (Sr(h2).focus(), Sr(h2).select());
  }
  function gt4(e3) {
    return function(e4, n3, t4) {
      var o3 = initial_default(t4), r2 = [last_default(t4)], a3 = getIn(e4, o3), i2 = a3 ? wc(a3, n3, r2) : void 0;
      return i2 ? Xc(o3.concat(i2)) : nd(t4);
    }(Sr(ie3), Sr(ve), e3);
  }
  function mt3(e3) {
    Sr(t3) && Sr(t3).onDrag(e3);
  }
  function bt2() {
    Sr(t3) && Sr(t3).onDragEnd();
  }
  var jt2 = Kt(void 0, true);
  xo(() => Sr(xe), () => {
    var e3;
    e3 = Sr(xe), isEqual_default(e3, y()) || (o2("onSelect", e3), W2()(e3));
  }), xo(() => (Ar(M2()), Ar(E())), () => {
    Xt(ke, us({
      escapeControlCharacters: M2(),
      escapeUnicodeCharacters: E()
    }));
  }), xo(() => Sr(Be), () => {
    !function(e3) {
      Sr(p2) && e3 && 0 === Sr(p2).scrollTop && (Zt(p2, Sr(p2).style.overflowAnchor = "none"), Zt(p2, Sr(p2).scrollTop += Cl), setTimeout(() => {
        Sr(p2) && Zt(p2, Sr(p2).style.overflowAnchor = "");
      }));
    }(Sr(Be));
  }), xo(() => Ar(x()), () => {
    an(x());
  }), xo(() => Ar(y()), () => {
    !function(e3) {
      isEqual_default(Sr(xe), e3) || (o2("applyExternalSelection", {
        selection: Sr(xe),
        externalSelection: e3
      }), Nc(e3) && Xt(xe, e3));
    }(y());
  }), xo(() => (Sr(ie3), Ar(N2()), Ar(A2()), Ar(D2())), () => {
    en(Sr(ie3), N2(), A2(), D2());
  }), xo(() => (Sr(p2), bf), () => {
    Xt(t3, Sr(p2) ? bf(Sr(p2)) : void 0);
  }), xo(() => (Ar(j()), Ar(S()), Ar(A2()), Sr(ke), Ar(Q()), Ar(Z2())), () => {
    Xt(jt2, {
      mode: os.tree,
      readOnly: j(),
      truncateTextSize: S(),
      parser: A2(),
      normalization: Sr(ke),
      getJson: tn,
      getDocumentState: on,
      getSelection: rn,
      findElement: Wn2,
      findNextInside: gt4,
      focus: ht3,
      onPatch: Qn2,
      onInsert: On,
      onExpand: Zn2,
      onSelect: ye,
      onFind: et3,
      onExpandSection: nt3,
      onPasteJson: tt3,
      onRenderValue: Q(),
      onContextMenu: rt3,
      onClassName: Z2() || (() => {
      }),
      onDrag: mt3,
      onDragEnd: bt2
    });
  }), xo(() => Sr(jt2), () => {
    o2("context changed", Sr(jt2));
  }), yo(), Ka(true);
  var xt2 = qg();
  Dr("mousedown", oo, function(e3) {
    !Cs(e3.target, (e4) => e4 === Sr(g)) && rd(Sr(xe)) && (o2("click outside the editor, exit edit mode"), Xt(xe, Yc(Sr(xe))), m && Sr(h2) && (Sr(h2).focus(), Sr(h2).blur()), o2("blur (outside editor)"), Sr(h2) && Sr(h2).blur());
  });
  var yt2, wt2 = vo(xt2), kt2 = uo(wt2), St2 = (e3) => {
    !function(e4, n3) {
      Tt(n3, false);
      var t4 = Kt(void 0, true), o3 = Kt(void 0, true), r2 = Kt(void 0, true), a3 = ai(n3, "json", 9), i2 = ai(n3, "selection", 9), s3 = ai(n3, "readOnly", 9), l2 = ai(n3, "showSearch", 13, false), c = ai(n3, "history", 9), d = ai(n3, "onExpandAll", 9), u2 = ai(n3, "onCollapseAll", 9), v2 = ai(n3, "onUndo", 9), f = ai(n3, "onRedo", 9), p3 = ai(n3, "onSort", 9), h3 = ai(n3, "onTransform", 9), g2 = ai(n3, "onContextMenu", 9), m2 = ai(n3, "onCopy", 9), b2 = ai(n3, "onRenderMenu", 9);
      function j2() {
        l2(!l2());
      }
      var x2 = Kt(void 0, true), y2 = Kt(void 0, true), w2 = Kt(void 0, true), k = Kt(void 0, true);
      xo(() => Ar(a3()), () => {
        Xt(t4, void 0 !== a3());
      }), xo(() => (Sr(t4), Ar(i2()), qc), () => {
        Xt(o3, Sr(t4) && (Pc(i2()) || Rc(i2()) || qc(i2())));
      }), xo(() => (Ar(d()), Ar(a3())), () => {
        Xt(x2, {
          type: "button",
          icon: Lp,
          title: "Expand all",
          className: "jse-expand-all",
          onClick: d(),
          disabled: !hi(a3())
        });
      }), xo(() => (Ar(u2()), Ar(a3())), () => {
        Xt(y2, {
          type: "button",
          icon: Wp,
          title: "Collapse all",
          className: "jse-collapse-all",
          onClick: u2(),
          disabled: !hi(a3())
        });
      }), xo(() => Ar(a3()), () => {
        Xt(w2, {
          type: "button",
          icon: faSearch,
          title: "Search (Ctrl+F)",
          className: "jse-search",
          onClick: j2,
          disabled: void 0 === a3()
        });
      }), xo(() => (Ar(s3()), Sr(x2), Sr(y2), Ar(p3()), Ar(a3()), Ar(h3()), Sr(w2), Ar(g2()), Ar(v2()), Ar(c()), Ar(f()), Ar(m2()), Sr(o3)), () => {
        Xt(k, s3() ? [Sr(x2), Sr(y2), {
          type: "separator"
        }, {
          type: "button",
          icon: faCopy,
          title: "Copy (Ctrl+C)",
          className: "jse-copy",
          onClick: m2(),
          disabled: !Sr(o3)
        }, {
          type: "separator"
        }, Sr(w2), {
          type: "space"
        }] : [Sr(x2), Sr(y2), {
          type: "separator"
        }, {
          type: "button",
          icon: faSortAmountDownAlt,
          title: "Sort",
          className: "jse-sort",
          onClick: p3(),
          disabled: s3() || void 0 === a3()
        }, {
          type: "button",
          icon: faFilter,
          title: "Transform contents (filter, sort, project)",
          className: "jse-transform",
          onClick: h3(),
          disabled: s3() || void 0 === a3()
        }, Sr(w2), {
          type: "button",
          icon: faEllipsisV,
          title: ml,
          className: "jse-contextmenu",
          onClick: g2()
        }, {
          type: "separator"
        }, {
          type: "button",
          icon: faUndo,
          title: "Undo (Ctrl+Z)",
          className: "jse-undo",
          onClick: v2(),
          disabled: !c().canUndo
        }, {
          type: "button",
          icon: faRedo,
          title: "Redo (Ctrl+Shift+Z)",
          className: "jse-redo",
          onClick: f(),
          disabled: !c().canRedo
        }, {
          type: "space"
        }]);
      }), xo(() => (Ar(b2()), Sr(k)), () => {
        Xt(r2, b2()(Sr(k)) || Sr(k));
      }), yo(), Ka(true), Qf(e4, {
        get items() {
          return Sr(r2);
        }
      }), Nt();
    }(e3, {
      get json() {
        return Sr(ie3);
      },
      get selection() {
        return Sr(xe);
      },
      get readOnly() {
        return j();
      },
      get history() {
        return w();
      },
      onExpandAll: Xn2,
      onCollapseAll: Gn2,
      onUndo: Tn,
      onRedo: Nn,
      onSort: Dn,
      onTransform: _n,
      onContextMenu: it3,
      onCopy: mn,
      get onRenderMenu() {
        return Y2();
      },
      get showSearch() {
        return Sr(Be);
      },
      set showSearch(e4) {
        Xt(Be, e4);
      },
      $$legacy: true
    });
  };
  sa(kt2, (e3) => {
    C3() && e3(St2);
  });
  var Ct2 = fo(kt2, 2), zt2 = (e3) => {
    ph(e3, {
      get json() {
        return Sr(ie3);
      },
      get selection() {
        return Sr(xe);
      },
      onSelect: pt3,
      get onError() {
        return _();
      },
      get pathParser() {
        return J();
      }
    });
  };
  sa(Ct2, (e3) => {
    z3() && e3(zt2);
  });
  var Ot2 = fo(Ct2, 2), Mt2 = (e3) => {
    var n3 = Ag(), t4 = vo(n3), o3 = uo(t4);
    o3.readOnly = true, Ha(o3, (e4) => Xt(h2, e4), () => Sr(h2));
    var r2 = fo(t4, 2), a3 = (e4) => {
      var n4 = $r(), t5 = vo(n4), o4 = (e5) => {
        !function(e6, n5) {
          Tt(n5, true);
          var t6 = Zp();
          t6.__click = [Yp, n5];
          var o5 = fo(uo(t6), 2), r4 = fo(uo(o5), 2), a4 = (e7) => {
            var t7 = Kp(), o6 = fo(vo(t7), 2);
            Ia(o6, "title", "Create an empty JSON object (press '{')"), o6.__click = [Hp, n5];
            var r5 = fo(o6, 2);
            Ia(r5, "title", "Create an empty JSON array (press '[')"), r5.__click = [Qp, n5], Hr(e7, t7);
          };
          sa(r4, (e7) => {
            n5.readOnly || e7(a4);
          }), Hr(e6, t6), Nt();
        }(e5, {
          get readOnly() {
            return j();
          },
          onCreateObject: () => {
            ht3(), qn("{");
          },
          onCreateArray: () => {
            ht3(), qn("[");
          },
          onClick: () => {
            ht3();
          }
        });
      }, r3 = (e5) => {
        var n5 = Og(), t6 = vo(n5), o5 = Lt(() => j() ? [] : [{
          icon: faCode,
          text: "Repair manually",
          title: 'Open the document in "code" mode and repair it manually',
          onClick: ft3
        }]);
        Rf(t6, {
          type: "error",
          message: "The loaded JSON document is invalid and could not be repaired automatically.",
          get actions() {
            return Sr(o5);
          }
        }), Lh(fo(t6, 2), {
          get text() {
            return Sr(se);
          },
          get json() {
            return Sr(ie3);
          },
          get indentation() {
            return B();
          },
          get parser() {
            return A2();
          }
        }), Hr(e5, n5);
      };
      sa(t5, (e5) => {
        "" === Sr(se) || void 0 === Sr(se) ? e5(o4) : e5(r3, false);
      }), Hr(e4, n4);
    }, i2 = (e4) => {
      var n4 = Eg(), t5 = vo(n4);
      bh(uo(t5), {
        get json() {
          return Sr(ie3);
        },
        get documentState() {
          return Sr(ve);
        },
        get parser() {
          return A2();
        },
        get showSearch() {
          return Sr(Be);
        },
        get showReplace() {
          return Sr(_e);
        },
        get readOnly() {
          return j();
        },
        columns: void 0,
        onSearch: Fe2,
        onFocus: We2,
        onPatch: Qn2,
        onClose: $e
      });
      var o4 = fo(t5, 2);
      Ia(o4, "data-jsoneditor-scrollable-contents", true);
      var r3 = uo(o4), a4 = (e5) => {
        Hr(e5, Mg());
      };
      sa(r3, (e5) => {
        Sr(Be) && e5(a4);
      }), Fp(fo(r3, 2), {
        get value() {
          return Sr(ie3);
        },
        pointer: "",
        get state() {
          return Sr(ve);
        },
        get validationErrors() {
          return Sr(Xe);
        },
        get searchResults() {
          return Sr(Je);
        },
        get selection() {
          return Sr(xe);
        },
        get context() {
          return Sr(jt2);
        },
        get onDragSelectionStart() {
          return noop_default;
        }
      }), Ha(o4, (e5) => Xt(p2, e5), () => Sr(p2));
      var i3 = fo(o4, 2), s3 = (e5) => {
        var n5 = Lt(() => (Sr(Se), Or(() => "You pasted a JSON ".concat(Array.isArray(Sr(Se).contents) ? "array" : "object", " as text")))), t6 = Lt(() => [{
          icon: faWrench,
          text: "Paste as JSON instead",
          title: "Replace the value with the pasted JSON",
          onMouseDown: st3
        }, {
          text: "Leave as is",
          title: "Keep the JSON embedded in the value",
          onClick: ut3
        }]);
        Rf(e5, {
          type: "info",
          get message() {
            return Sr(n5);
          },
          get actions() {
            return Sr(t6);
          }
        });
      };
      sa(i3, (e5) => {
        Sr(Se) && e5(s3);
      });
      var l2 = fo(i3, 2), c = (e5) => {
        var n5 = Lt(() => [{
          icon: faWrench,
          text: "Paste as string instead",
          title: "Paste the clipboard data as a single string value instead of an array",
          onClick: ct3
        }, {
          text: "Leave as is",
          title: "Keep the pasted array",
          onClick: vt2
        }]);
        Rf(e5, {
          type: "info",
          message: "Multiline text was pasted as array",
          get actions() {
            return Sr(n5);
          }
        });
      };
      sa(l2, (e5) => {
        Sr(De) && e5(c);
      });
      var d = fo(l2, 2), u2 = (e5) => {
        var n5 = Lt(() => j() ? [] : [{
          icon: faCheck,
          text: "Ok",
          title: "Accept the repaired document",
          onClick: pn
        }, {
          icon: faCode,
          text: "Repair manually instead",
          title: "Leave the document unchanged and repair it manually instead",
          onClick: ft3
        }]);
        Rf(e5, {
          type: "success",
          message: "The loaded JSON document was invalid but is successfully repaired.",
          get actions() {
            return Sr(n5);
          },
          onClose: ht3
        });
      };
      sa(d, (e5) => {
        Sr(Ke) && e5(u2);
      }), Df(fo(d, 2), {
        get validationErrors() {
          return Sr(Ze);
        },
        selectError: He
      }), Hr(e4, n4);
    };
    sa(r2, (e4) => {
      void 0 === Sr(ie3) ? e4(a3) : e4(i2, false);
    }), Dr("paste", o3, jn), Hr(e3, n3);
  }, Et2 = (e3) => {
    Hr(e3, Rg());
  };
  sa(Ot2, (e3) => {
    a2 ? e3(Et2, false) : e3(Mt2);
  }), Ha(wt2, (e3) => Xt(g, e3), () => Sr(g));
  var At2 = fo(wt2, 2), Rt2 = (e3) => {
    Lf(e3, {
      onClose: () => Xt(re, false)
    });
  };
  sa(At2, (e3) => {
    Sr(re) && e3(Rt2);
  });
  var qt2 = fo(At2, 2), It2 = (e3) => {
    Xf(e3, ri(() => Sr(ae), {
      onClose: () => {
        var e4;
        null === (e4 = Sr(ae)) || void 0 === e4 || e4.onClose(), Xt(ae, void 0);
      }
    }));
  };
  return sa(qt2, (e3) => {
    Sr(ae) && e3(It2);
  }), ko((e3) => yt2 = Ca(wt2, 1, "jse-tree-mode svelte-vrx1dr", null, yt2, e3), [() => ({
    "no-main-menu": !C3()
  })], Lt), Dr("keydown", wt2, function(e3) {
    var n3 = Ns(e3), t4 = e3.shiftKey;
    if (o2("keydown", {
      combo: n3,
      key: e3.key
    }), "Ctrl+X" === n3 && (e3.preventDefault(), hn(true)), "Ctrl+Shift+X" === n3 && (e3.preventDefault(), hn(false)), "Ctrl+C" === n3 && (e3.preventDefault(), mn(true)), "Ctrl+Shift+C" === n3 && (e3.preventDefault(), mn(false)), "Ctrl+D" === n3 && (e3.preventDefault(), Cn()), "Delete" !== n3 && "Backspace" !== n3 || (e3.preventDefault(), Sn()), "Insert" === n3 && (e3.preventDefault(), On("structure")), "Ctrl+A" === n3 && (e3.preventDefault(), Xt(xe, Xc([]))), "Ctrl+Q" === n3 && at4(e3), "ArrowUp" === n3 || "Shift+ArrowUp" === n3) {
      e3.preventDefault();
      var a3 = Sr(xe) ? _c(Sr(ie3), Sr(ve), Sr(xe), t4) || Sr(xe) : Lc(Sr(ie3), Sr(ve));
      Xt(xe, a3), $n2(vd(a3));
    }
    if ("ArrowDown" === n3 || "Shift+ArrowDown" === n3) {
      e3.preventDefault();
      var i2 = Sr(xe) ? function(e4, n4, t5) {
        var o3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        if (t5) {
          var r2 = o3 ? vd(t5) : Bc(e4, t5), a4 = hi(getIn(e4, r2)) ? sc(e4, n4, r2, true) : n4, i3 = wc(e4, n4, r2), s4 = wc(e4, a4, r2);
          if (o3) return Ac(t5) ? void 0 !== i3 ? td(i3, i3) : void 0 : Ec(t5) ? void 0 !== s4 ? td(s4, s4) : void 0 : void 0 !== s4 ? td(fd(t5), s4) : void 0;
          if (Ec(t5)) return void 0 !== s4 ? Xc(s4) : void 0;
          if (Ac(t5)) return void 0 !== i3 ? Xc(i3) : void 0;
          if (qc(t5)) return void 0 !== i3 ? Xc(i3) : void 0;
          if (Rc(t5)) {
            if (void 0 === i3 || 0 === i3.length) return;
            var l3 = initial_default(i3), c2 = getIn(e4, l3);
            return Array.isArray(c2) ? Xc(i3) : Kc(i3);
          }
          return Pc(t5) ? void 0 !== s4 ? Xc(s4) : void 0 !== i3 ? Xc(i3) : void 0 : void 0;
        }
      }(Sr(ie3), Sr(ve), Sr(xe), t4) || Sr(xe) : Lc(Sr(ie3), Sr(ve));
      Xt(xe, i2), $n2(vd(i2));
    }
    if ("ArrowLeft" === n3 || "Shift+ArrowLeft" === n3) {
      e3.preventDefault();
      var s3 = Sr(xe) ? function(e4, n4, t5) {
        var o3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (t5) {
          var {
            caret: a4,
            previous: i3
          } = Fc(e4, n4, t5, r2);
          if (o3) return Pc(t5) ? void 0 : td(t5.path, t5.path);
          if (a4 && i3) return sd(i3);
          var s4 = initial_default(vd(t5)), l3 = getIn(e4, s4);
          return qc(t5) && Array.isArray(l3) ? td(t5.path, t5.path) : Pc(t5) && !Array.isArray(l3) ? Kc(t5.focusPath) : void 0;
        }
      }(Sr(ie3), Sr(ve), Sr(xe), t4, !j()) || Sr(xe) : Lc(Sr(ie3), Sr(ve));
      Xt(xe, s3), $n2(vd(s3));
    }
    if ("ArrowRight" === n3 || "Shift+ArrowRight" === n3) {
      e3.preventDefault();
      var l2 = Sr(xe) && void 0 !== Sr(ie3) ? function(e4, n4, t5) {
        var o3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (t5) {
          var {
            caret: a4,
            next: i3
          } = Fc(e4, n4, t5, r2);
          return o3 ? Pc(t5) ? void 0 : td(t5.path, t5.path) : a4 && i3 ? sd(i3) : Pc(t5) ? Xc(t5.focusPath) : void 0;
        }
      }(Sr(ie3), Sr(ve), Sr(xe), t4, !j()) || Sr(xe) : Lc(Sr(ie3), Sr(ve));
      Xt(xe, l2), $n2(vd(l2));
    }
    if ("Enter" === n3 && Sr(xe)) {
      if (Tc(Sr(xe))) {
        var c = Sr(xe).focusPath, u2 = getIn(Sr(ie3), initial_default(c));
        Array.isArray(u2) && (e3.preventDefault(), Xt(xe, Xc(c)));
      }
      if (Rc(Sr(xe)) && (e3.preventDefault(), Xt(xe, r(r({}, Sr(xe)), {}, {
        edit: true
      }))), qc(Sr(xe))) e3.preventDefault(), hi(getIn(Sr(ie3), Sr(xe).path)) ? Zn2(Sr(xe).path, true) : Xt(xe, r(r({}, Sr(xe)), {}, {
        edit: true
      }));
    }
    if (1 === n3.replace(/^Shift\+/, "").length && Sr(xe)) return e3.preventDefault(), void qn(e3.key);
    if ("Enter" === n3 && (Ec(Sr(xe)) || Ac(Sr(xe)))) return e3.preventDefault(), void qn("");
    if ("Ctrl+Enter" === n3 && qc(Sr(xe))) {
      var v2 = getIn(Sr(ie3), Sr(xe).path);
      ki(v2) && window.open(String(v2), "_blank");
    }
    "Escape" === n3 && Sr(xe) && (e3.preventDefault(), Xt(xe, void 0)), "Ctrl+F" === n3 && (e3.preventDefault(), et3(false)), "Ctrl+H" === n3 && (e3.preventDefault(), et3(true)), "Ctrl+Z" === n3 && (e3.preventDefault(), Tn()), "Ctrl+Shift+Z" === n3 && (e3.preventDefault(), Nn());
  }), Dr("mousedown", wt2, function(e3) {
    o2("handleMouseDown", e3);
    var n3 = e3.target;
    ks(n3, "BUTTON") || n3.isContentEditable || (ht3(), Sr(xe) || void 0 !== Sr(ie3) || "" !== Sr(se) && void 0 !== Sr(se) || (o2("createDefaultSelection"), Xt(xe, Xc([]))));
  }), Dr("contextmenu", wt2, at4), Hr(e2, xt2), Va(n2, "expand", Qe), Va(n2, "collapse", Ye), Va(n2, "validate", nn), Va(n2, "getJson", tn), Va(n2, "patch", dn), Va(n2, "acceptAutoRepair", pn), Va(n2, "openTransformModal", Jn), Va(n2, "scrollTo", Fn2), Va(n2, "findElement", Wn2), Va(n2, "findSearchResult", Vn2), Va(n2, "focus", ht3), Nt({
    expand: Qe,
    collapse: Ye,
    validate: nn,
    getJson: tn,
    patch: dn,
    acceptAutoRepair: pn,
    openTransformModal: Jn,
    scrollTo: Fn2,
    findElement: Wn2,
    findSearchResult: Vn2,
    focus: ht3
  });
}
function Tg(e2) {
  return "object" != typeof (n2 = e2) || null === n2 ? e2 : new Proxy(e2, {
    get: (e3, n3, t3) => Tg(Reflect.get(e3, n3, t3)),
    set: () => false,
    deleteProperty: () => false
  });
  var n2;
}
var Ng = ii("jsoneditor:History");
function Ig() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = e2.maxItems || 1e3, t3 = [], o2 = 0;
  function r2() {
    return o2 < t3.length;
  }
  function a2() {
    return o2 > 0;
  }
  function i2() {
    return {
      canUndo: r2(),
      canRedo: a2(),
      items: () => t3.slice().reverse(),
      add: l,
      undo: d,
      redo: u,
      clear: c
    };
  }
  function s2() {
    e2.onChange && e2.onChange(i2());
  }
  function l(e3) {
    Ng("add", e3), t3 = [e3].concat(t3.slice(o2)).slice(0, n2), o2 = 0, s2();
  }
  function c() {
    Ng("clear"), t3 = [], o2 = 0, s2();
  }
  function d() {
    if (r2()) {
      var e3 = t3[o2];
      return o2 += 1, Ng("undo", e3), s2(), e3;
    }
  }
  function u() {
    if (a2()) return Ng("redo", t3[o2 -= 1]), s2(), t3[o2];
  }
  return {
    get: i2
  };
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-transform-modal-inner.svelte-rrrjnb {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-width: 0;\n  min-height: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) {\n  color: inherit;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: 0;\n  overflow: auto;\n  min-width: 0;\n  min-height: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-actions:where(.svelte-rrrjnb) {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  padding-top: var(--jse-padding, 10px);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-actions:where(.svelte-rrrjnb) button.jse-primary:where(.svelte-rrrjnb) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-actions:where(.svelte-rrrjnb) button.jse-primary:where(.svelte-rrrjnb):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-actions:where(.svelte-rrrjnb) button.jse-primary:where(.svelte-rrrjnb):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) {\n  flex: 1;\n  display: flex;\n  gap: calc(2 * var(--jse-padding, 10px));\n  min-height: 0;\n  box-sizing: border-box;\n  padding: 0 calc(2 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) .jse-description:where(.svelte-rrrjnb) p {\n  margin: var(--jse-padding, 10px) 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) .jse-description:where(.svelte-rrrjnb) p:first-child {\n  margin-top: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) .jse-description:where(.svelte-rrrjnb) p:last-child {\n  margin-bottom: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) .jse-description:where(.svelte-rrrjnb) code {\n  background: var(--jse-modal-code-background, rgba(0, 0, 0, 0.05));\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) .query-error:where(.svelte-rrrjnb) {\n  color: var(--jse-error-color, #ee5341);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) textarea.jse-query:where(.svelte-rrrjnb) {\n  flex: 1;\n  outline: none;\n  resize: vertical;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents:where(.svelte-rrrjnb) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: calc(2 * var(--jse-padding, 10px));\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents:where(.svelte-rrrjnb) .jse-original-data:where(.svelte-rrrjnb) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  box-sizing: border-box;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents:where(.svelte-rrrjnb) .jse-original-data.jse-hide:where(.svelte-rrrjnb) {\n  flex: none;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents:where(.svelte-rrrjnb) .jse-preview-data:where(.svelte-rrrjnb) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  box-sizing: border-box;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents.jse-hide-original-data:where(.svelte-rrrjnb) {\n  flex-direction: column;\n  gap: 0;\n  margin-bottom: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-actions:where(.svelte-rrrjnb) {\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px)) calc(2 * var(--jse-padding, 10px));\n}\n@media screen and (max-width: 1200px) {\n  .jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) {\n    flex-direction: column;\n    overflow: auto;\n  }\n  .jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-query-contents:where(.svelte-rrrjnb) textarea.jse-query:where(.svelte-rrrjnb) {\n    min-height: 150px;\n    flex: none;\n  }\n  .jse-transform-modal-inner.svelte-rrrjnb .jse-modal-contents:where(.svelte-rrrjnb) .jse-main-contents:where(.svelte-rrrjnb) .jse-data-contents:where(.svelte-rrrjnb) .jse-tree-mode {\n    height: 300px;\n    flex: none;\n  }\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-label:where(.svelte-rrrjnb) {\n  font-weight: bold;\n  display: block;\n  box-sizing: border-box;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-label:where(.svelte-rrrjnb) .jse-label-inner:where(.svelte-rrrjnb) {\n  margin-top: calc(2 * var(--jse-padding, 10px));\n  margin-bottom: calc(0.5 * var(--jse-padding, 10px));\n  box-sizing: border-box;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-label:where(.svelte-rrrjnb) .jse-label-inner:where(.svelte-rrrjnb) button:where(.svelte-rrrjnb) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  font-weight: bold;\n  padding: 0;\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-tree-mode {\n  flex: 1;\n  background: var(--jse-input-background-readonly, transparent);\n  box-shadow: none;\n  box-sizing: border-box;\n  --jse-main-border: var(--jse-input-border, 1px solid #d8dbdf);\n}\n.jse-transform-modal-inner.svelte-rrrjnb input:where(.svelte-rrrjnb),\n.jse-transform-modal-inner.svelte-rrrjnb textarea:where(.svelte-rrrjnb) {\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  outline: none;\n  box-sizing: border-box;\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: inherit;\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n}\n.jse-transform-modal-inner.svelte-rrrjnb input:where(.svelte-rrrjnb):focus,\n.jse-transform-modal-inner.svelte-rrrjnb textarea:where(.svelte-rrrjnb):focus {\n  border: var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)));\n}\n.jse-transform-modal-inner.svelte-rrrjnb input:where(.svelte-rrrjnb):read-only,\n.jse-transform-modal-inner.svelte-rrrjnb textarea:where(.svelte-rrrjnb):read-only {\n  background: var(--jse-input-background-readonly, transparent);\n}\n.jse-transform-modal-inner.svelte-rrrjnb .jse-preview.jse-error:where(.svelte-rrrjnb) {\n  flex: 1;\n  background: var(--jse-input-background-readonly, transparent);\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  color: var(--jse-error-color, #ee5341);\n  padding: calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-transform-modal-inner.svelte-rrrjnb a {\n  color: var(--jse-a-color, #156fc5);\n}\n.jse-transform-modal-inner.svelte-rrrjnb a:hover {\n  color: var(--jse-a-color-highlight, #0f508d);\n}');
var Ug = Xa(() => vu);
var Dg = Xa(() => fu);
var Jg = Lr('<div class="query-error svelte-rrrjnb"> </div>');
var Bg = Lr("<!> <!>", 1);
var _g = Lr('<div class="jse-preview jse-error svelte-rrrjnb"> </div>');
var Fg = Lr('<!> <div class="jse-modal-contents svelte-rrrjnb"><div class="jse-main-contents svelte-rrrjnb"><div class="jse-query-contents svelte-rrrjnb"><div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb">Language</div></div> <div class="jse-description svelte-rrrjnb"><!></div> <div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb">Path</div></div> <input class="jse-path svelte-rrrjnb" type="text" readonly="" title="Selected path"/> <div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb"><button type="button" class="svelte-rrrjnb"><!> Wizard</button></div></div> <!> <div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb">Query</div></div> <textarea class="jse-query svelte-rrrjnb" spellcheck="false"></textarea></div> <div><div><div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb"><button type="button" class="svelte-rrrjnb"><!> Original</button></div></div> <!></div> <div class="jse-preview-data svelte-rrrjnb"><div class="jse-label svelte-rrrjnb"><div class="jse-label-inner svelte-rrrjnb">Preview</div></div> <!></div></div></div> <div class="jse-actions svelte-rrrjnb"><button type="button" class="jse-primary svelte-rrrjnb">Transform</button></div></div>', 1);
var Lg = Lr('<div class="jse-transform-modal-inner svelte-rrrjnb"><!></div>');
function Wg(e2, n2) {
  var t3, o2, r2;
  Tt(n2, false);
  var a2 = ii("jsoneditor:TransformModal"), i2 = ai(n2, "id", 25, () => "transform-modal-" + di()), s2 = ai(n2, "json", 9), l = ai(n2, "rootPath", 25, () => []), u = ai(n2, "indentation", 9), v = ai(n2, "truncateTextSize", 9), f = ai(n2, "escapeControlCharacters", 9), p2 = ai(n2, "escapeUnicodeCharacters", 9), h2 = ai(n2, "parser", 9), g = ai(n2, "parseMemoizeOne", 9), m = ai(n2, "validationParser", 9), b = ai(n2, "pathParser", 9), j = ai(n2, "queryLanguages", 9), x = ai(n2, "queryLanguageId", 13), y = ai(n2, "onChangeQueryLanguage", 9), w = ai(n2, "onRenderValue", 9), k = ai(n2, "onRenderMenu", 9), S = ai(n2, "onRenderContextMenu", 9), C3 = ai(n2, "onClassName", 9), z3 = ai(n2, "onTransform", 9), O = ai(n2, "onClose", 9), M2 = Kt(void 0, true), E = Kt(Ig({
    onChange: (e3) => Xt(E, e3)
  }).get(), true), A2 = Kt(void 0, true), R = Kt(void 0, true), q2 = Kt(false, true), P = "".concat(i2(), ":").concat(compileJSONPointer(l())), T2 = null !== (t3 = Ug()[P]) && void 0 !== t3 ? t3 : {}, N2 = Kt(false !== Dg().showWizard, true), D2 = Kt(false !== Dg().showOriginal, true), J = Kt(null !== (o2 = T2.queryOptions) && void 0 !== o2 ? o2 : {}, true), B = Kt(x() === T2.queryLanguageId && T2.query ? T2.query : "", true), _ = Kt(null !== (r2 = T2.isManual) && void 0 !== r2 && r2, true), L = Kt(void 0, true), W2 = Kt(void 0, true), V2 = Kt({
    text: ""
  }, true);
  function $(e3) {
    var n3;
    return null !== (n3 = j().find((n4) => n4.id === e3)) && void 0 !== n3 ? n3 : j()[0];
  }
  function H2(e3) {
    try {
      Xt(J, e3), Xt(B, $(x()).createQuery(Sr(A2), e3)), Xt(L, void 0), Xt(_, false), a2("updateQueryByWizard", {
        queryOptions: Sr(J),
        query: Sr(B),
        isManual: Sr(_)
      });
    } catch (e4) {
      Xt(L, String(e4));
    }
  }
  function Q(e3) {
    Xt(B, e3.target.value), Xt(_, true), a2("handleChangeQuery", {
      query: Sr(B),
      isManual: Sr(_)
    });
  }
  Sr(_) || H2(Sr(J)), ta(() => {
    var e3;
    null === (e3 = Sr(M2)) || void 0 === e3 || e3.focus();
  });
  var Y2 = debounce_default(function(e3, n3) {
    if (void 0 === e3) return Xt(V2, {
      text: ""
    }), void Xt(W2, "Error: No JSON");
    if ("" !== n3.trim()) try {
      a2("previewTransform", {
        query: n3
      });
      var t4 = $(x()).executeQuery(e3, n3, h2());
      Xt(V2, {
        json: t4
      }), Xt(W2, void 0);
    } catch (e4) {
      Xt(V2, {
        text: ""
      }), Xt(W2, String(e4));
    }
    else Xt(V2, {
      json: e3
    });
  }, 300);
  function K() {
    if (void 0 === Sr(A2)) return Xt(V2, {
      text: ""
    }), void Xt(W2, "Error: No JSON");
    try {
      a2("handleTransform", {
        query: Sr(B)
      });
      var e3 = $(x()).executeQuery(Sr(A2), Sr(B), h2());
      z3()([{
        op: "replace",
        path: compileJSONPointer(l()),
        value: e3
      }]), O()();
    } catch (e4) {
      console.error(e4), Xt(V2, {
        text: ""
      }), Xt(W2, String(e4));
    }
  }
  function Z2() {
    Xt(N2, !Sr(N2)), Dg(Dg().showWizard = Sr(N2));
  }
  function X2() {
    Xt(D2, !Sr(D2)), Dg(Dg().showOriginal = Sr(D2));
  }
  function G2(e3) {
    e3.focus();
  }
  function ee(e3) {
    a2("handleChangeQueryLanguage", e3), x(e3), y()(e3), H2(Sr(J));
  }
  function ne() {
    Sr(q2) ? Xt(q2, !Sr(q2)) : O()();
  }
  xo(() => (Ar(s2()), Ar(l())), () => {
    Xt(A2, Tg(getIn(s2(), l())));
  }), xo(() => Sr(A2), () => {
    Xt(R, Sr(A2) ? {
      json: Sr(A2)
    } : {
      text: ""
    });
  }), xo(() => (Sr(A2), Sr(B)), () => {
    Y2(Sr(A2), Sr(B));
  }), xo(() => (Ug(), Sr(J), Sr(B), Ar(x()), Sr(_)), () => {
    Ug(Ug()[P] = {
      queryOptions: Sr(J),
      query: Sr(B),
      queryLanguageId: x(),
      isManual: Sr(_)
    }), a2("store state in memory", P, Ug()[P]);
  }), yo(), Ka(true), _f(e2, {
    get onClose() {
      return O();
    },
    className: "jse-transform-modal",
    get fullscreen() {
      return Sr(q2);
    },
    children: (e3, n3) => {
      var t4 = Lg();
      Ls(uo(t4), {
        children: (e4, n4) => {
          var t5 = Fg(), o3 = vo(t5);
          !function(e5, n5) {
            Tt(n5, false);
            var t6, o4 = ai(n5, "queryLanguages", 9), r4 = ai(n5, "queryLanguageId", 9), a4 = ai(n5, "fullscreen", 13), i4 = ai(n5, "onChangeQueryLanguage", 9), s4 = ai(n5, "onClose", 9), l2 = Kt(void 0, true), {
              openAbsolutePopup: c2,
              closeAbsolutePopup: d2
            } = Pt("absolute-popup");
            function u2() {
              var e6 = {
                queryLanguages: o4(),
                queryLanguageId: r4(),
                onChangeQueryLanguage: (e7) => {
                  d2(t6), i4()(e7);
                }
              };
              t6 = c2(vf, e6, {
                offsetTop: -2,
                offsetLeft: 0,
                anchor: Sr(l2),
                closeOnOuterClick: true
              });
            }
            Ka(true), hf(e5, {
              title: "Transform",
              fullScreenButton: true,
              get onClose() {
                return s4();
              },
              get fullscreen() {
                return a4();
              },
              set fullscreen(e6) {
                a4(e6);
              },
              $$slots: {
                actions: (e6, n6) => {
                  var t7, r5 = gf();
                  nl(uo(r5), {
                    get data() {
                      return faCog;
                    }
                  }), Ha(r5, (e7) => Xt(l2, e7), () => Sr(l2)), ko((e7) => t7 = Ca(r5, 1, "jse-config svelte-1kpylsp", null, t7, e7), [() => ({
                    hide: o4().length <= 1
                  })], Lt), Dr("click", r5, u2), Hr(e6, r5);
                }
              },
              $$legacy: true
            }), Nt();
          }(o3, {
            get queryLanguages() {
              return j();
            },
            get queryLanguageId() {
              return x();
            },
            onChangeQueryLanguage: ee,
            get onClose() {
              return O();
            },
            get fullscreen() {
              return Sr(q2);
            },
            set fullscreen(e5) {
              Xt(q2, e5);
            },
            $$legacy: true
          });
          var r3 = uo(fo(o3, 2)), a3 = uo(r3), i3 = fo(uo(a3), 2);
          ha(uo(i3), () => (Ar(x()), Or(() => $(x()).description)));
          var s3 = fo(i3, 4), c = fo(s3, 2), d = uo(c), y2 = uo(d), z4 = uo(y2), P2 = Lt(() => Sr(N2) ? faCaretDown : faCaretRight);
          nl(z4, {
            get data() {
              return Sr(P2);
            }
          });
          var T3 = fo(c, 2), _2 = (e5) => {
            var n5 = $r(), t6 = vo(n5), o4 = (e6) => {
              var n6 = Bg(), t7 = vo(n6);
              cf(t7, {
                get queryOptions() {
                  return Sr(J);
                },
                get json() {
                  return Sr(A2);
                },
                onChange: H2
              });
              var o5 = fo(t7, 2), r5 = (e7) => {
                var n7 = Jg(), t8 = uo(n7);
                ko(() => Xr(t8, Sr(L))), Hr(e7, n7);
              };
              sa(o5, (e7) => {
                Sr(L) && e7(r5);
              }), Hr(e6, n6);
            }, r4 = (e6) => {
              Hr(e6, Vr("(Only available for arrays, not for objects)"));
            };
            sa(t6, (e6) => {
              Sr(A2), Or(() => Array.isArray(Sr(A2))) ? e6(o4) : e6(r4, false);
            }), Hr(e5, n5);
          };
          sa(T3, (e5) => {
            Sr(N2) && e5(_2);
          });
          var F2 = fo(T3, 4);
          Ha(F2, (e5) => Xt(M2, e5), () => Sr(M2));
          var Y3, ne2, te = fo(a3, 2), oe = uo(te), ae = uo(oe), ie3 = uo(ae), se = uo(ie3), le = uo(se), ce = Lt(() => Sr(D2) ? faCaretDown : faCaretRight);
          nl(le, {
            get data() {
              return Sr(ce);
            }
          });
          var de = fo(ae, 2), fe = (e5) => {
            Pg(e5, {
              get externalContent() {
                return Sr(R);
              },
              externalSelection: void 0,
              get history() {
                return Sr(E);
              },
              readOnly: true,
              get truncateTextSize() {
                return v();
              },
              mainMenuBar: false,
              navigationBar: false,
              get indentation() {
                return u();
              },
              get escapeControlCharacters() {
                return f();
              },
              get escapeUnicodeCharacters() {
                return p2();
              },
              get parser() {
                return h2();
              },
              get parseMemoizeOne() {
                return g();
              },
              get onRenderValue() {
                return w();
              },
              get onRenderMenu() {
                return k();
              },
              get onRenderContextMenu() {
                return S();
              },
              onError: Or(() => console.error),
              get onChange() {
                return noop_default;
              },
              get onChangeMode() {
                return noop_default;
              },
              get onSelect() {
                return noop_default;
              },
              get onUndo() {
                return noop_default;
              },
              get onRedo() {
                return noop_default;
              },
              get onFocus() {
                return noop_default;
              },
              get onBlur() {
                return noop_default;
              },
              get onSortModal() {
                return noop_default;
              },
              get onTransformModal() {
                return noop_default;
              },
              get onJSONEditorModal() {
                return noop_default;
              },
              get onClassName() {
                return C3();
              },
              validator: void 0,
              get validationParser() {
                return m();
              },
              get pathParser() {
                return b();
              }
            });
          };
          sa(de, (e5) => {
            Sr(D2) && e5(fe);
          });
          var pe = fo(oe, 2), he = fo(uo(pe), 2), ge = (e5) => {
            Pg(e5, {
              get externalContent() {
                return Sr(V2);
              },
              externalSelection: void 0,
              get history() {
                return Sr(E);
              },
              readOnly: true,
              get truncateTextSize() {
                return v();
              },
              mainMenuBar: false,
              navigationBar: false,
              get indentation() {
                return u();
              },
              get escapeControlCharacters() {
                return f();
              },
              get escapeUnicodeCharacters() {
                return p2();
              },
              get parser() {
                return h2();
              },
              get parseMemoizeOne() {
                return g();
              },
              get onRenderValue() {
                return w();
              },
              get onRenderMenu() {
                return k();
              },
              get onRenderContextMenu() {
                return S();
              },
              onError: Or(() => console.error),
              get onChange() {
                return noop_default;
              },
              get onChangeMode() {
                return noop_default;
              },
              get onSelect() {
                return noop_default;
              },
              get onUndo() {
                return noop_default;
              },
              get onRedo() {
                return noop_default;
              },
              get onFocus() {
                return noop_default;
              },
              get onBlur() {
                return noop_default;
              },
              get onSortModal() {
                return noop_default;
              },
              get onTransformModal() {
                return noop_default;
              },
              get onJSONEditorModal() {
                return noop_default;
              },
              get onClassName() {
                return C3();
              },
              validator: void 0,
              get validationParser() {
                return m();
              },
              get pathParser() {
                return b();
              }
            });
          }, me = (e5) => {
            var n5 = _g(), t6 = uo(n5);
            ko(() => Xr(t6, Sr(W2))), Hr(e5, n5);
          };
          sa(he, (e5) => {
            Sr(W2) ? e5(me, false) : e5(ge);
          });
          var be = uo(fo(r3, 2));
          jo(() => Dr("click", be, K)), ba(be, (e5) => null == G2 ? void 0 : G2(e5)), ko((e5, n5, t6) => {
            Na(s3, e5), Na(F2, Sr(B)), Y3 = Ca(te, 1, "jse-data-contents svelte-rrrjnb", null, Y3, n5), ne2 = Ca(oe, 1, "jse-original-data svelte-rrrjnb", null, ne2, t6), be.disabled = !!Sr(W2);
          }, [() => (Ar(isEmpty_default), Ar(l()), Ar(au), Or(() => isEmpty_default(l()) ? "(document root)" : au(l()))), () => ({
            "jse-hide-original-data": !Sr(D2)
          }), () => ({
            "jse-hide": !Sr(D2)
          })], Lt), Dr("click", y2, Z2), Dr("input", F2, Q), Dr("click", se, X2), Hr(e4, t5);
        },
        $$slots: {
          default: true
        }
      }), ba(t4, (e4, n4) => null == Jf ? void 0 : Jf(e4, n4), () => ne), Hr(e3, t4);
    },
    $$slots: {
      default: true
    }
  }), Nt();
}
function Vg() {
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-status-bar.svelte-1ulj7zd {\n  background: var(--jse-panel-background, #ebebeb);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  margin: 0;\n  border-top: var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n  display: flex;\n  gap: var(--jse-padding, 10px);\n}\n.jse-status-bar.svelte-1ulj7zd:last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-status-bar.svelte-1ulj7zd .jse-status-bar-info:where(.svelte-1ulj7zd) {\n  padding: 2px;\n}');
var $g = Lr('<div class="jse-status-bar-info svelte-1ulj7zd"> </div>');
var Hg = Lr('<div class="jse-status-bar-info svelte-1ulj7zd"> </div>');
var Qg = Lr('<div class="jse-status-bar-info svelte-1ulj7zd"> </div>');
var Yg = Lr('<div class="jse-status-bar svelte-1ulj7zd"><!> <!> <!></div>');
var Kg = HighlightStyle.define([{
  tag: tags.propertyName,
  color: "var(--internal-key-color)"
}, {
  tag: tags.number,
  color: "var(--internal-value-color-number)"
}, {
  tag: tags.bool,
  color: "var(--internal-value-color-boolean)"
}, {
  tag: tags.string,
  color: "var(--internal-value-color-string)"
}, {
  tag: tags.keyword,
  color: "var(--internal-value-color-null)"
}]);
var Zg = syntaxHighlighting(Kg);
var Xg = Kg.style;
Kg.style = (e2) => Xg(e2 || []);
var Gg = [ViewPlugin.fromClass(class {
  constructor(e2) {
    this.view = e2, this.indentUnit = getIndentUnit(e2.state), this.initialPaddingLeft = null, this.isChrome = null === window || void 0 === window ? void 0 : window.navigator.userAgent.includes("Chrome"), this.generate(e2.state);
  }
  update(e2) {
    var n2 = getIndentUnit(e2.state);
    (n2 !== this.indentUnit || e2.docChanged || e2.viewportChanged) && (this.indentUnit = n2, this.generate(e2.state));
  }
  generate(e2) {
    var n2 = new RangeSetBuilder();
    this.initialPaddingLeft ? this.addStyleToBuilder(n2, e2, this.initialPaddingLeft) : this.view.requestMeasure({
      read: (e3) => {
        var t3 = e3.contentDOM.querySelector(".cm-line");
        t3 && (this.initialPaddingLeft = window.getComputedStyle(t3).getPropertyValue("padding-left"), this.addStyleToBuilder(n2, e3.state, this.initialPaddingLeft)), this.decorations = n2.finish();
      }
    }), this.decorations = n2.finish();
  }
  addStyleToBuilder(e2, n2, t3) {
    var o2 = this.getVisibleLines(n2);
    for (var r2 of o2) {
      var {
        numColumns: a2,
        containsTab: i2
      } = this.numColumns(r2.text, n2.tabSize), s2 = "calc(".concat(a2 + this.indentUnit, "ch + ").concat(t3, ")"), l = this.isChrome ? "calc(-".concat(a2 + this.indentUnit, "ch - ").concat(i2 ? 1 : 0, "px)") : "-".concat(a2 + this.indentUnit, "ch");
      e2.add(r2.from, r2.from, Decoration.line({
        attributes: {
          style: "padding-left: ".concat(s2, "; text-indent: ").concat(l, ";")
        }
      }));
    }
  }
  getVisibleLines(e2) {
    var n2 = /* @__PURE__ */ new Set(), t3 = null;
    for (var {
      from: o2,
      to: r2
    } of this.view.visibleRanges) for (var a2 = o2; a2 <= r2; ) {
      var i2 = e2.doc.lineAt(a2);
      t3 !== i2 && (n2.add(i2), t3 = i2), a2 = i2.to + 1;
    }
    return n2;
  }
  numColumns(e2, n2) {
    var t3 = 0, o2 = false;
    e: for (var r2 = 0; r2 < e2.length; r2++) switch (e2[r2]) {
      case " ":
        t3 += 1;
        continue e;
      case "	":
        t3 += n2 - t3 % n2, o2 = true;
        continue e;
      case "\r":
        continue e;
      default:
        break e;
    }
    return {
      numColumns: t3,
      containsTab: o2
    };
  }
}, {
  decorations: (e2) => e2.decorations
})];
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-text-mode.svelte-xt61xw {\n  --internal-key-color: var(--jse-key-color, #1a1a1a);\n  --internal-value-color-number: var(--jse-value-color-number, #ee422e);\n  --internal-value-color-boolean: var(--jse-value-color-boolean, #ff8c00);\n  --internal-value-color-string: var(--jse-value-color-string, #008000);\n  --internal-value-color-null: var(--jse-value-color-null, #004ed0);\n  flex: 1;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  background: var(--jse-background-color, #fff);\n}\n.jse-text-mode.no-main-menu.svelte-xt61xw {\n  border-top: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) {\n  flex: 1;\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  overflow: hidden;\n  min-width: 0;\n  min-height: 0;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw):last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents.jse-hidden:where(.svelte-xt61xw) {\n  visibility: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor {\n  flex: 1;\n  overflow: hidden;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-scroller {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  line-height: var(--jse-line-height, calc(1em + 4px));\n  color: var(--jse-delimiter-color, rgba(0, 0, 0, 0.38));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-gutters {\n  background: var(--jse-panel-background, #ebebeb);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  border-right: var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-activeLine,\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-activeLineGutter {\n  background: var(--jse-active-line-background-color, rgba(0, 0, 0, 0.06));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-selectionBackground {\n  background: var(--jse-selection-background-color, #d3d3d3);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-searchMatch {\n  background-color: var(--jse-search-match-color, #ffe665);\n  outline: var(--jse-search-match-outline, none);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-searchMatch.cm-searchMatch-selected {\n  background-color: var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));\n  outline: var(--jse-search-match-outline, 2px solid #e0be00);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-selectionMatch {\n  background-color: var(--jse-search-match-background-color, rgba(153, 255, 119, 0.5019607843));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-foldPlaceholder {\n  background: var(--jse-tag-background, rgba(0, 0, 0, 0.2));\n  color: var(--jse-tag-color, var(--jse-text-color-inverse, #fff));\n  border: none;\n  padding: 0 var(--jse-padding, 10px);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-tooltip {\n  font-size: var(--jse-font-size, 16px);\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  color: var(--jse-tooltip-color, var(--jse-text-color, #4d4d4d));\n  background: var(--jse-tooltip-background, var(--jse-modal-background, #f5f5f5));\n  border: var(--jse-tooltip-border, var(--jse-main-border, 1px solid #d7d7d7));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-diagnosticAction {\n  background: var(--jse-tooltip-action-button-color, var(--jse-text-color-inverse, #fff));\n  background: var(--jse-tooltip-action-button-background, #4d4d4d);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-panels {\n  border-bottom: var(--jse-panel-border, var(--jse-main-border, 1px solid #d7d7d7));\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search {\n  background: var(--jse-panel-background, #ebebeb);\n  color: var(--jse-panel-color, var(--jse-text-color, #4d4d4d));\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search input {\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size-text-mode-search, 80%);\n  color: var(--jse-input-color, var(--jse-text-color, #4d4d4d));\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n  margin-right: 2px;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search button {\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size-text-mode-search, 80%);\n  color: var(--jse-panel-button-color, inherit);\n  background: var(--jse-panel-button-background, transparent);\n  border: none;\n  cursor: pointer;\n  text-transform: capitalize;\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px);\n  margin: 0;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search button:hover {\n  color: var(--panel-button-color-highlight, var(--jse-text-color, #4d4d4d));\n  background: var(--jse-panel-button-background-highlight, #e0e0e0);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search label {\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size-text-mode-search, 80%);\n  padding-left: var(--jse-padding, 10px);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search label input {\n  margin-right: 2px;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-search button[name="close"] {\n  width: 32px;\n  height: 32px;\n  font-size: 24px;\n  line-height: 24px;\n  padding: 0;\n  right: 0;\n  top: -4px;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .cm-editor .cm-cursor-primary {\n  border-color: var(--jse-text-color, #4d4d4d);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .jse-loading-space:where(.svelte-xt61xw) {\n  flex: 1;\n}\n.jse-text-mode.svelte-xt61xw .jse-contents:where(.svelte-xt61xw) .jse-loading:where(.svelte-xt61xw) {\n  flex: 2;\n  text-align: center;\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  box-sizing: border-box;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n}\n.jse-text-mode.svelte-xt61xw .jse-contents.jse-preview:where(.svelte-xt61xw) {\n  flex: 1;\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  overflow: auto;\n  white-space: pre-wrap;\n  word-break: break-word;\n  padding: 2px;\n}');
var em = Lr('<!> <div class="jse-contents jse-preview svelte-xt61xw"> </div>', 1);
var nm = Lr("<!> <!> <!> <!>", 1);
var tm = Lr("<div></div> <!> <!>", 1);
var om = Lr('<div class="jse-contents svelte-xt61xw"><div class="jse-loading-space svelte-xt61xw"></div> <div class="jse-loading svelte-xt61xw">loading...</div></div>');
var rm2 = Lr("<div><!> <!></div>");
function am(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), a2 = ai(n2, "readOnly", 9), s2 = ai(n2, "mainMenuBar", 9), l = ai(n2, "statusBar", 9), c = ai(n2, "askToFormat", 9), d = ai(n2, "externalContent", 9), u = ai(n2, "externalSelection", 9), v = ai(n2, "history", 9), p2 = ai(n2, "indentation", 9), h2 = ai(n2, "tabSize", 9), g = ai(n2, "escapeUnicodeCharacters", 9), m = ai(n2, "parser", 9), b = ai(n2, "validator", 9), j = ai(n2, "validationParser", 9), x = ai(n2, "onChange", 9), y = ai(n2, "onChangeMode", 9), w = ai(n2, "onSelect", 9), k = ai(n2, "onUndo", 9), C3 = ai(n2, "onRedo", 9), M2 = ai(n2, "onError", 9), E = ai(n2, "onFocus", 9), A2 = ai(n2, "onBlur", 9), R = ai(n2, "onRenderMenu", 9), q2 = ai(n2, "onSortModal", 9), P = ai(n2, "onTransformModal", 9), N2 = ii("jsoneditor:TextMode"), I = {
    key: "Mod-i",
    run: xe,
    shift: ye,
    preventDefault: true
  }, U2 = "undefined" == typeof window;
  N2("isSSR:", U2);
  var D2, J = Kt(void 0, true), B = Kt(void 0, true), _ = Kt(void 0, true), L = Kt(false, true), W2 = Kt(c(), true), V2 = Kt([], true), H2 = new Compartment(), Q = new Compartment(), Y2 = new Compartment(), K = new Compartment(), Z2 = new Compartment(), X2 = d(), G2 = Kt(Yi(X2, p2(), m()), true), ee = Annotation.define(), te = null;
  function oe() {
    if (!te || 0 === te.length) return false;
    var e3 = te[0].startState, n3 = te[te.length - 1].state, t4 = te.map((e4) => e4.changes).reduce((e4, n4) => e4.compose(n4)), o3 = {
      type: "text",
      undo: {
        changes: t4.invert(e3.doc).toJSON(),
        selection: Fn2(e3.selection)
      },
      redo: {
        changes: t4.toJSON(),
        selection: Fn2(n3.selection)
      }
    };
    return N2("add history item", o3), v().add(o3), te = null, true;
  }
  var re = Kt(g(), true);
  ta(i(function* () {
    if (!U2) try {
      D2 = function(e3) {
        var {
          target: n3,
          initialText: t4,
          readOnly: o3,
          indentation: r2
        } = e3;
        N2("Create CodeMirror editor", {
          readOnly: o3,
          indentation: r2
        });
        var a3 = function(e4, n4) {
          if (!Ic(e4)) return false;
          return e4.ranges.every((e5) => e5.anchor < n4.length && e5.head < n4.length);
        }(u(), t4) ? Fe2(u()) : void 0, i2 = EditorState.create({
          doc: t4,
          selection: a3,
          extensions: [keymap.of([indentWithTab, I]), H2.of(Ne()), lintGutter(), lineNumbers(), highlightActiveLineGutter(), highlightSpecialChars(), foldGutter(), drawSelection(), dropCursor(), EditorState.allowMultipleSelections.of(true), indentOnInput(), syntaxHighlighting(defaultHighlightStyle, {
            fallback: true
          }), bracketMatching(), closeBrackets(), autocompletion(), rectangularSelection(), crosshairCursor(), highlightActiveLine(), highlightSelectionMatches(), keymap.of([...closeBracketsKeymap, ...defaultKeymap, ...searchKeymap, {
            key: "Mod-z",
            run: Oe,
            preventDefault: true
          }, {
            key: "Mod-y",
            mac: "Mod-Shift-z",
            run: Me,
            preventDefault: true
          }, {
            key: "Ctrl-Shift-z",
            run: Me,
            preventDefault: true
          }, ...foldKeymap, ...completionKeymap, ...lintKeymap]), Zg, indentationMarkers({
            hideFirstIndent: true
          }), EditorView.domEventHandlers({
            dblclick: Te
          }), EditorView.updateListener.of((e4) => {
            (Xt(_, e4.state), e4.docChanged) && (e4.transactions.some((e5) => !!e5.annotation(ee)) || (te = [...null != te ? te : [], e4]), en());
            e4.selectionSet && Bn();
          }), json(), search({
            top: true
          }), EditorView.lineWrapping, Q.of(EditorState.readOnly.of(o3)), K.of(EditorState.tabSize.of(h2())), Y2.of(Ge(r2)), Z2.of(EditorView.theme({}, {
            dark: Ie()
          }))]
        });
        D2 = new EditorView({
          state: i2,
          parent: n3
        }), a3 && D2.dispatch(D2.state.update({
          selection: a3.main,
          scrollIntoView: true
        }));
        return D2;
      }({
        target: Sr(J),
        initialText: Ln2(Sr(G2), Sr(L)) ? "" : Sr(t3).escapeValue(Sr(G2)),
        readOnly: a2(),
        indentation: p2()
      });
    } catch (e3) {
      console.error(e3);
    }
  })), oa(() => {
    jn(), D2 && (N2("Destroy CodeMirror editor"), D2.destroy());
  });
  var ie3 = uniqueId_default(), se = uniqueId_default();
  function le() {
    D2 && (N2("focus"), D2.focus());
  }
  function de(e3) {
    if (D2) try {
      if (e3 && e3.length > 0) {
        var {
          from: n3
        } = Fi(Sr(t3).escapeValue(Sr(G2)), e3);
        void 0 !== n3 && (D2.dispatch({
          selection: {
            anchor: n3,
            head: n3
          }
        }), foldCode(D2));
      } else foldAll(D2);
    } catch (e4) {
      M2()(e4);
    }
  }
  function ue(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : zc;
    if (D2) try {
      if (e3 && e3.length > 0) {
        var {
          from: o3
        } = Fi(Sr(t3).escapeValue(Sr(G2)), e3);
        void 0 !== o3 && (D2.dispatch({
          selection: {
            anchor: o3,
            head: o3
          }
        }), unfoldCode(D2));
      } else unfoldAll(D2);
      null == n3 || n3(e3);
    } catch (e4) {
      M2()(e4);
    }
  }
  var ve = false;
  function ge(e3) {
    return je(e3, false);
  }
  function je(e3, n3) {
    N2("handlePatch", e3, n3);
    var t4 = m().parse(Sr(G2)), o3 = immutableJSONPatch(t4, e3), r2 = revertJSONPatch(t4, e3);
    return _e({
      text: m().stringify(o3, null, p2())
    }, n3, false), {
      json: o3,
      previousJson: t4,
      undo: r2,
      redo: e3
    };
  }
  function xe() {
    if (N2("format"), a2()) return false;
    try {
      var e3 = m().parse(Sr(G2));
      return _e({
        text: m().stringify(e3, null, p2())
      }, true, false), Xt(W2, c()), true;
    } catch (e4) {
      M2()(e4);
    }
    return false;
  }
  function ye() {
    if (N2("compact"), a2()) return false;
    try {
      var e3 = m().parse(Sr(G2));
      return _e({
        text: m().stringify(e3)
      }, true, false), Xt(W2, false), true;
    } catch (e4) {
      M2()(e4);
    }
    return false;
  }
  function we() {
    if (N2("repair"), !a2()) try {
      _e({
        text: jsonrepair(Sr(G2))
      }, true, false), Xt(Wn2, yl), Xt(Vn2, void 0);
    } catch (e3) {
      M2()(e3);
    }
  }
  function ke() {
    var e3;
    if (!a2()) try {
      var n3 = m().parse(Sr(G2));
      ve = true, q2()({
        id: ie3,
        json: n3,
        rootPath: [],
        onSort: (e3 = i(function* (e4) {
          var {
            operations: n4
          } = e4;
          N2("onSort", n4), je(n4, true);
        }), function(n4) {
          return e3.apply(this, arguments);
        }),
        onClose: () => {
          ve = false, le();
        }
      });
    } catch (e4) {
      M2()(e4);
    }
  }
  function Se(e3) {
    var {
      id: n3,
      rootPath: t4,
      onTransform: o3,
      onClose: r2
    } = e3;
    try {
      var a3 = m().parse(Sr(G2));
      ve = true, P()({
        id: n3 || se,
        json: a3,
        rootPath: t4 || [],
        onTransform: (e4) => {
          o3 ? o3({
            operations: e4,
            json: a3,
            transformedJson: immutableJSONPatch(a3, e4)
          }) : (N2("onTransform", e4), je(e4, true));
        },
        onClose: () => {
          ve = false, le(), r2 && r2();
        }
      });
    } catch (e4) {
      M2()(e4);
    }
  }
  function Ce() {
    a2() || Se({
      rootPath: []
    });
  }
  function ze() {
    D2 && (Sr(J) && Sr(J).querySelector(".cm-search") ? closeSearchPanel(D2) : openSearchPanel(D2));
  }
  function Oe() {
    if (a2()) return false;
    jn();
    var e3 = v().undo();
    return N2("undo", e3), Yl(e3) ? (D2.dispatch({
      annotations: ee.of("undo"),
      changes: ChangeSet.fromJSON(e3.undo.changes),
      selection: EditorSelection.fromJSON(e3.undo.selection),
      scrollIntoView: true
    }), true) : (k()(e3), false);
  }
  function Me() {
    if (a2()) return false;
    jn();
    var e3 = v().redo();
    return N2("redo", e3), Yl(e3) ? (D2.dispatch({
      annotations: ee.of("redo"),
      changes: ChangeSet.fromJSON(e3.redo.changes),
      selection: EditorSelection.fromJSON(e3.redo.selection),
      scrollIntoView: true
    }), true) : (C3()(e3), false);
  }
  function Ee() {
    Xt(L, true), _e(d(), true, true);
  }
  function Ae() {
    y()(os.tree);
  }
  function Re() {
    $e();
  }
  function qe(e3) {
    N2("select validation error", e3);
    var {
      from: n3,
      to: t4
    } = Ue(e3);
    void 0 !== n3 && void 0 !== t4 && (Pe(n3, t4), le());
  }
  function Pe(e3, n3) {
    N2("setSelection", {
      anchor: e3,
      head: n3
    }), D2 && D2.dispatch(D2.state.update({
      selection: {
        anchor: e3,
        head: n3
      },
      scrollIntoView: true
    }));
  }
  function Te(e3, n3) {
    if (1 === n3.state.selection.ranges.length) {
      var t4 = n3.state.selection.ranges[0], o3 = Sr(G2).slice(t4.from, t4.to);
      if ("{" === o3 || "[" === o3) {
        var r2 = import_json_source_map.default.parse(Sr(G2)), a3 = Object.keys(r2.pointers).find((e4) => {
          var n4;
          return (null === (n4 = r2.pointers[e4].value) || void 0 === n4 ? void 0 : n4.pos) === t4.from;
        }), i2 = r2.pointers[a3];
        if (a3 && i2 && i2.value && i2.valueEnd) N2("pointer found, selecting inner contents of path:", a3, i2), Pe(i2.value.pos + 1, i2.valueEnd.pos - 1);
      }
    }
  }
  function Ne() {
    return linter($n2, {
      delay: 300
    });
  }
  function Ie() {
    return !!Sr(J) && getComputedStyle(Sr(J)).getPropertyValue("--jse-theme").includes("dark");
  }
  function Ue(e3) {
    var {
      path: n3,
      message: o3,
      severity: r2
    } = e3, {
      line: a3,
      column: i2,
      from: s3,
      to: l2
    } = Fi(Sr(t3).escapeValue(Sr(G2)), n3);
    return {
      path: n3,
      line: a3,
      column: i2,
      from: s3,
      to: l2,
      message: o3,
      severity: r2,
      actions: []
    };
  }
  function Je(e3, n3) {
    var {
      line: t4,
      column: o3,
      position: r2,
      message: i2
    } = e3;
    return {
      path: [],
      line: t4,
      column: o3,
      from: r2,
      to: r2,
      severity: is.error,
      message: i2,
      actions: n3 && !a2() ? [{
        name: "Auto repair",
        apply: () => we()
      }] : void 0
    };
  }
  function Be(e3) {
    return {
      from: e3.from || 0,
      to: e3.to || 0,
      message: e3.message || "",
      actions: e3.actions,
      severity: e3.severity
    };
  }
  function _e(e3, n3, o3) {
    var r2 = Yi(e3, p2(), m()), a3 = !isEqual_default(e3, X2), i2 = X2;
    N2("setCodeMirrorContent", {
      isChanged: a3,
      emitChange: n3,
      forceUpdate: o3
    }), D2 && (a3 || o3) && (X2 = e3, Xt(G2, r2), Ln2(Sr(G2), Sr(L)) || D2.dispatch({
      changes: {
        from: 0,
        to: D2.state.doc.length,
        insert: Sr(t3).escapeValue(Sr(G2))
      }
    }), oe(), a3 && n3 && xn(X2, i2));
  }
  function Fe2(e3) {
    return Ic(e3) ? EditorSelection.fromJSON(e3) : void 0;
  }
  function We2() {
    return Ve2.apply(this, arguments);
  }
  function Ve2() {
    return Ve2 = i(function* () {
      N2("refresh"), yield function() {
        return He.apply(this, arguments);
      }();
    }), Ve2.apply(this, arguments);
  }
  function $e() {
    if (D2) {
      var e3 = D2 ? Sr(t3).unescapeValue(D2.state.doc.toString()) : "", n3 = e3 !== Sr(G2);
      if (N2("onChangeCodeMirrorValue", {
        isChanged: n3
      }), n3) {
        var o3 = X2;
        Xt(G2, e3), X2 = {
          text: Sr(G2)
        }, oe(), xn(X2, o3), wr(), Bn();
      }
    }
  }
  function He() {
    return (He = i(function* () {
      if (wr(), D2) {
        var e3 = Ie();
        return N2("updateTheme", {
          dark: e3
        }), D2.dispatch({
          effects: [Z2.reconfigure(EditorView.theme({}, {
            dark: e3
          }))]
        }), new Promise((e4) => setTimeout(e4));
      }
      return Promise.resolve();
    })).apply(this, arguments);
  }
  function Ge(e3) {
    var n3 = indentUnit.of("number" == typeof e3 ? " ".repeat(e3) : e3);
    return "	" === e3 ? [n3] : [n3, Gg];
  }
  Mf({
    onMount: ta,
    onDestroy: oa,
    getWindow: () => Os(Sr(B)),
    hasFocus: () => ve && document.hasFocus() || Ms(Sr(B)),
    onFocus: E(),
    onBlur: () => {
      jn(), A2()();
    }
  });
  var en = debounce_default($e, 300);
  function jn() {
    en.flush();
  }
  function xn(e3, n3) {
    x() && x()(e3, n3, {
      contentErrors: Hn2(),
      patchResult: void 0
    });
  }
  function Bn() {
    w()(Fn2(Sr(_).selection));
  }
  function Fn2(e3) {
    return r({
      type: rs.text
    }, e3.toJSON());
  }
  function Ln2(e3, n3) {
    return !!e3 && e3.length > hl && !n3;
  }
  var Wn2 = Kt(yl, true), Vn2 = Kt(void 0, true);
  function $n2() {
    if (Ln2(Sr(G2), Sr(L))) return [];
    var e3 = Hn2();
    if (Ul(e3)) {
      var {
        parseError: n3,
        isRepairable: t4
      } = e3;
      return [Be(Je(n3, t4))];
    }
    return Dl(e3) ? e3.validationErrors.map(Ue).map(Be) : [];
  }
  function Hn2() {
    N2("validate:start"), jn();
    var e3 = Qn2(Sr(t3).escapeValue(Sr(G2)), b(), m(), j());
    return Ul(e3) ? (Xt(Wn2, e3.isRepairable ? wl : "invalid"), Xt(Vn2, e3.parseError), Xt(V2, [])) : (Xt(Wn2, yl), Xt(Vn2, void 0), Xt(V2, (null == e3 ? void 0 : e3.validationErrors) || [])), N2("validate:end"), e3;
  }
  var Qn2 = memoizeOne(zf);
  function Yn2() {
    Sr(Vn2) && function(e3) {
      N2("select parse error", e3);
      var n3 = Je(e3, false);
      Pe(null != n3.from ? n3.from : 0, null != n3.to ? n3.to : 0), le();
    }(Sr(Vn2));
  }
  var Kn2 = {
    icon: faEye,
    text: "Show me",
    title: "Move to the parse error location",
    onClick: Yn2
  };
  xo(() => Ar(g()), () => {
    Xt(t3, us({
      escapeControlCharacters: false,
      escapeUnicodeCharacters: g()
    }));
  }), xo(() => Ar(d()), () => {
    _e(d(), false, false);
  }), xo(() => Ar(u()), () => {
    !function(e3) {
      if (Ic(e3)) {
        var n3 = Fe2(e3);
        !D2 || !n3 || Sr(_) && Sr(_).selection.eq(n3) || (N2("applyExternalSelection", n3), D2.dispatch({
          selection: n3
        }));
      }
    }(u());
  }), xo(() => Ar(b()), () => {
    !function(e3) {
      N2("updateLinter", e3), D2 && D2.dispatch({
        effects: H2.reconfigure(Ne())
      });
    }(b());
  }), xo(() => Ar(p2()), () => {
    !function(e3) {
      D2 && (N2("updateIndentation", e3), D2.dispatch({
        effects: Y2.reconfigure(Ge(e3))
      }));
    }(p2());
  }), xo(() => Ar(h2()), () => {
    !function(e3) {
      D2 && (N2("updateTabSize", e3), D2.dispatch({
        effects: K.reconfigure(EditorState.tabSize.of(e3))
      }));
    }(h2());
  }), xo(() => Ar(a2()), () => {
    !function(e3) {
      D2 && (N2("updateReadOnly", e3), D2.dispatch({
        effects: [Q.reconfigure(EditorState.readOnly.of(e3))]
      }));
    }(a2());
  }), xo(() => (Sr(re), Ar(g())), () => {
    Sr(re) !== g() && (Xt(re, g()), N2("forceUpdateText", {
      escapeUnicodeCharacters: g()
    }), D2 && D2.dispatch({
      changes: {
        from: 0,
        to: D2.state.doc.length,
        insert: Sr(t3).escapeValue(Sr(G2))
      }
    }));
  }), xo(() => (Sr(Wn2), Ar(a2()), faWrench), () => {
    Xt(o2, Sr(Wn2) !== wl || a2() ? [Kn2] : [{
      icon: faWrench,
      text: "Auto repair",
      title: "Automatically repair JSON",
      onClick: we
    }, Kn2]);
  }), yo(), Ka(true);
  var Zn2, Xn2 = rm2(), Gn2 = uo(Xn2), et3 = (e3) => {
    var n3 = Lt(() => (Sr(G2), Or(() => 0 === Sr(G2).length))), t4 = Lt(() => !Sr(n3)), o3 = Lt(() => !Sr(n3)), r2 = Lt(() => !Sr(n3)), i2 = Lt(() => !Sr(n3));
    !function(e4, n4) {
      Tt(n4, false);
      var t5 = Kt(void 0, true), o4 = ai(n4, "readOnly", 9, false), r3 = ai(n4, "onFormat", 9), a3 = ai(n4, "onCompact", 9), i3 = ai(n4, "onSort", 9), s3 = ai(n4, "onTransform", 9), l2 = ai(n4, "onToggleSearch", 9), c2 = ai(n4, "onUndo", 9), d2 = ai(n4, "onRedo", 9), u2 = ai(n4, "canUndo", 9), v2 = ai(n4, "canRedo", 9), f = ai(n4, "canFormat", 9), p3 = ai(n4, "canCompact", 9), h3 = ai(n4, "canSort", 9), g2 = ai(n4, "canTransform", 9), m2 = ai(n4, "onRenderMenu", 9), b2 = {
        type: "button",
        icon: faSearch,
        title: "Search (Ctrl+F)",
        className: "jse-search",
        onClick: l2()
      }, j2 = Kt(void 0, true);
      xo(() => (Ar(o4()), Ar(r3()), Ar(f()), Ar(a3()), Ar(p3()), Ar(i3()), Ar(h3()), Ar(s3()), Ar(g2()), Ar(c2()), Ar(u2()), Ar(d2()), Ar(v2())), () => {
        Xt(j2, o4() ? [b2, {
          type: "space"
        }] : [{
          type: "button",
          icon: Vp,
          title: "Format JSON: add proper indentation and new lines (Ctrl+I)",
          className: "jse-format",
          onClick: r3(),
          disabled: o4() || !f()
        }, {
          type: "button",
          icon: $p,
          title: "Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)",
          className: "jse-compact",
          onClick: a3(),
          disabled: o4() || !p3()
        }, {
          type: "separator"
        }, {
          type: "button",
          icon: faSortAmountDownAlt,
          title: "Sort",
          className: "jse-sort",
          onClick: i3(),
          disabled: o4() || !h3()
        }, {
          type: "button",
          icon: faFilter,
          title: "Transform contents (filter, sort, project)",
          className: "jse-transform",
          onClick: s3(),
          disabled: o4() || !g2()
        }, b2, {
          type: "separator"
        }, {
          type: "button",
          icon: faUndo,
          title: "Undo (Ctrl+Z)",
          className: "jse-undo",
          onClick: c2(),
          disabled: !u2()
        }, {
          type: "button",
          icon: faRedo,
          title: "Redo (Ctrl+Shift+Z)",
          className: "jse-redo",
          onClick: d2(),
          disabled: !v2()
        }, {
          type: "space"
        }]);
      }), xo(() => (Ar(m2()), Sr(j2)), () => {
        Xt(t5, m2()(Sr(j2)) || Sr(j2));
      }), yo(), Ka(true), Qf(e4, {
        get items() {
          return Sr(t5);
        }
      }), Nt();
    }(e3, {
      get readOnly() {
        return a2();
      },
      onFormat: xe,
      onCompact: ye,
      onSort: ke,
      onTransform: Ce,
      onToggleSearch: ze,
      onUndo: Oe,
      onRedo: Me,
      get canFormat() {
        return Sr(t4);
      },
      get canCompact() {
        return Sr(o3);
      },
      get canSort() {
        return Sr(r2);
      },
      get canTransform() {
        return Sr(i2);
      },
      get canUndo() {
        return Ar(v()), Or(() => v().canUndo);
      },
      get canRedo() {
        return Ar(v()), Or(() => v().canRedo);
      },
      get onRenderMenu() {
        return R();
      }
    });
  };
  sa(Gn2, (e3) => {
    s2() && e3(et3);
  });
  var nt3 = fo(Gn2, 2), tt3 = (e3) => {
    var n3, t4 = tm(), r2 = Lt(() => (Sr(G2), Sr(L), Or(() => Ln2(Sr(G2), Sr(L))))), a3 = vo(t4);
    Ha(a3, (e4) => Xt(J, e4), () => Sr(J));
    var i2 = fo(a3, 2), s3 = (e4) => {
      var n4 = em(), t5 = vo(n4), o3 = Lt(() => (Ar($d), Ar(hl), Sr(G2), Or(() => "The JSON document is larger than ".concat($d(hl), ", ") + "and may crash your browser when loading it in text mode. Actual size: ".concat($d(Sr(G2).length), "."))));
      Rf(t5, {
        get icon() {
          return faExclamationTriangle;
        },
        type: "error",
        get message() {
          return Sr(o3);
        },
        actions: [{
          text: "Open anyway",
          title: "Open the document in text mode. This may freeze or crash your browser.",
          onClick: Ee
        }, {
          text: "Open in tree mode",
          title: "Open the document in tree mode. Tree mode can handle large documents.",
          onClick: Ae
        }, {
          text: "Cancel",
          title: "Cancel opening this large document.",
          onClick: Re
        }],
        onClose: le
      });
      var r3 = uo(fo(t5, 2));
      ko((e5) => Xr(r3, e5), [() => (Ar(Vs), Sr(G2), Ar(ul), Or(() => Vs(Sr(G2) || "", ul)))], Lt), Hr(e4, n4);
    };
    sa(i2, (e4) => {
      Sr(r2) && e4(s3);
    });
    var c2 = fo(i2, 2), d2 = (e4) => {
      var n4 = nm(), t5 = vo(n4), r3 = (e5) => {
        !function(e6, n5) {
          Tt(n5, false);
          var t6 = ai(n5, "editorState", 8), o3 = Kt(), r4 = Kt(), a5 = Kt(), i4 = Kt(), s5 = Kt();
          xo(() => Ar(t6()), () => {
            var e7;
            Xt(o3, null === (e7 = t6()) || void 0 === e7 || null === (e7 = e7.selection) || void 0 === e7 || null === (e7 = e7.main) || void 0 === e7 ? void 0 : e7.head);
          }), xo(() => (Sr(o3), Ar(t6())), () => {
            var e7;
            Xt(r4, void 0 !== Sr(o3) ? null === (e7 = t6()) || void 0 === e7 || null === (e7 = e7.doc) || void 0 === e7 ? void 0 : e7.lineAt(Sr(o3)) : void 0);
          }), xo(() => Sr(r4), () => {
            Xt(a5, void 0 !== Sr(r4) ? Sr(r4).number : void 0);
          }), xo(() => (Sr(r4), Sr(o3)), () => {
            Xt(i4, void 0 !== Sr(r4) && void 0 !== Sr(o3) ? Sr(o3) - Sr(r4).from + 1 : void 0);
          }), xo(() => Ar(t6()), () => {
            var e7;
            Xt(s5, null === (e7 = t6()) || void 0 === e7 || null === (e7 = e7.selection) || void 0 === e7 || null === (e7 = e7.ranges) || void 0 === e7 ? void 0 : e7.reduce((e8, n6) => e8 + n6.to - n6.from, 0));
          }), yo(), Ka();
          var l2 = Yg(), c4 = uo(l2), d3 = (e7) => {
            var n6 = $g(), t7 = uo(n6);
            ko(() => {
              var e8;
              return Xr(t7, "Line: ".concat(null !== (e8 = Sr(a5)) && void 0 !== e8 ? e8 : ""));
            }), Hr(e7, n6);
          };
          sa(c4, (e7) => {
            void 0 !== Sr(a5) && e7(d3);
          });
          var u2 = fo(c4, 2), v2 = (e7) => {
            var n6 = Hg(), t7 = uo(n6);
            ko(() => {
              var e8;
              return Xr(t7, "Column: ".concat(null !== (e8 = Sr(i4)) && void 0 !== e8 ? e8 : ""));
            }), Hr(e7, n6);
          };
          sa(u2, (e7) => {
            void 0 !== Sr(i4) && e7(v2);
          });
          var f = fo(u2, 2), p3 = (e7) => {
            var n6 = Qg(), t7 = uo(n6);
            ko(() => {
              var e8;
              return Xr(t7, "Selection: ".concat(null !== (e8 = Sr(s5)) && void 0 !== e8 ? e8 : "", " characters"));
            }), Hr(e7, n6);
          };
          sa(f, (e7) => {
            void 0 !== Sr(s5) && Sr(s5) > 0 && e7(p3);
          }), Hr(e6, l2), Nt();
        }(e5, {
          get editorState() {
            return Sr(_);
          }
        });
      };
      sa(t5, (e5) => {
        l() && e5(r3);
      });
      var a4 = fo(t5, 2), i3 = (e5) => {
        Rf(e5, {
          type: "error",
          get icon() {
            return faExclamationTriangle;
          },
          get message() {
            return Sr(Vn2), Or(() => Sr(Vn2).message);
          },
          get actions() {
            return Sr(o2);
          },
          onClick: Yn2,
          onClose: le
        });
      };
      sa(a4, (e5) => {
        Sr(Vn2) && e5(i3);
      });
      var s4 = fo(a4, 2), c3 = (e5) => {
        var n5 = Lt(() => [{
          icon: Vp,
          text: "Format",
          title: "Format JSON: add proper indentation and new lines (Ctrl+I)",
          onClick: xe
        }, {
          icon: faTimes,
          text: "No thanks",
          title: "Close this message",
          onClick: () => Xt(W2, false)
        }]);
        Rf(e5, {
          type: "success",
          message: "Do you want to format the JSON?",
          get actions() {
            return Sr(n5);
          },
          onClose: le
        });
      };
      sa(s4, (e5) => {
        Sr(Vn2), Sr(W2), Ar(ts), Sr(G2), Or(() => !Sr(Vn2) && Sr(W2) && ts(Sr(G2))) && e5(c3);
      }), Df(fo(s4, 2), {
        get validationErrors() {
          return Sr(V2);
        },
        selectError: qe
      }), Hr(e4, n4);
    };
    sa(c2, (e4) => {
      Sr(r2) || e4(d2);
    }), ko((e4) => n3 = Ca(a3, 1, "jse-contents svelte-xt61xw", null, n3, e4), [() => ({
      "jse-hidden": Sr(r2)
    })], Lt), Hr(e3, t4);
  }, ot3 = (e3) => {
    Hr(e3, om());
  };
  return sa(nt3, (e3) => {
    U2 ? e3(ot3, false) : e3(tt3);
  }), Ha(Xn2, (e3) => Xt(B, e3), () => Sr(B)), ko((e3) => Zn2 = Ca(Xn2, 1, "jse-text-mode svelte-xt61xw", null, Zn2, e3), [() => ({
    "no-main-menu": !s2()
  })], Lt), Hr(e2, Xn2), Va(n2, "focus", le), Va(n2, "collapse", de), Va(n2, "expand", ue), Va(n2, "patch", ge), Va(n2, "handlePatch", je), Va(n2, "openTransformModal", Se), Va(n2, "refresh", We2), Va(n2, "flush", jn), Va(n2, "validate", Hn2), Nt({
    focus: le,
    collapse: de,
    expand: ue,
    patch: ge,
    handlePatch: je,
    openTransformModal: Se,
    refresh: We2,
    flush: jn,
    validate: Hn2
  });
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-inline-value.svelte-h57m0p {\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  line-height: var(--jse-line-height, calc(1em + 4px));\n  border: none;\n  padding: 0 calc(0.5 * var(--jse-padding, 10px));\n  background: transparent;\n  color: inherit;\n  cursor: inherit;\n}\n.jse-inline-value.jse-highlight.svelte-h57m0p {\n  background-color: var(--jse-search-match-color, #ffe665);\n  outline: var(--jse-search-match-outline, none);\n}\n.jse-inline-value.jse-highlight.jse-active.svelte-h57m0p {\n  background-color: var(--jse-search-match-active-color, var(--jse-search-match-color, #ffe665));\n  outline: var(--jse-search-match-outline, 2px solid #e0be00);\n}');
var im = Lr('<button type="button"> </button>');
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-column-header.svelte-2i3vdx {\n  background: none;\n  border: none;\n  font-family: inherit;\n  font-size: inherit;\n  color: inherit;\n  display: flex;\n  gap: var(--jse-padding, 10px);\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px));\n  width: 100%;\n}\n.jse-column-header.svelte-2i3vdx:hover {\n  background: var(--jse-table-header-background-highlight, #e8e8e8);\n}\n.jse-column-header.svelte-2i3vdx:not(.jse-column-header.jse-readonly) {\n  cursor: pointer;\n}\n.jse-column-header.svelte-2i3vdx span.jse-column-sort-icon:where(.svelte-2i3vdx) {\n  height: 1em;\n}');
var sm = Lr('<span class="jse-column-sort-icon svelte-2i3vdx"><!></span>');
var lm = Lr('<button type="button"><span class="jse-column-name"> </span> <!></button>');
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-table-mode-welcome.svelte-17xl1jx {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n  align-items: center;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-table-mode-welcome.svelte-17xl1jx:last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-space.jse-before:where(.svelte-17xl1jx) {\n  flex: 1;\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) {\n  display: flex;\n  flex-direction: column;\n  gap: var(--jse-padding, 10px);\n  max-width: 400px;\n  margin: 2em var(--jse-padding, 10px);\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) .jse-nested-arrays-info:where(.svelte-17xl1jx) {\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) .jse-nested-property:where(.svelte-17xl1jx) {\n  display: flex;\n  align-items: center;\n  gap: var(--jse-padding, 10px);\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) .jse-nested-property:where(.svelte-17xl1jx) .jse-nested-property-path:where(.svelte-17xl1jx) {\n  flex: 1;\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) .jse-nested-property:where(.svelte-17xl1jx) .jse-nested-property-path:where(.svelte-17xl1jx) .jse-nested-property-count:where(.svelte-17xl1jx) {\n  opacity: 0.5;\n  white-space: nowrap;\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) button.jse-nested-array-action:where(.svelte-17xl1jx) {\n  text-align: left;\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) button.jse-nested-array-action:where(.svelte-17xl1jx):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-nested-arrays:where(.svelte-17xl1jx) button.jse-nested-array-action:where(.svelte-17xl1jx):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}\n.jse-table-mode-welcome.svelte-17xl1jx .jse-space.jse-after:where(.svelte-17xl1jx) {\n  flex: 2;\n}');
var cm = (e2, n2) => n2.onClick();
var dm = Lr("An empty document cannot be opened in table mode. You can go to tree mode instead, or paste\n        a JSON Array using <b>Ctrl+V</b>.", 1);
var um = (e2, n2, t3) => n2.openJSONEditorModal(Sr(t3));
var vm = (e2, n2, t3) => n2.extractPath(Sr(t3));
var fm = Lr('<button type="button" class="jse-nested-array-action svelte-17xl1jx">Extract</button>');
var pm = Lr('<div class="jse-nested-property svelte-17xl1jx"><div class="jse-nested-property-path svelte-17xl1jx"> <span class="jse-nested-property-count svelte-17xl1jx"> </span></div> <button type="button" class="jse-nested-array-action svelte-17xl1jx"> </button> <!></div>');
var hm = (e2, n2) => n2.onChangeMode(os.tree);
var gm = Lr('<div class="jse-table-mode-welcome svelte-17xl1jx" role="none"><div class="jse-space jse-before svelte-17xl1jx"></div> <div class="jse-nested-arrays svelte-17xl1jx"><div class="jse-nested-arrays-title"> </div> <div class="jse-nested-arrays-info svelte-17xl1jx"><!></div> <!> <button type="button" class="jse-nested-array-action svelte-17xl1jx">Switch to tree mode</button></div> <div class="jse-space jse-after svelte-17xl1jx"></div></div>');
function mm(e2, n2) {
  Tt(n2, true);
  var t3 = Ft(() => n2.json ? function(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, t4 = [];
    return function e4(o3, r3) {
      isJSONObject(o3) && r3.length < n3 && Object.keys(o3).forEach((n4) => {
        e4(o3[n4], r3.concat(n4));
      }), isJSONArray(o3) && t4.push(r3);
    }(e3, []), t4;
  }(n2.json).slice(0, 99).filter((e3) => e3.length > 0) : []), o2 = Ft(() => !isEmpty_default(Sr(t3))), r2 = Ft(() => void 0 === n2.json && ("" === n2.text || void 0 === n2.text)), a2 = Ft(() => Sr(o2) ? "Object with nested arrays" : Sr(r2) ? "An empty document" : isJSONObject(n2.json) ? "An object" : isJSONArray(n2.json) ? "An empty array" : "A ".concat(yi(n2.json, n2.parser)));
  var i2 = gm();
  i2.__click = [cm, n2];
  var s2 = fo(uo(i2), 2), l = uo(s2), c = uo(l), u = fo(l, 2), v = uo(u), f = (e3) => {
    Hr(e3, Vr("An object cannot be opened in table mode. You can open a nested array instead, or open the\n        document in tree mode."));
  }, p2 = (e3, t4) => {
    var o3 = (e4) => {
      Hr(e4, dm());
    }, i3 = (e4) => {
      var n3 = Vr();
      ko(() => {
        var e5;
        return Xr(n3, "".concat(null !== (e5 = Sr(a2)) && void 0 !== e5 ? e5 : "", " cannot be opened in table mode. You can open the document in tree mode instead."));
      }), Hr(e4, n3);
    };
    sa(e3, (e4) => {
      Sr(r2) && !n2.readOnly ? e4(o3) : e4(i3, false);
    }, t4);
  };
  sa(v, (e3) => {
    Sr(o2) ? e3(f) : e3(p2, false);
  });
  var h2 = fo(u, 2);
  da(h2, 17, () => Sr(t3), ca, (e3, t4) => {
    var o3 = pm(), r3 = Ft(() => function(e4) {
      return getIn(n2.json, e4).length;
    }(Sr(t4))), a3 = uo(o3), i3 = uo(a3), s3 = uo(fo(i3)), l2 = fo(a3, 2);
    l2.__click = [um, n2, t4];
    var c2 = uo(l2), u2 = fo(l2, 2), v2 = (e4) => {
      var o4 = fm();
      o4.__click = [vm, n2, t4], Hr(e4, o4);
    };
    sa(u2, (e4) => {
      n2.readOnly || e4(v2);
    }), ko((e4) => {
      var t5;
      Xr(i3, '"'.concat(null != e4 ? e4 : "", '" ')), Xr(s3, "(".concat(null !== (t5 = Sr(r3)) && void 0 !== t5 ? t5 : "", " ").concat(1 !== Sr(r3) ? "items" : "item", ")")), Xr(c2, n2.readOnly ? "View" : "Edit");
    }, [() => au(Sr(t4))]), Hr(e3, o3);
  }), fo(h2, 2).__click = [hm, n2], ko(() => Xr(c, Sr(a2))), Hr(e2, i2), Nt();
}
Jr(["click"]);
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-column-header.svelte-fzj761 {\n  background: none;\n  border: none;\n  font-family: inherit;\n  font-size: inherit;\n  color: inherit;\n  display: flex;\n  gap: var(--jse-padding, 10px);\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px));\n  width: 100%;\n}\n.jse-column-header.svelte-fzj761:hover {\n  background: var(--jse-table-header-background-highlight, #e8e8e8);\n}\n.jse-column-header.svelte-fzj761:not(.jse-column-header.jse-readonly) {\n  cursor: pointer;\n}');
var bm = Lr('<button type="button"><!></button>');
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-table-mode.svelte-u14cgx {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  background: var(--jse-background-color, #fff);\n  min-width: 0;\n  min-height: 0;\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: var(--jse-text-color, #4d4d4d);\n  line-height: var(--jse-line-height, calc(1em + 4px));\n}\n.jse-table-mode.no-main-menu.svelte-u14cgx {\n  border-top: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-table-mode.svelte-u14cgx .jse-search-box-container:where(.svelte-u14cgx) {\n  position: relative;\n  height: 0;\n  top: calc(var(--jse-line-height, calc(1em + 4px)) + 2 * var(--jse-padding, 10px));\n  margin-right: calc(var(--jse-padding, 10px) + 20px);\n  margin-left: var(--jse-padding, 10px);\n  text-align: right;\n  z-index: 3;\n}\n.jse-table-mode.svelte-u14cgx .jse-hidden-input-label:where(.svelte-u14cgx) {\n  position: fixed;\n  right: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n}\n.jse-table-mode.svelte-u14cgx .jse-hidden-input-label:where(.svelte-u14cgx) .jse-hidden-input:where(.svelte-u14cgx) {\n  width: 0;\n  height: 0;\n  padding: 0;\n  border: 0;\n  outline: none;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) {\n  flex: 1;\n  align-items: flex-start;\n  flex-direction: column;\n  display: flex;\n  overflow: auto;\n  overflow-anchor: none;\n  scrollbar-gutter: stable;\n  border-left: var(--jse-main-border, 1px solid #d7d7d7);\n  border-right: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx):last-child {\n  border-bottom: var(--jse-main-border, 1px solid #d7d7d7);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-invisible-start-section:where(.svelte-u14cgx) td:where(.svelte-u14cgx),\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-invisible-end-section:where(.svelte-u14cgx) td:where(.svelte-u14cgx) {\n  margin: 0;\n  padding: 0;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-search-box-background:where(.svelte-u14cgx) {\n  background: var(--jse-table-header-background, #f5f5f5);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-invisible-end-section:where(.svelte-u14cgx) td:where(.svelte-u14cgx) {\n  padding-bottom: var(--jse-padding, 10px);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx):hover {\n  background-color: var(--jse-table-row-odd-background, rgba(0, 0, 0, 0.05));\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell:where(.svelte-u14cgx) {\n  padding: 0 var(--jse-padding, 10px) 0 0;\n  vertical-align: top;\n  white-space: nowrap;\n  height: var(--jse-line-height, calc(1em + 4px));\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell.jse-table-cell-header:where(.svelte-u14cgx), .jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell.jse-table-cell-gutter:where(.svelte-u14cgx) {\n  font-weight: normal;\n  text-align: left;\n  color: var(--jse-text-readonly, #8d8d8d);\n  background: var(--jse-table-header-background, #f5f5f5);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell.jse-table-cell-header:where(.svelte-u14cgx) {\n  padding: 0;\n  position: sticky;\n  top: 0;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell.jse-table-cell-header:where(.svelte-u14cgx) .jse-table-root-error:where(.svelte-u14cgx) {\n  padding: calc(0.5 * var(--jse-padding, 10px)) var(--jse-padding, 10px) calc(0.5 * var(--jse-padding, 10px)) calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell.jse-table-cell-gutter:where(.svelte-u14cgx) {\n  padding: 0 var(--jse-padding, 10px) 0 calc(0.5 * var(--jse-padding, 10px));\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell:where(.svelte-u14cgx) .jse-value-outer:where(.svelte-u14cgx) {\n  display: inline-block;\n  cursor: var(--jse-contents-cursor, pointer);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell:where(.svelte-u14cgx) .jse-value-outer:where(.svelte-u14cgx):hover {\n  background: var(--jse-hover-background-color, rgba(0, 0, 0, 0.06));\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell:where(.svelte-u14cgx) .jse-value-outer.jse-selected-value:where(.svelte-u14cgx) {\n  background: var(--jse-selection-background-color, #d3d3d3);\n}\n.jse-table-mode.svelte-u14cgx .jse-contents:where(.svelte-u14cgx) table.jse-table-main:where(.svelte-u14cgx) .jse-table-row:where(.svelte-u14cgx) .jse-table-cell:where(.svelte-u14cgx) .jse-context-menu-anchor:where(.svelte-u14cgx) {\n  display: inline-flex;\n  position: relative;\n  vertical-align: top;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading:where(.svelte-u14cgx) {\n  align-items: unset;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading:where(.svelte-u14cgx) .jse-loading-space:where(.svelte-u14cgx) {\n  flex: 1;\n}\n.jse-table-mode.svelte-u14cgx .jse-contents.jse-contents-loading:where(.svelte-u14cgx) .jse-loading:where(.svelte-u14cgx) {\n  flex: 2;\n  text-align: center;\n  color: var(--jse-panel-color-readonly, #b2b2b2);\n  box-sizing: border-box;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n}');
var jm = Lr('<div class="jse-table-root-error svelte-u14cgx"><!></div>');
var xm = Lr('<th class="jse-table-cell jse-table-cell-header svelte-u14cgx"><!></th>');
var ym = Lr('<th class="jse-table-cell jse-table-cell-header svelte-u14cgx"><!></th>');
var wm = Lr('<th class="jse-table-cell jse-table-cell-gutter svelte-u14cgx"> <!></th>');
var km = Lr('<div class="jse-context-menu-anchor svelte-u14cgx"><!></div>');
var Sm = Lr('<td class="jse-table-cell svelte-u14cgx"><div><!><!></div> <!></td>');
var Cm = Lr('<td class="jse-table-cell svelte-u14cgx"></td>');
var zm = Lr('<tr class="jse-table-row svelte-u14cgx"><!><!><!></tr>');
var Om = Lr('<div class="jse-search-box-container svelte-u14cgx"><!></div> <div class="jse-contents svelte-u14cgx"><table class="jse-table-main svelte-u14cgx"><tbody><tr class="jse-table-row jse-table-row-header svelte-u14cgx"><th class="jse-table-cell jse-table-cell-header svelte-u14cgx"><!></th><!><!></tr><tr><td class="svelte-u14cgx"></td></tr><!><tr class="jse-table-invisible-end-section svelte-u14cgx"><td class="svelte-u14cgx"></td></tr></tbody></table></div> <!> <!> <!> <!>', 1);
var Mm = Lr("<!> <!>", 1);
var Em = Lr('<label class="jse-hidden-input-label svelte-u14cgx"><input type="text" tabindex="-1" class="jse-hidden-input svelte-u14cgx"/></label> <!>', 1);
var Am = Lr('<div class="jse-contents jse-contents-loading svelte-u14cgx"><div class="jse-loading-space svelte-u14cgx"></div> <div class="jse-loading svelte-u14cgx">loading...</div></div>');
var Rm = Lr('<div role="table"><!> <!></div> <!> <!>', 1);
function qm(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = Kt(void 0, true), a2 = Kt(void 0, true), s2 = ii("jsoneditor:TableMode"), {
    openAbsolutePopup: u,
    closeAbsolutePopup: v
  } = Pt("absolute-popup"), p2 = xf(), h2 = uniqueId_default(), m = uniqueId_default(), b = "undefined" == typeof window;
  s2("isSSR:", b);
  var j = ai(n2, "readOnly", 9), w = ai(n2, "externalContent", 9), S = ai(n2, "externalSelection", 9), C3 = ai(n2, "history", 9), z3 = ai(n2, "truncateTextSize", 9), M2 = ai(n2, "mainMenuBar", 9), E = ai(n2, "escapeControlCharacters", 9), A2 = ai(n2, "escapeUnicodeCharacters", 9), R = ai(n2, "flattenColumns", 9), P = ai(n2, "parser", 9), N2 = ai(n2, "parseMemoizeOne", 9), U2 = ai(n2, "validator", 9), D2 = ai(n2, "validationParser", 9), J = ai(n2, "indentation", 9), B = ai(n2, "onChange", 9), _ = ai(n2, "onChangeMode", 9), F2 = ai(n2, "onSelect", 9), L = ai(n2, "onUndo", 9), W2 = ai(n2, "onRedo", 9), V2 = ai(n2, "onRenderValue", 9), H2 = ai(n2, "onRenderMenu", 9), Q = ai(n2, "onRenderContextMenu", 9), Y2 = ai(n2, "onFocus", 9), K = ai(n2, "onBlur", 9), Z2 = ai(n2, "onSortModal", 9), X2 = ai(n2, "onTransformModal", 9), G2 = ai(n2, "onJSONEditorModal", 9), ee = Kt(void 0, true), ne = Kt(void 0, true), te = Kt(void 0, true), oe = Kt(void 0, true), re = Kt(void 0, true);
  Mf({
    onMount: ta,
    onDestroy: oa,
    getWindow: () => Os(Sr(ne)),
    hasFocus: () => Fe2 && document.hasFocus() || Ms(Sr(ne)),
    onFocus: () => {
      We2 = true, Y2() && Y2()();
    },
    onBlur: () => {
      We2 = false, K() && K()();
    }
  });
  var ae, ie3 = Kt(void 0, true), se = Kt(void 0, true), le = Kt(void 0, true), ve = Kt(void 0, true), xe = Kt(void 0, true), ye = Kt(void 0, true), we = Kt(false, true), ke = Kt(false, true);
  function Se(e3) {
    Xt(ye, (ae = e3) ? Fd(Sr(ie3), ae.items) : void 0);
  }
  function Re(e3) {
    return Pe.apply(this, arguments);
  }
  function Pe() {
    return (Pe = i(function* (e3) {
      Xt(Ge, void 0), yield xn(e3);
    })).apply(this, arguments);
  }
  function Ne() {
    Xt(we, false), Xt(ke, false), gn();
  }
  var Ie = Kt(1e4, true), De = Kt([], true), _e = Kt(void 0, true), Fe2 = false, We2 = false, Ve2 = Kt(false, true), $e = Kt({}, true), He = Kt(600, true), Qe = Kt(0, true), Ye = 18;
  function Ke(e3) {
    Xt(Ge, e3);
  }
  function Ze(e3) {
    Sr(Ge) && void 0 !== e3 && (existsIn(e3, fd(Sr(Ge))) && existsIn(e3, vd(Sr(Ge))) || (s2("clearing selection: path does not exist anymore", Sr(Ge)), Xt(Ge, void 0)));
  }
  var Xe = Kt(void 0 !== Sr(ie3) ? Zl({
    json: Sr(ie3)
  }) : void 0, true), Ge = Kt(Nc(S()) ? S() : void 0, true), en = Kt(void 0, true), nn = Kt(false, true);
  function tn(e3) {
    if (!j()) {
      s2("onSortByHeader", e3);
      var n3 = e3.sortDirection === ls.desc ? -1 : 1;
      un(Gp(Sr(ie3), [], e3.path, n3), (n4, t4) => ({
        state: t4,
        sortedColumn: e3
      }));
    }
  }
  ta(() => {
    Sr(Ge) && wn(vd(Sr(Ge)));
  });
  var on = Kt(void 0, true);
  function rn(e3) {
    if (void 0 !== e3.json || void 0 !== e3.text) {
      var n3 = void 0 !== Sr(ie3) && void 0 !== e3.json;
      C3().add({
        type: "tree",
        undo: {
          patch: n3 ? [{
            op: "replace",
            path: "",
            value: e3.json
          }] : void 0,
          json: e3.json,
          text: e3.text,
          documentState: e3.documentState,
          textIsRepaired: e3.textIsRepaired,
          selection: Yc(e3.selection),
          sortedColumn: e3.sortedColumn
        },
        redo: {
          patch: n3 ? [{
            op: "replace",
            path: "",
            value: Sr(ie3)
          }] : void 0,
          json: Sr(ie3),
          text: Sr(se),
          documentState: Sr(Xe),
          textIsRepaired: Sr(nn),
          selection: Yc(Sr(Ge)),
          sortedColumn: Sr(en)
        }
      });
    }
  }
  var an = Kt([], true), sn = memoizeOne(Cf);
  function ln(e3, n3, t4, o3) {
    yf(() => {
      var r2;
      try {
        r2 = sn(e3, n3, t4, o3);
      } catch (e4) {
        r2 = [{
          path: [],
          message: "Failed to validate: " + e4.message,
          severity: is.warning
        }];
      }
      isEqual_default(r2, Sr(an)) || (s2("validationErrors changed:", r2), Xt(an, r2));
    }, (e4) => s2("validationErrors updated in ".concat(e4, " ms")));
  }
  function cn() {
    return s2("validate"), Sr(le) ? {
      parseError: Sr(le),
      isRepairable: false
    } : (ln(Sr(ie3), U2(), P(), D2()), isEmpty_default(Sr(an)) ? void 0 : {
      validationErrors: Sr(an)
    });
  }
  function dn(e3, n3) {
    if (s2("patch", e3, n3), void 0 === Sr(ie3)) throw new Error("Cannot apply patch: no JSON");
    var t4 = Sr(ie3), o3 = {
      json: void 0,
      text: Sr(se),
      documentState: Sr(Xe),
      selection: Yc(Sr(Ge)),
      sortedColumn: Sr(en),
      textIsRepaired: Sr(nn)
    }, a3 = Ed(Sr(ie3), e3), i2 = cc(Sr(ie3), Sr(Xe), e3), l = Ah(Sr(en), e3, Sr(De)), c = "function" == typeof n3 ? n3(i2.json, i2.documentState, Sr(Ge)) : void 0;
    return Xt(ie3, void 0 !== (null == c ? void 0 : c.json) ? c.json : i2.json), Xt(Xe, void 0 !== (null == c ? void 0 : c.state) ? c.state : i2.documentState), Xt(Ge, void 0 !== (null == c ? void 0 : c.selection) ? c.selection : Sr(Ge)), Xt(en, void 0 !== (null == c ? void 0 : c.sortedColumn) ? c.sortedColumn : l), Xt(se, void 0), Xt(nn, false), Xt(ve, void 0), Xt(xe, void 0), Xt(le, void 0), C3().add({
      type: "tree",
      undo: r({
        patch: a3
      }, o3),
      redo: {
        patch: e3,
        json: void 0,
        text: void 0,
        documentState: Sr(Xe),
        selection: Yc(Sr(Ge)),
        sortedColumn: Sr(en),
        textIsRepaired: Sr(nn)
      }
    }), {
      json: Sr(ie3),
      previousJson: t4,
      undo: a3,
      redo: e3
    };
  }
  function un(e3, n3) {
    s2("handlePatch", e3, n3);
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, o3 = dn(e3, n3);
    return vn(t4, o3), o3;
  }
  function vn(e3, n3) {
    if ((void 0 !== e3.json || void 0 !== (null == e3 ? void 0 : e3.text)) && B()) {
      if (void 0 !== Sr(se)) {
        var t4 = {
          text: Sr(se),
          json: void 0
        };
        B()(t4, e3, {
          contentErrors: cn(),
          patchResult: n3
        });
      } else if (void 0 !== Sr(ie3)) {
        var o3 = {
          text: void 0,
          json: Sr(ie3)
        };
        B()(o3, e3, {
          contentErrors: cn(),
          patchResult: n3
        });
      }
    }
  }
  function fn(e3) {
    s2("pasted json as text", e3), Xt(ve, e3);
  }
  function pn(e3) {
    s2("pasted multiline text", {
      pastedText: e3
    }), Xt(xe, e3);
  }
  function hn(e3) {
    var n3 = parseInt(e3[0], 10), t4 = [String(n3 + 1), ...e3.slice(1)];
    return existsIn(Sr(ie3), t4) ? Xc(t4) : Xc(e3);
  }
  function gn() {
    s2("focus"), Sr(oe) && (Sr(oe).focus(), Sr(oe).select());
  }
  function mn(e3) {
    Xt(Qe, e3.target.scrollTop);
  }
  function bn() {
    Sr(Ge) || Xt(Ge, function() {
      if (isJSONArray(Sr(ie3)) && !isEmpty_default(Sr(ie3)) && !isEmpty_default(Sr(De))) return Xc(["0", ...Sr(De)[0]]);
    }());
  }
  function jn() {
    if (Sr(nn) && void 0 !== Sr(ie3)) {
      var e3 = {
        json: Sr(ie3),
        text: Sr(se)
      }, n3 = {
        json: Sr(ie3),
        documentState: Sr(Xe),
        selection: Sr(Ge),
        sortedColumn: Sr(en),
        text: Sr(se),
        textIsRepaired: Sr(nn)
      };
      Xt(se, void 0), Xt(nn, false), Ze(Sr(ie3)), rn(n3);
      vn(e3, void 0);
    }
    return {
      json: Sr(ie3),
      text: Sr(se)
    };
  }
  function xn(e3) {
    var {
      scrollToWhenVisible: n3 = true
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t4 = Sr(we) ? Cl : 0, o3 = Sh(e3, Sr(De), $e, Ye), r2 = o3 - Sr(Qe) + t4 + Ye, a3 = kn(e3);
    if (s2("scrollTo", {
      path: e3,
      top: o3,
      scrollTop: Sr(Qe),
      elem: a3
    }), !Sr(te)) return Promise.resolve();
    var i2 = Sr(te).getBoundingClientRect();
    if (a3 && !n3) {
      var l = a3.getBoundingClientRect();
      if (l.bottom > i2.top && l.top < i2.bottom) return Promise.resolve();
    }
    var c = -Math.max(t4 + 2 * Ye, i2.height / 4);
    return new Promise(a3 ? (n4) => {
      p2(a3, {
        container: Sr(te),
        offset: c,
        duration: 300,
        callback: () => {
          yn(e3), n4();
        }
      });
    } : (n4) => {
      p2(r2, {
        container: Sr(te),
        offset: c,
        duration: 300,
        callback: () => {
          wr(), yn(e3), n4();
        }
      });
    });
  }
  function yn(e3) {
    var n3 = kn(e3);
    if (n3 && Sr(te)) {
      var t4 = Sr(te).getBoundingClientRect(), o3 = n3.getBoundingClientRect();
      if (o3.right > t4.right) {
        var r2 = o3.right - t4.right;
        Zt(te, Sr(te).scrollLeft += r2);
      }
      if (o3.left < t4.left) {
        var a3 = t4.left - o3.left;
        Zt(te, Sr(te).scrollLeft -= a3);
      }
    }
  }
  function wn(e3) {
    !function(e4) {
      if (Sr(te)) {
        var {
          rowIndex: n3
        } = Ch(e4, Sr(De)), t4 = Sh(e4, Sr(De), $e, Ye), o3 = t4 + ($e[n3] || Ye), r2 = Ye, a3 = Sr(te).getBoundingClientRect(), i2 = Sr(Qe), s3 = Sr(Qe) + a3.height - r2;
        if (o3 > s3) {
          var l = o3 - s3;
          Zt(te, Sr(te).scrollTop += l);
        }
        if (t4 < i2) {
          var c = i2 - t4;
          Zt(te, Sr(te).scrollTop -= c);
        }
      }
    }(e3), yn(e3);
  }
  function kn(e3) {
    var n3, t4, o3 = Sr(De).find((n4) => Qc(e3.slice(1), n4)), r2 = o3 ? e3.slice(0, 1).concat(o3) : e3;
    return null !== (n3 = null === (t4 = Sr(te)) || void 0 === t4 ? void 0 : t4.querySelector('td[data-path="'.concat(Rs(r2), '"]'))) && void 0 !== n3 ? n3 : void 0;
  }
  function Sn(e3) {
    var n3, {
      anchor: t4,
      left: o3,
      top: r2,
      width: a3,
      height: i2,
      offsetTop: s3,
      offsetLeft: l,
      showTip: c
    } = e3, f = function(e4) {
      var {
        json: n4,
        documentState: t5,
        selection: o4,
        readOnly: r3,
        onEditValue: a4,
        onEditRow: i3,
        onToggleEnforceString: s4,
        onCut: l2,
        onCopy: c2,
        onPaste: u2,
        onRemove: v2,
        onDuplicateRow: f2,
        onInsertBeforeRow: p4,
        onInsertAfterRow: h4,
        onRemoveRow: g2
      } = e4, m2 = void 0 !== n4, b2 = !!o4, j2 = void 0 !== n4 && o4 ? getIn(n4, vd(o4)) : void 0, x = m2 && (Pc(o4) || Rc(o4) || qc(o4)), y = !r3 && m2 && void 0 !== o4 && $c(o4), w2 = y && !hi(j2), k = !r3 && x, S2 = void 0 !== o4 && bc(n4, t5, vd(o4));
      return [{
        type: "separator"
      }, {
        type: "row",
        items: [{
          type: "column",
          items: [{
            type: "label",
            text: "Table cell:"
          }, {
            type: "dropdown-button",
            main: {
              type: "button",
              onClick: () => a4(),
              icon: faPen,
              text: "Edit",
              title: "Edit the value (Double-click on the value)",
              disabled: !y
            },
            width: "11em",
            items: [{
              type: "button",
              icon: faPen,
              text: "Edit",
              title: "Edit the value (Double-click on the value)",
              onClick: () => a4(),
              disabled: !y
            }, {
              type: "button",
              icon: S2 ? faCheckSquare2 : faSquare2,
              text: "Enforce string",
              title: "Enforce keeping the value as string when it contains a numeric value",
              onClick: () => s4(),
              disabled: !w2
            }]
          }, {
            type: "dropdown-button",
            main: {
              type: "button",
              onClick: () => l2(true),
              icon: faCut,
              text: "Cut",
              title: "Cut selected contents, formatted with indentation (Ctrl+X)",
              disabled: !k
            },
            width: "10em",
            items: [{
              type: "button",
              icon: faCut,
              text: "Cut formatted",
              title: "Cut selected contents, formatted with indentation (Ctrl+X)",
              onClick: () => l2(true),
              disabled: r3 || !x
            }, {
              type: "button",
              icon: faCut,
              text: "Cut compacted",
              title: "Cut selected contents, without indentation (Ctrl+Shift+X)",
              onClick: () => l2(false),
              disabled: r3 || !x
            }]
          }, {
            type: "dropdown-button",
            main: {
              type: "button",
              onClick: () => c2(true),
              icon: faCopy,
              text: "Copy",
              title: "Copy selected contents, formatted with indentation (Ctrl+C)",
              disabled: !x
            },
            width: "12em",
            items: [{
              type: "button",
              icon: faCopy,
              text: "Copy formatted",
              title: "Copy selected contents, formatted with indentation (Ctrl+C)",
              onClick: () => c2(false),
              disabled: !x
            }, {
              type: "button",
              icon: faCopy,
              text: "Copy compacted",
              title: "Copy selected contents, without indentation (Ctrl+Shift+C)",
              onClick: () => c2(false),
              disabled: !x
            }]
          }, {
            type: "button",
            onClick: () => u2(),
            icon: faPaste,
            text: "Paste",
            title: "Paste clipboard contents (Ctrl+V)",
            disabled: r3 || !b2
          }, {
            type: "button",
            onClick: () => v2(),
            icon: faTrashCan,
            text: "Remove",
            title: "Remove selected contents (Delete)",
            disabled: r3 || !x
          }]
        }, {
          type: "column",
          items: [{
            type: "label",
            text: "Table row:"
          }, {
            type: "button",
            onClick: () => i3(),
            icon: faPen,
            text: "Edit row",
            title: "Edit the current row",
            disabled: r3 || !b2 || !m2
          }, {
            type: "button",
            onClick: () => f2(),
            icon: faClone,
            text: "Duplicate row",
            title: "Duplicate the current row (Ctrl+D)",
            disabled: r3 || !b2 || !m2
          }, {
            type: "button",
            onClick: () => p4(),
            icon: faPlus,
            text: "Insert before",
            title: "Insert a row before the current row",
            disabled: r3 || !b2 || !m2
          }, {
            type: "button",
            onClick: () => h4(),
            icon: faPlus,
            text: "Insert after",
            title: "Insert a row after the current row",
            disabled: r3 || !b2 || !m2
          }, {
            type: "button",
            onClick: () => g2(),
            icon: faTrashCan,
            text: "Remove row",
            title: "Remove current row",
            disabled: r3 || !b2 || !m2
          }]
        }]
      }];
    }({
      json: Sr(ie3),
      documentState: Sr(Xe),
      selection: Sr(Ge),
      readOnly: j(),
      onEditValue: On,
      onEditRow: Mn,
      onToggleEnforceString: En,
      onCut: Jn,
      onCopy: _n,
      onPaste: qn,
      onRemove: Ln2,
      onDuplicateRow: Vn2,
      onInsertBeforeRow: $n2,
      onInsertAfterRow: Hn2,
      onRemoveRow: Qn2
    }), p3 = null !== (n3 = Q()(f)) && void 0 !== n3 ? n3 : f;
    if (false !== p3) {
      var h3 = {
        left: o3,
        top: r2,
        offsetTop: s3,
        offsetLeft: l,
        width: a3,
        height: i2,
        anchor: t4,
        closeOnOuterClick: true,
        onClose: () => {
          Fe2 = false, gn();
        }
      };
      Fe2 = true;
      var g = u(rg, {
        tip: c ? "Tip: you can open this context menu via right-click or with Ctrl+Q" : void 0,
        items: p3,
        onRequestClose() {
          v(g), gn();
        }
      }, h3);
    }
  }
  function Cn(e3) {
    if (!rd(Sr(Ge))) if (e3 && (e3.stopPropagation(), e3.preventDefault()), e3 && "contextmenu" === e3.type && e3.target !== Sr(oe)) Sn({
      left: e3.clientX,
      top: e3.clientY,
      width: Sl,
      height: kl,
      showTip: false
    });
    else {
      var n3, t4 = null === (n3 = Sr(te)) || void 0 === n3 ? void 0 : n3.querySelector(".jse-table-cell.jse-selected-value");
      if (t4) Sn({
        anchor: t4,
        offsetTop: 2,
        width: Sl,
        height: kl,
        showTip: false
      });
      else {
        var o3, r2 = null === (o3 = Sr(te)) || void 0 === o3 ? void 0 : o3.getBoundingClientRect();
        r2 && Sn({
          top: r2.top + 2,
          left: r2.left + 2,
          width: Sl,
          height: kl,
          showTip: false
        });
      }
    }
  }
  function zn(e3) {
    Sn({
      anchor: Es(e3.target, "BUTTON"),
      offsetTop: 0,
      width: Sl,
      height: kl,
      showTip: true
    });
  }
  function On() {
    if (!j() && Sr(Ge)) {
      var e3 = vd(Sr(Ge));
      hi(getIn(Sr(ie3), e3)) ? tt3(e3) : Xt(Ge, Xc(e3));
    }
  }
  function Mn() {
    !j() && Sr(Ge) && tt3(vd(Sr(Ge)).slice(0, 1));
  }
  function En() {
    if (!j() && qc(Sr(Ge))) {
      var e3 = Sr(Ge).path, n3 = compileJSONPointer(e3), t4 = getIn(Sr(ie3), e3), o3 = !bc(Sr(ie3), Sr(Xe), e3), r2 = o3 ? String(t4) : Si(String(t4), P());
      s2("handleToggleEnforceString", {
        enforceString: o3,
        value: t4,
        updatedValue: r2
      }), un([{
        op: "replace",
        path: n3,
        value: r2
      }], (n4, t5) => ({
        state: fc(Sr(ie3), t5, e3, {
          type: "value",
          enforceString: o3
        })
      }));
    }
  }
  function An() {
    return Rn.apply(this, arguments);
  }
  function Rn() {
    return (Rn = i(function* () {
      if (s2("apply pasted json", Sr(ve)), Sr(ve)) {
        var {
          onPasteAsJson: e3
        } = Sr(ve);
        e3(), setTimeout(gn);
      }
    })).apply(this, arguments);
  }
  function qn() {
    return Pn.apply(this, arguments);
  }
  function Pn() {
    return (Pn = i(function* () {
      try {
        Zn2(yield navigator.clipboard.readText());
      } catch (e3) {
        console.error(e3), Xt(Ve2, true);
      }
    })).apply(this, arguments);
  }
  function Tn() {
    return Nn.apply(this, arguments);
  }
  function Nn() {
    return (Nn = i(function* () {
      s2("apply pasted multiline text", Sr(xe)), Sr(xe) && (Zn2(JSON.stringify(Sr(xe))), setTimeout(gn));
    })).apply(this, arguments);
  }
  function In() {
    s2("clear pasted json"), Xt(ve, void 0), gn();
  }
  function Un() {
    s2("clear pasted multiline text"), Xt(xe, void 0), gn();
  }
  function Dn() {
    _()(os.text);
  }
  function Jn(e3) {
    return Bn.apply(this, arguments);
  }
  function Bn() {
    return (Bn = i(function* (e3) {
      yield qh({
        json: Sr(ie3),
        selection: Sr(Ge),
        indentation: e3 ? J() : void 0,
        readOnly: j(),
        parser: P(),
        onPatch: un
      });
    })).apply(this, arguments);
  }
  function _n() {
    return Fn2.apply(this, arguments);
  }
  function Fn2() {
    return Fn2 = i(function* () {
      var e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      void 0 !== Sr(ie3) && (yield Th({
        json: Sr(ie3),
        selection: Sr(Ge),
        indentation: e3 ? J() : void 0,
        parser: P()
      }));
    }), Fn2.apply(this, arguments);
  }
  function Ln2() {
    Uh({
      json: Sr(ie3),
      text: Sr(se),
      selection: Sr(Ge),
      keepSelection: true,
      readOnly: j(),
      onChange: B(),
      onPatch: un
    });
  }
  function Wn2(e3) {
    j() || (s2("extract", {
      path: e3
    }), un(kd(Sr(ie3), Xc(e3))));
  }
  function Vn2() {
    !function(e3) {
      var {
        json: n3,
        selection: t4,
        columns: o3,
        readOnly: r2,
        onPatch: a3
      } = e3;
      if (!r2 && void 0 !== n3 && t4 && ad(t4)) {
        var {
          rowIndex: i2,
          columnIndex: s3
        } = Ch(vd(t4), o3);
        Rh("duplicate row", {
          rowIndex: i2
        });
        var l = [String(i2)];
        a3(wd(n3, [l]), (e4, t5) => ({
          state: t5,
          selection: Xc(zh({
            rowIndex: i2 < n3.length ? i2 + 1 : i2,
            columnIndex: s3
          }, o3))
        }));
      }
    }({
      json: Sr(ie3),
      selection: Sr(Ge),
      columns: Sr(De),
      readOnly: j(),
      onPatch: un
    });
  }
  function $n2() {
    !function(e3) {
      var {
        json: n3,
        selection: t4,
        columns: o3,
        readOnly: r2,
        onPatch: a3
      } = e3;
      if (!r2 && void 0 !== n3 && t4 && ad(t4)) {
        var {
          rowIndex: i2
        } = Ch(vd(t4), o3);
        Rh("insert before row", {
          rowIndex: i2
        }), a3(jd(n3, [String(i2)], [{
          key: "",
          value: isJSONObject(n3[0]) ? {} : ""
        }]));
      }
    }({
      json: Sr(ie3),
      selection: Sr(Ge),
      columns: Sr(De),
      readOnly: j(),
      onPatch: un
    });
  }
  function Hn2() {
    !function(e3) {
      var {
        json: n3,
        selection: t4,
        columns: o3,
        readOnly: r2,
        onPatch: a3
      } = e3;
      if (!r2 && void 0 !== n3 && t4 && ad(t4)) {
        var {
          rowIndex: i2,
          columnIndex: s3
        } = Ch(vd(t4), o3);
        Rh("insert after row", {
          rowIndex: i2
        });
        var l = i2 + 1, c = [String(l)], d = [{
          key: "",
          value: isJSONObject(n3[0]) ? {} : ""
        }];
        a3(l < n3.length ? jd(n3, c, d) : xd(n3, [], d), (e4, n4) => ({
          state: n4,
          selection: Xc(zh({
            rowIndex: l,
            columnIndex: s3
          }, o3))
        }));
      }
    }({
      json: Sr(ie3),
      selection: Sr(Ge),
      columns: Sr(De),
      readOnly: j(),
      onPatch: un
    });
  }
  function Qn2() {
    !function(e3) {
      var {
        json: n3,
        selection: t4,
        columns: o3,
        readOnly: r2,
        onPatch: a3
      } = e3;
      if (!r2 && void 0 !== n3 && t4 && ad(t4)) {
        var {
          rowIndex: i2,
          columnIndex: s3
        } = Ch(vd(t4), o3);
        Rh("remove row", {
          rowIndex: i2
        }), a3(Cd([[String(i2)]]), (e4, n4) => {
          var t5 = i2 < e4.length ? i2 : i2 > 0 ? i2 - 1 : void 0, r3 = void 0 !== t5 ? Xc(zh({
            rowIndex: t5,
            columnIndex: s3
          }, o3)) : void 0;
          return Rh("remove row new selection", {
            rowIndex: i2,
            newRowIndex: t5,
            newSelection: r3
          }), {
            state: n4,
            selection: r3
          };
        });
      }
    }({
      json: Sr(ie3),
      selection: Sr(Ge),
      columns: Sr(De),
      readOnly: j(),
      onPatch: un
    });
  }
  function Yn2() {
    return (Yn2 = i(function* (e3) {
      yield Jh({
        char: e3,
        selectInside: false,
        json: Sr(ie3),
        selection: Sr(Ge),
        readOnly: j(),
        parser: P(),
        onPatch: un,
        onReplaceJson: Xn2,
        onSelect: Ke
      });
    })).apply(this, arguments);
  }
  function Kn2(e3) {
    var n3;
    e3.preventDefault(), Zn2(null === (n3 = e3.clipboardData) || void 0 === n3 ? void 0 : n3.getData("text/plain"));
  }
  function Zn2(e3) {
    void 0 !== e3 && Ih({
      clipboardText: e3,
      json: Sr(ie3),
      selection: Sr(Ge),
      readOnly: j(),
      parser: P(),
      onPatch: un,
      onChangeText: Gn2,
      onPasteMultilineText: pn,
      openRepairModal: ot3
    });
  }
  function Xn2(e3, n3) {
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, o3 = {
      json: Sr(ie3),
      documentState: Sr(Xe),
      selection: Sr(Ge),
      sortedColumn: Sr(en),
      text: Sr(se),
      textIsRepaired: Sr(nn)
    }, r2 = tc(e3, Sr(Xe)), a3 = "function" == typeof n3 ? n3(e3, r2, Sr(Ge)) : void 0;
    Xt(ie3, void 0 !== (null == a3 ? void 0 : a3.json) ? a3.json : e3), Xt(Xe, void 0 !== (null == a3 ? void 0 : a3.state) ? a3.state : r2), Xt(Ge, void 0 !== (null == a3 ? void 0 : a3.selection) ? a3.selection : Sr(Ge)), Xt(en, void 0), Xt(se, void 0), Xt(nn, false), Xt(le, void 0), Ze(Sr(ie3)), rn(o3);
    vn(t4, void 0);
  }
  function Gn2(e3, n3) {
    s2("handleChangeText");
    var t4 = {
      json: Sr(ie3),
      text: Sr(se)
    }, o3 = {
      json: Sr(ie3),
      documentState: Sr(Xe),
      selection: Sr(Ge),
      sortedColumn: Sr(en),
      text: Sr(se),
      textIsRepaired: Sr(nn)
    };
    try {
      Xt(ie3, N2()(e3)), Xt(Xe, tc(Sr(ie3), Sr(Xe))), Xt(se, void 0), Xt(nn, false), Xt(le, void 0);
    } catch (n4) {
      try {
        Xt(ie3, N2()(jsonrepair(e3))), Xt(Xe, tc(Sr(ie3), Sr(Xe))), Xt(se, e3), Xt(nn, true), Xt(le, void 0);
      } catch (t5) {
        Xt(ie3, void 0), Xt(Xe, void 0), Xt(se, e3), Xt(nn, false), Xt(le, "" !== Sr(se) ? _i(Sr(se), n4.message || String(n4)) : void 0);
      }
    }
    if ("function" == typeof n3) {
      var r2 = n3(Sr(ie3), Sr(Xe), Sr(Ge));
      Xt(ie3, void 0 !== (null == r2 ? void 0 : r2.json) ? r2.json : Sr(ie3)), Xt(Xe, void 0 !== (null == r2 ? void 0 : r2.state) ? r2.state : Sr(Xe)), Xt(Ge, void 0 !== (null == r2 ? void 0 : r2.selection) ? r2.selection : Sr(Ge));
    }
    Ze(Sr(ie3)), rn(o3);
    vn(t4, void 0);
  }
  function et3(e3) {
    s2("select validation error", e3), Xt(Ge, Xc(e3.path)), xn(e3.path);
  }
  function nt3(e3) {
    if (void 0 !== Sr(ie3)) {
      var {
        id: n3,
        onTransform: t4,
        onClose: o3
      } = e3, r2 = e3.rootPath || [];
      Fe2 = true, X2()({
        id: n3 || m,
        json: Sr(ie3),
        rootPath: r2 || [],
        onTransform: (e4) => {
          t4 ? t4({
            operations: e4,
            json: Sr(ie3),
            transformedJson: immutableJSONPatch(Sr(ie3), e4)
          }) : (s2("onTransform", r2, e4), un(e4));
        },
        onClose: () => {
          Fe2 = false, setTimeout(gn), o3 && o3();
        }
      });
    }
  }
  function tt3(e3) {
    s2("openJSONEditorModal", {
      path: e3
    }), Fe2 = true, G2()({
      content: {
        json: getIn(Sr(ie3), e3)
      },
      path: e3,
      onPatch: un,
      onClose: () => {
        Fe2 = false, setTimeout(gn);
      }
    });
  }
  function ot3(e3, n3) {
    Xt(re, {
      text: e3,
      onParse: (e4) => Di(e4, (e5) => Ii(e5, P())),
      onRepair: Ji,
      onApply: n3,
      onClose: gn
    });
  }
  function rt3() {
    !function(e3) {
      j() || void 0 === Sr(ie3) || (Fe2 = true, Z2()({
        id: h2,
        json: Sr(ie3),
        rootPath: e3,
        onSort: (n3) => {
          var {
            operations: t4,
            itemPath: o3,
            direction: r2
          } = n3;
          s2("onSort", t4, e3, o3, r2), un(t4, (e4, n4) => ({
            state: n4,
            sortedColumn: {
              path: o3,
              sortDirection: -1 === r2 ? ls.desc : ls.asc
            }
          }));
        },
        onClose: () => {
          Fe2 = false, setTimeout(gn);
        }
      }));
    }([]);
  }
  function at4() {
    nt3({
      rootPath: []
    });
  }
  function it3(e3) {
    s2("openFind", {
      findAndReplace: e3
    }), Xt(we, false), Xt(ke, false), wr(), Xt(we, true), Xt(ke, e3);
  }
  function st3() {
    if (!j() && C3().canUndo) {
      var e3 = C3().undo();
      if (Ql(e3)) {
        var n3 = {
          json: Sr(ie3),
          text: Sr(se)
        };
        Xt(ie3, e3.undo.patch ? immutableJSONPatch(Sr(ie3), e3.undo.patch) : e3.undo.json), Xt(Xe, e3.undo.documentState), Xt(Ge, e3.undo.selection), Xt(en, e3.undo.sortedColumn), Xt(se, e3.undo.text), Xt(nn, e3.undo.textIsRepaired), Xt(le, void 0), s2("undo", {
          item: e3,
          json: Sr(ie3)
        }), vn(n3, e3.undo.patch && e3.redo.patch ? {
          json: Sr(ie3),
          previousJson: n3.json,
          redo: e3.undo.patch,
          undo: e3.redo.patch
        } : void 0), gn(), Sr(Ge) && xn(vd(Sr(Ge)), {
          scrollToWhenVisible: false
        });
      } else L()(e3);
    }
  }
  function lt4() {
    if (!j() && C3().canRedo) {
      var e3 = C3().redo();
      if (Ql(e3)) {
        var n3 = {
          json: Sr(ie3),
          text: Sr(se)
        };
        Xt(ie3, e3.redo.patch ? immutableJSONPatch(Sr(ie3), e3.redo.patch) : e3.redo.json), Xt(Xe, e3.redo.documentState), Xt(Ge, e3.redo.selection), Xt(en, e3.redo.sortedColumn), Xt(se, e3.redo.text), Xt(nn, e3.redo.textIsRepaired), Xt(le, void 0), s2("redo", {
          item: e3,
          json: Sr(ie3)
        }), vn(n3, e3.undo.patch && e3.redo.patch ? {
          json: Sr(ie3),
          previousJson: n3.json,
          redo: e3.redo.patch,
          undo: e3.undo.patch
        } : void 0), gn(), Sr(Ge) && xn(vd(Sr(Ge)), {
          scrollToWhenVisible: false
        });
      } else W2()(e3);
    }
  }
  function ct3(e3) {
    Xt(He, e3.getBoundingClientRect().height);
  }
  xo(() => (Ar(E()), Ar(A2())), () => {
    Xt(ee, us({
      escapeControlCharacters: E(),
      escapeUnicodeCharacters: A2()
    }));
  }), xo(() => Sr(we), () => {
    !function(e3) {
      if (Sr(te)) {
        var n3 = e3 ? Cl : -100;
        Sr(te).scrollTo({
          top: Zt(te, Sr(te).scrollTop += n3),
          left: Sr(te).scrollLeft
        });
      }
    }(Sr(we));
  }), xo(() => Ar(w()), () => {
    !function(e3) {
      var n3 = {
        json: Sr(ie3)
      }, t4 = Vi(e3) ? e3.text !== Sr(se) : !isEqual_default(n3.json, e3.json);
      if (s2("update external content", {
        isChanged: t4
      }), t4) {
        var o3 = {
          json: Sr(ie3),
          documentState: Sr(Xe),
          selection: Sr(Ge),
          sortedColumn: Sr(en),
          text: Sr(se),
          textIsRepaired: Sr(nn)
        };
        if (Vi(e3)) try {
          Xt(ie3, N2()(e3.text)), Xt(Xe, tc(Sr(ie3), Sr(Xe))), Xt(se, e3.text), Xt(nn, false), Xt(le, void 0);
        } catch (n4) {
          try {
            Xt(ie3, N2()(jsonrepair(e3.text))), Xt(Xe, tc(Sr(ie3), Sr(Xe))), Xt(se, e3.text), Xt(nn, true), Xt(le, void 0);
          } catch (t5) {
            Xt(ie3, void 0), Xt(Xe, void 0), Xt(se, e3.text), Xt(nn, false), Xt(le, "" !== Sr(se) ? _i(Sr(se), n4.message || String(n4)) : void 0);
          }
        }
        else Xt(ie3, e3.json), Xt(Xe, tc(Sr(ie3), Sr(Xe))), Xt(se, void 0), Xt(nn, false), Xt(le, void 0);
        Ze(Sr(ie3)), Xt(en, void 0), rn(o3);
      }
    }(w());
  }), xo(() => Ar(S()), () => {
    !function(e3) {
      isEqual_default(Sr(Ge), e3) || (s2("applyExternalSelection", {
        selection: Sr(Ge),
        externalSelection: e3
      }), Nc(e3) && Xt(Ge, e3));
    }(S());
  }), xo(() => (Sr(De), Sr(ie3), Ar(R()), Sr(Ie)), () => {
    Xt(De, isJSONArray(Sr(ie3)) ? function(e3, n3) {
      var t4 = new Set(n3.map(compileJSONPointer)), o3 = new Set(e3.map(compileJSONPointer));
      for (var r2 of t4) o3.has(r2) || t4.delete(r2);
      for (var a3 of o3) t4.has(a3) || t4.add(a3);
      return [...t4].map(parseJSONPointer);
    }(xh(Sr(ie3), R(), Sr(Ie)), Sr(De)) : []);
  }), xo(() => (Sr(ie3), Sr(De)), () => {
    Xt(_e, !(!Sr(ie3) || isEmpty_default(Sr(De))));
  }), xo(() => (Sr(ie3), Sr(Ie)), () => {
    Xt(t3, Array.isArray(Sr(ie3)) && Sr(ie3).length > Sr(Ie));
  }), xo(() => (Sr(Qe), Sr(He), Sr(ie3), Sr(we), Cl), () => {
    Xt(o2, kh(Sr(Qe), Sr(He), Sr(ie3), $e, Ye, Sr(we) ? Cl : 0));
  }), xo(() => Sr(ie3), () => {
    Sr(ie3), Sr(te) && Sr(te).scrollTo({
      top: Sr(te).scrollTop,
      left: Sr(te).scrollLeft
    });
  }), xo(() => Sr(Ge), () => {
    var e3;
    e3 = Sr(Ge), isEqual_default(e3, S()) || (s2("onSelect", e3), F2()(e3));
  }), xo(() => (Ar(j()), Ar(z3()), Ar(P()), Sr(ee), Sr(ie3), Sr(Xe), Ar(V2())), () => {
    Xt(on, {
      mode: os.table,
      readOnly: j(),
      truncateTextSize: z3(),
      parser: P(),
      normalization: Sr(ee),
      getJson: () => Sr(ie3),
      getDocumentState: () => Sr(Xe),
      findElement: kn,
      findNextInside: hn,
      focus: gn,
      onPatch: (e3, n3) => un(function(e4, n4) {
        return e4.flatMap((e5) => {
          if (isJSONPatchReplace(e5)) {
            var t4 = parseJSONPointer(e5.path);
            if (t4.length > 0) {
              for (var o3 = [e5], r2 = initial_default(t4); r2.length > 0 && !existsIn(n4, r2); ) o3.unshift({
                op: "add",
                path: compileJSONPointer(r2),
                value: {}
              }), r2 = initial_default(r2);
              return o3;
            }
          }
          return e5;
        });
      }(e3, Sr(ie3)), n3),
      onSelect: Ke,
      onFind: it3,
      onPasteJson: fn,
      onRenderValue: V2()
    });
  }), xo(() => (Sr(ie3), Ar(U2()), Ar(P()), Ar(D2())), () => {
    ln(Sr(ie3), U2(), P(), D2());
  }), xo(() => (Sr(an), Sr(De)), () => {
    Xt(a2, Oh(Sr(an), Sr(De)));
  }), yo(), Ka(true);
  var dt3 = Rm();
  Dr("mousedown", oo, function(e3) {
    !Cs(e3.target, (e4) => e4 === Sr(ne)) && rd(Sr(Ge)) && (s2("click outside the editor, exit edit mode"), Xt(Ge, Yc(Sr(Ge))), We2 && Sr(oe) && (Sr(oe).focus(), Sr(oe).blur()), s2("blur (outside editor)"), Sr(oe) && Sr(oe).blur());
  });
  var ut3, vt2 = vo(dt3), ft3 = uo(vt2), pt3 = (e3) => {
    !function(e4, n3) {
      Tt(n3, false);
      var t4 = ai(n3, "containsValidArray", 9), o3 = ai(n3, "readOnly", 9), r2 = ai(n3, "showSearch", 13, false), a3 = ai(n3, "history", 9), i2 = ai(n3, "onSort", 9), s3 = ai(n3, "onTransform", 9), l = ai(n3, "onContextMenu", 9), c = ai(n3, "onUndo", 9), d = ai(n3, "onRedo", 9), u2 = ai(n3, "onRenderMenu", 9);
      function v2() {
        r2(!r2());
      }
      var f = Kt(void 0, true), p3 = Kt(void 0, true);
      xo(() => (Ar(o3()), Ar(i2()), Ar(t4()), Ar(s3()), Ar(l()), Ar(c()), Ar(a3()), Ar(d())), () => {
        Xt(f, o3() ? [{
          type: "space"
        }] : [{
          type: "button",
          icon: faSortAmountDownAlt,
          title: "Sort",
          className: "jse-sort",
          onClick: i2(),
          disabled: o3() || !t4()
        }, {
          type: "button",
          icon: faFilter,
          title: "Transform contents (filter, sort, project)",
          className: "jse-transform",
          onClick: s3(),
          disabled: o3() || !t4()
        }, {
          type: "button",
          icon: faSearch,
          title: "Search (Ctrl+F)",
          className: "jse-search",
          onClick: v2,
          disabled: !t4()
        }, {
          type: "button",
          icon: faEllipsisV,
          title: ml,
          className: "jse-contextmenu",
          onClick: l()
        }, {
          type: "separator"
        }, {
          type: "button",
          icon: faUndo,
          title: "Undo (Ctrl+Z)",
          className: "jse-undo",
          onClick: c(),
          disabled: !a3().canUndo
        }, {
          type: "button",
          icon: faRedo,
          title: "Redo (Ctrl+Shift+Z)",
          className: "jse-redo",
          onClick: d(),
          disabled: !a3().canRedo
        }, {
          type: "space"
        }]);
      }), xo(() => (Ar(u2()), Sr(f)), () => {
        Xt(p3, u2()(Sr(f)) || Sr(f));
      }), yo(), Ka(true), Qf(e4, {
        get items() {
          return Sr(p3);
        }
      }), Nt();
    }(e3, {
      get containsValidArray() {
        return Sr(_e);
      },
      get readOnly() {
        return j();
      },
      get history() {
        return C3();
      },
      onSort: rt3,
      onTransform: at4,
      onUndo: st3,
      onRedo: lt4,
      onContextMenu: zn,
      get onRenderMenu() {
        return H2();
      },
      get showSearch() {
        return Sr(we);
      },
      set showSearch(e4) {
        Xt(we, e4);
      },
      $$legacy: true
    });
  };
  sa(ft3, (e3) => {
    M2() && e3(pt3);
  });
  var ht3 = fo(ft3, 2), gt4 = (e3) => {
    var n3 = Em(), r2 = vo(n3), i2 = uo(r2);
    i2.readOnly = true, Ha(i2, (e4) => Xt(oe, e4), () => Sr(oe));
    var s3 = fo(r2, 2), l = (e4) => {
      var n4 = Om(), r3 = vo(n4);
      bh(uo(r3), {
        get json() {
          return Sr(ie3);
        },
        get documentState() {
          return Sr(Xe);
        },
        get parser() {
          return P();
        },
        get showSearch() {
          return Sr(we);
        },
        get showReplace() {
          return Sr(ke);
        },
        get readOnly() {
          return j();
        },
        get columns() {
          return Sr(De);
        },
        onSearch: Se,
        onFocus: Re,
        onPatch: un,
        onClose: Ne
      });
      var i3 = fo(r3, 2), s4 = uo(i3), l2 = uo(s4), c2 = uo(l2), u2 = uo(c2), v2 = uo(u2), f = (e5) => {
        var n5 = $r(), t4 = Lt(() => (Ar(Mh), Sr(a2), Or(() => {
          var e6;
          return Mh([], null === (e6 = Sr(a2)) || void 0 === e6 ? void 0 : e6.root);
        }))), o3 = vo(n5), r4 = (e6) => {
          var n6 = jm();
          up(uo(n6), {
            get validationError() {
              return Sr(t4);
            },
            get onExpand() {
              return Vg;
            }
          }), Hr(e6, n6);
        };
        sa(o3, (e6) => {
          Sr(t4) && e6(r4);
        }), Hr(e5, n5);
      };
      sa(v2, (e5) => {
        Ar(isEmpty_default), Sr(a2), Or(() => {
          var e6;
          return !isEmpty_default(null === (e6 = Sr(a2)) || void 0 === e6 ? void 0 : e6.root);
        }) && e5(f);
      });
      var p3 = fo(u2);
      da(p3, 1, () => Sr(De), ca, (e5, n5) => {
        var t4 = xm();
        !function(e6, n6) {
          Tt(n6, false);
          var t5 = Kt(void 0, true), o3 = Kt(void 0, true), r4 = Kt(void 0, true), a3 = ai(n6, "path", 9), i4 = ai(n6, "sortedColumn", 9), s5 = ai(n6, "readOnly", 9), l3 = ai(n6, "onSort", 9);
          xo(() => (Ar(a3()), au), () => {
            Xt(t5, isEmpty_default(a3()) ? "values" : au(a3()));
          }), xo(() => (Ar(i4()), Ar(a3())), () => {
            var e7;
            Xt(o3, i4() && isEqual_default(a3(), null === (e7 = i4()) || void 0 === e7 ? void 0 : e7.path) ? i4().sortDirection : void 0);
          }), xo(() => (Sr(o3), zl), () => {
            Xt(r4, Sr(o3) ? zl[Sr(o3)] : void 0);
          }), yo(), Ka(true);
          var c3, d = lm(), u3 = uo(d), v3 = uo(u3), f2 = fo(u3, 2), p4 = (e7) => {
            var n7 = sm(), t6 = uo(n7), a4 = Lt(() => (Sr(o3), Ar(ls), Ar(faCaretDown), Ar(faCaretUp), Or(() => Sr(o3) === ls.asc ? faCaretDown : faCaretUp)));
            nl(t6, {
              get data() {
                return Sr(a4);
              }
            }), ko(() => Ia(n7, "title", "Currently sorted in ".concat(Sr(r4), " order"))), Hr(e7, n7);
          };
          sa(f2, (e7) => {
            void 0 !== Sr(o3) && e7(p4);
          }), ko((e7, n7) => {
            c3 = Ca(d, 1, "jse-column-header svelte-2i3vdx", null, c3, e7), Ia(d, "title", s5() ? Sr(t5) : Sr(t5) + " (Click to sort the data by this column)"), Xr(v3, n7);
          }, [() => ({
            "jse-readonly": s5()
          }), () => (Ar(Vs), Sr(t5), Ar(50), Or(() => Vs(Sr(t5), 50)))], Lt), Dr("click", d, function() {
            s5() || l3()({
              path: a3(),
              sortDirection: Sr(o3) === ls.asc ? ls.desc : ls.asc
            });
          }), Hr(e6, d), Nt();
        }(uo(t4), {
          get path() {
            return Sr(n5);
          },
          get sortedColumn() {
            return Sr(en);
          },
          get readOnly() {
            return j();
          },
          onSort: tn
        }), Hr(e5, t4);
      });
      var h3 = fo(p3), g = (e5) => {
        var n5 = ym(), t4 = uo(n5), o3 = Lt(() => (Sr(ie3), Or(() => Array.isArray(Sr(ie3)) ? Sr(ie3).length : 0)));
        !function(e6, n6) {
          Tt(n6, false);
          var t5 = ai(n6, "count", 9), o4 = ai(n6, "maxSampleCount", 9), r4 = ai(n6, "readOnly", 9), a3 = ai(n6, "onRefresh", 9);
          Ka(true);
          var i4, s5 = bm();
          nl(uo(s5), {
            get data() {
              return faRotate;
            }
          }), ko((e7) => {
            i4 = Ca(s5, 1, "jse-column-header svelte-fzj761", null, i4, e7), Ia(s5, "title", "The Columns are created by sampling ".concat(o4(), " items out of ").concat(t5(), ". ") + "If you're missing a column, click here to sample all of the items instead of a subset. This is slower.");
          }, [() => ({
            "jse-readonly": r4()
          })], Lt), Dr("click", s5, () => a3()()), Hr(e6, s5), Nt();
        }(t4, {
          get count() {
            return Sr(o3);
          },
          get maxSampleCount() {
            return Sr(Ie);
          },
          get readOnly() {
            return j();
          },
          onRefresh: () => Xt(Ie, 1 / 0)
        }), Hr(e5, n5);
      };
      sa(h3, (e5) => {
        Sr(t3) && e5(g);
      });
      var m2, b2, x = fo(c2), y = uo(x), w2 = fo(x);
      da(w2, 1, () => (Sr(o2), Or(() => Sr(o2).visibleItems)), ca, (e5, n5, r4) => {
        var i4 = zm(), s5 = Lt(() => (Sr(o2), Or(() => Sr(o2).startIndex + r4))), l3 = Lt(() => (Sr(a2), Ar(Sr(s5)), Or(() => Sr(a2).rows[Sr(s5)]))), c3 = Lt(() => (Ar(Mh), Ar(Sr(s5)), Ar(Sr(l3)), Or(() => {
          var e6;
          return Mh([String(Sr(s5))], null === (e6 = Sr(l3)) || void 0 === e6 ? void 0 : e6.row);
        }))), u3 = Lt(() => (Ar(uc), Sr(ie3), Sr(ye), Ar(Sr(s5)), Or(() => uc(Sr(ie3), Sr(ye), [String(Sr(s5))])))), v3 = uo(i4);
        la(v3, () => Sr(s5), (e6) => {
          var n6 = wm(), t4 = uo(n6), o3 = fo(t4), r5 = (e7) => {
            up(e7, {
              get validationError() {
                return Sr(c3);
              },
              get onExpand() {
                return Vg;
              }
            });
          };
          sa(o3, (e7) => {
            Sr(c3) && e7(r5);
          }), ba(n6, (e7, n7) => null == zg ? void 0 : zg(e7, n7), () => (e7) => function(e8, n7) {
            $e[n7] = e8.getBoundingClientRect().height;
          }(e7, Sr(s5))), ko(() => {
            var e7;
            return Xr(t4, "".concat(null !== (e7 = Sr(s5)) && void 0 !== e7 ? e7 : "", " "));
          }), Hr(e6, n6);
        });
        var f2 = fo(v3);
        da(f2, 1, () => Sr(De), ca, (e6, t4, o3, r5) => {
          var a3, i5 = Sm(), c4 = Lt(() => (Ar(Sr(s5)), Sr(t4), Or(() => [String(Sr(s5))].concat(Sr(t4))))), v4 = Lt(() => (Ar(getIn), Sr(n5), Sr(t4), Or(() => getIn(Sr(n5), Sr(t4))))), f3 = Lt(() => (Ar(qc), Sr(Ge), Ar(Qc), Ar(Sr(c4)), Or(() => qc(Sr(Ge)) && Qc(Sr(Ge).path, Sr(c4))))), p5 = Lt(() => (Ar(Sr(l3)), Or(() => {
            var e7;
            return null === (e7 = Sr(l3)) || void 0 === e7 ? void 0 : e7.columns[o3];
          }))), h5 = Lt(() => (Ar(Mh), Ar(Sr(c4)), Ar(Sr(p5)), Or(() => Mh(Sr(c4), Sr(p5))))), g2 = uo(i5), m3 = uo(g2), b3 = (e7) => {
            var o4 = Lt(() => (Ar(Ld), Ar(uc), Sr(n5), Ar(Sr(u3)), Sr(t4), Or(() => Ld(uc(Sr(n5), Sr(u3), Sr(t4)))))), r6 = Lt(() => (Ar(Sr(o4)), Or(() => !!Sr(o4) && Sr(o4).some((e8) => e8.active)))), a4 = Lt(() => (Ar(isEmpty_default), Ar(Sr(o4)), Or(() => !isEmpty_default(Sr(o4)))));
            !function(e8, n6) {
              Tt(n6, false);
              var t5 = ai(n6, "path", 9), o5 = ai(n6, "value", 9), r7 = ai(n6, "parser", 9), a5 = ai(n6, "isSelected", 9), i6 = ai(n6, "containsSearchResult", 9), s6 = ai(n6, "containsActiveSearchResult", 9), l4 = ai(n6, "onEdit", 9);
              Ka(true);
              var c5, d = im(), u4 = uo(d);
              ko((e9, n7) => {
                c5 = Ca(d, 1, "jse-inline-value svelte-h57m0p", null, c5, e9), Xr(u4, n7);
              }, [() => ({
                "jse-selected": a5(),
                "jse-highlight": i6(),
                "jse-active": s6()
              }), () => (Ar(Vs), Ar(r7()), Ar(o5()), Ar(50), Or(() => {
                var e9;
                return Vs(null !== (e9 = r7().stringify(o5())) && void 0 !== e9 ? e9 : "", 50);
              }))], Lt), Dr("dblclick", d, () => l4()(t5())), Hr(e8, d), Nt();
            }(e7, {
              get path() {
                return Sr(c4);
              },
              get value() {
                return Sr(v4);
              },
              get parser() {
                return P();
              },
              get isSelected() {
                return Sr(f3);
              },
              get containsSearchResult() {
                return Sr(a4);
              },
              get containsActiveSearchResult() {
                return Sr(r6);
              },
              onEdit: tt3
            });
          }, x2 = (e7) => {
            var n6 = Lt(() => (Ar(uc), Sr(ie3), Sr(ye), Ar(Sr(c4)), Or(() => {
              var e8;
              return null === (e8 = uc(Sr(ie3), Sr(ye), Sr(c4))) || void 0 === e8 ? void 0 : e8.searchResults;
            }))), t5 = Lt(() => void 0 !== Sr(v4) ? Sr(v4) : ""), o4 = Lt(() => (Ar(bc), Sr(ie3), Sr(Xe), Ar(Sr(c4)), Or(() => bc(Sr(ie3), Sr(Xe), Sr(c4))))), r6 = Lt(() => Sr(f3) ? Sr(Ge) : void 0);
            sp(e7, {
              get path() {
                return Sr(c4);
              },
              get value() {
                return Sr(t5);
              },
              get enforceString() {
                return Sr(o4);
              },
              get selection() {
                return Sr(r6);
              },
              get searchResultItems() {
                return Sr(n6);
              },
              get context() {
                return Sr(on);
              }
            });
          };
          sa(m3, (e7) => {
            Ar(hi), Ar(Sr(v4)), Or(() => hi(Sr(v4))) ? e7(b3) : e7(x2, false);
          });
          var y2 = fo(m3), w3 = (e7) => {
            var n6 = km();
            op(uo(n6), {
              selected: true,
              onContextMenu: Sn
            }), Hr(e7, n6);
          };
          sa(y2, (e7) => {
            Ar(j()), Ar(Sr(f3)), Ar(rd), Sr(Ge), Or(() => !j() && Sr(f3) && !rd(Sr(Ge))) && e7(w3);
          });
          var k2 = fo(g2, 2), S3 = (e7) => {
            up(e7, {
              get validationError() {
                return Sr(h5);
              },
              get onExpand() {
                return Vg;
              }
            });
          };
          sa(k2, (e7) => {
            Sr(h5) && e7(S3);
          }), ko((e7, n6) => {
            Ia(i5, "data-path", e7), a3 = Ca(g2, 1, "jse-value-outer svelte-u14cgx", null, a3, n6);
          }, [() => (Ar(Rs), Ar(Sr(c4)), Or(() => Rs(Sr(c4)))), () => ({
            "jse-selected-value": Sr(f3)
          })], Lt), Hr(e6, i5);
        });
        var p4 = fo(f2), h4 = (e6) => {
          Hr(e6, Cm());
        };
        sa(p4, (e6) => {
          Sr(t3) && e6(h4);
        }), Hr(e5, i4);
      });
      var k, S2 = uo(fo(w2));
      Ha(i3, (e5) => Xt(te, e5), () => Sr(te)), ba(i3, (e5, n5) => null == zg ? void 0 : zg(e5, n5), () => ct3), jo(() => Dr("scroll", i3, mn));
      var C4 = fo(i3, 2), z4 = (e5) => {
        var n5 = Lt(() => (Sr(ve), Or(() => "You pasted a JSON ".concat(Array.isArray(Sr(ve).contents) ? "array" : "object", " as text")))), t4 = Lt(() => [{
          icon: faWrench,
          text: "Paste as JSON instead",
          title: "Paste the text as JSON instead of a single value",
          onMouseDown: An
        }, {
          text: "Leave as is",
          title: "Keep the pasted content as a single value",
          onClick: In
        }]);
        Rf(e5, {
          type: "info",
          get message() {
            return Sr(n5);
          },
          get actions() {
            return Sr(t4);
          }
        });
      };
      sa(C4, (e5) => {
        Sr(ve) && e5(z4);
      });
      var O = fo(C4, 2), M3 = (e5) => {
        var n5 = Lt(() => [{
          icon: faWrench,
          text: "Paste as string instead",
          title: "Paste the clipboard data as a single string value instead of an array",
          onClick: Tn
        }, {
          text: "Leave as is",
          title: "Keep the pasted array",
          onClick: Un
        }]);
        Rf(e5, {
          type: "info",
          message: "Multiline text was pasted as array",
          get actions() {
            return Sr(n5);
          }
        });
      };
      sa(O, (e5) => {
        Sr(xe) && e5(M3);
      });
      var E2 = fo(O, 2), A3 = (e5) => {
        var n5 = Lt(() => j() ? [] : [{
          icon: faCheck,
          text: "Ok",
          title: "Accept the repaired document",
          onClick: jn
        }, {
          icon: faCode,
          text: "Repair manually instead",
          title: "Leave the document unchanged and repair it manually instead",
          onClick: Dn
        }]);
        Rf(e5, {
          type: "success",
          message: "The loaded JSON document was invalid but is successfully repaired.",
          get actions() {
            return Sr(n5);
          },
          onClose: gn
        });
      };
      sa(E2, (e5) => {
        Sr(nn) && e5(A3);
      }), Df(fo(E2, 2), {
        get validationErrors() {
          return Sr(an);
        },
        selectError: et3
      }), ko((e5, n5, t4) => {
        m2 = Ca(x, 1, "jse-table-invisible-start-section svelte-u14cgx", null, m2, e5), Ia(y, "colspan", (Sr(De), Or(() => Sr(De).length))), b2 = Oa(y, "", b2, n5), Ia(S2, "colspan", (Sr(De), Or(() => Sr(De).length))), k = Oa(S2, "", k, t4);
      }, [() => ({
        "jse-search-box-background": Sr(we)
      }), () => ({
        height: (Sr(o2), Or(() => Sr(o2).startHeight + "px"))
      }), () => ({
        height: (Sr(o2), Or(() => Sr(o2).endHeight + "px"))
      })], Lt), Hr(e4, n4);
    }, c = (e4, n4) => {
      var t4 = (e5) => {
        var n5 = Mm(), t5 = vo(n5), o4 = Lt(() => j() ? [] : [{
          icon: faCode,
          text: "Repair manually",
          title: 'Open the document in "code" mode and repair it manually',
          onClick: Dn
        }]);
        Rf(t5, {
          type: "error",
          message: "The loaded JSON document is invalid and could not be repaired automatically.",
          get actions() {
            return Sr(o4);
          }
        }), Lh(fo(t5, 2), {
          get text() {
            return Sr(se);
          },
          get json() {
            return Sr(ie3);
          },
          get indentation() {
            return J();
          },
          get parser() {
            return P();
          }
        }), Hr(e5, n5);
      }, o3 = (e5) => {
        mm(e5, {
          get text() {
            return Sr(se);
          },
          get json() {
            return Sr(ie3);
          },
          get readOnly() {
            return j();
          },
          get parser() {
            return P();
          },
          openJSONEditorModal: tt3,
          extractPath: Wn2,
          get onChangeMode() {
            return _();
          },
          onClick: () => {
            gn();
          }
        });
      };
      sa(e4, (e5) => {
        Sr(le) && void 0 !== Sr(se) && "" !== Sr(se) ? e5(t4) : e5(o3, false);
      }, n4);
    };
    sa(s3, (e4) => {
      Sr(_e) ? e4(l) : e4(c, false);
    }), Dr("paste", i2, Kn2), Hr(e3, n3);
  }, mt3 = (e3) => {
    Hr(e3, Am());
  };
  sa(ht3, (e3) => {
    b ? e3(mt3, false) : e3(gt4);
  }), Ha(vt2, (e3) => Xt(ne, e3), () => Sr(ne));
  var bt2 = fo(vt2, 2), jt2 = (e3) => {
    Lf(e3, {
      onClose: () => Xt(Ve2, false)
    });
  };
  sa(bt2, (e3) => {
    Sr(Ve2) && e3(jt2);
  });
  var xt2 = fo(bt2, 2), yt2 = (e3) => {
    Xf(e3, ri(() => Sr(re), {
      onClose: () => {
        var e4;
        null === (e4 = Sr(re)) || void 0 === e4 || e4.onClose(), Xt(re, void 0);
      }
    }));
  };
  return sa(xt2, (e3) => {
    Sr(re) && e3(yt2);
  }), ko((e3) => ut3 = Ca(vt2, 1, "jse-table-mode svelte-u14cgx", null, ut3, e3), [() => ({
    "no-main-menu": !M2()
  })], Lt), Dr("mousedown", vt2, function(e3) {
    if (1 === e3.buttons || 2 === e3.buttons) {
      var n3 = e3.target;
      n3.isContentEditable || gn();
      var t4 = qs(n3);
      if (t4) {
        if (rd(Sr(Ge)) && dd(Sr(ie3), Sr(Ge), t4)) return;
        Xt(Ge, Xc(t4)), e3.preventDefault();
      }
    }
  }), Dr("keydown", vt2, function(e3) {
    var n3 = Ns(e3);
    if (s2("keydown", {
      combo: n3,
      key: e3.key
    }), "Ctrl+X" === n3 && (e3.preventDefault(), Jn(true)), "Ctrl+Shift+X" === n3 && (e3.preventDefault(), Jn(false)), "Ctrl+C" === n3 && (e3.preventDefault(), _n(true)), "Ctrl+Shift+C" === n3 && (e3.preventDefault(), _n(false)), "Ctrl+D" === n3 && (e3.preventDefault(), Vn2()), "Delete" !== n3 && "Backspace" !== n3 || (e3.preventDefault(), Ln2()), "Insert" === n3 && e3.preventDefault(), "Ctrl+A" === n3 && e3.preventDefault(), "Ctrl+Q" === n3 && Cn(e3), "ArrowLeft" === n3 && (e3.preventDefault(), bn(), Sr(Ge))) {
      var t4 = function(e4, n4) {
        var {
          rowIndex: t5,
          columnIndex: o4
        } = Ch(vd(n4), e4);
        return o4 > 0 ? Xc(zh({
          rowIndex: t5,
          columnIndex: o4 - 1
        }, e4)) : n4;
      }(Sr(De), Sr(Ge));
      Xt(Ge, t4), wn(vd(t4));
    }
    if ("ArrowRight" === n3 && (e3.preventDefault(), bn(), Sr(Ge))) {
      var o3 = function(e4, n4) {
        var {
          rowIndex: t5,
          columnIndex: o4
        } = Ch(vd(n4), e4);
        return o4 < e4.length - 1 ? Xc(zh({
          rowIndex: t5,
          columnIndex: o4 + 1
        }, e4)) : n4;
      }(Sr(De), Sr(Ge));
      Xt(Ge, o3), wn(vd(o3));
    }
    if ("ArrowUp" === n3 && (e3.preventDefault(), bn(), Sr(Ge))) {
      var a3 = function(e4, n4) {
        var {
          rowIndex: t5,
          columnIndex: o4
        } = Ch(vd(n4), e4);
        return t5 > 0 ? Xc(zh({
          rowIndex: t5 - 1,
          columnIndex: o4
        }, e4)) : n4;
      }(Sr(De), Sr(Ge));
      Xt(Ge, a3), wn(vd(a3));
    }
    if ("ArrowDown" === n3 && (e3.preventDefault(), bn(), Sr(Ge))) {
      var i2 = function(e4, n4, t5) {
        var {
          rowIndex: o4,
          columnIndex: r2
        } = Ch(vd(t5), n4);
        return o4 < e4.length - 1 ? Xc(zh({
          rowIndex: o4 + 1,
          columnIndex: r2
        }, n4)) : t5;
      }(Sr(ie3), Sr(De), Sr(Ge));
      Xt(Ge, i2), wn(vd(i2));
    }
    if ("Enter" === n3 && Sr(Ge) && qc(Sr(Ge))) {
      e3.preventDefault();
      var l = Sr(Ge).path;
      hi(getIn(Sr(ie3), l)) ? tt3(l) : j() || Xt(Ge, r(r({}, Sr(Ge)), {}, {
        edit: true
      }));
    }
    if (1 === n3.replace(/^Shift\+/, "").length && Sr(Ge)) return e3.preventDefault(), void function(e4) {
      Yn2.apply(this, arguments);
    }(e3.key);
    if ("Ctrl+Enter" === n3 && qc(Sr(Ge))) {
      e3.preventDefault();
      var c = getIn(Sr(ie3), Sr(Ge).path);
      ki(c) && window.open(String(c), "_blank");
    }
    "Escape" === n3 && Sr(Ge) && (e3.preventDefault(), Xt(Ge, void 0)), "Ctrl+F" === n3 && (e3.preventDefault(), it3(false)), "Ctrl+H" === n3 && (e3.preventDefault(), it3(true)), "Ctrl+Z" === n3 && (e3.preventDefault(), st3()), "Ctrl+Shift+Z" === n3 && (e3.preventDefault(), lt4());
  }), Dr("contextmenu", vt2, Cn), Hr(e2, dt3), Va(n2, "validate", cn), Va(n2, "patch", dn), Va(n2, "focus", gn), Va(n2, "acceptAutoRepair", jn), Va(n2, "scrollTo", xn), Va(n2, "findElement", kn), Va(n2, "openTransformModal", nt3), Nt({
    validate: cn,
    patch: dn,
    focus: gn,
    acceptAutoRepair: jn,
    scrollTo: xn,
    findElement: kn,
    openTransformModal: nt3
  });
}
function Pm(e2, n2) {
  Tt(n2, false);
  var t3 = ai(n2, "content", 8), o2 = ai(n2, "selection", 12), r2 = ai(n2, "readOnly", 8), a2 = ai(n2, "indentation", 8), s2 = ai(n2, "tabSize", 8), l = ai(n2, "truncateTextSize", 8), c = ai(n2, "externalMode", 8), d = ai(n2, "mainMenuBar", 8), u = ai(n2, "navigationBar", 8), v = ai(n2, "statusBar", 8), f = ai(n2, "askToFormat", 8), p2 = ai(n2, "escapeControlCharacters", 8), h2 = ai(n2, "escapeUnicodeCharacters", 8), g = ai(n2, "flattenColumns", 8), m = ai(n2, "parser", 8), b = ai(n2, "parseMemoizeOne", 8), j = ai(n2, "validator", 8), x = ai(n2, "validationParser", 8), y = ai(n2, "pathParser", 8), w = ai(n2, "insideModal", 8), k = ai(n2, "onChange", 8), S = ai(n2, "onChangeMode", 8), C3 = ai(n2, "onSelect", 8), z3 = ai(n2, "onRenderValue", 8), O = ai(n2, "onClassName", 8), M2 = ai(n2, "onRenderMenu", 8), E = ai(n2, "onRenderContextMenu", 8), A2 = ai(n2, "onError", 8), R = ai(n2, "onFocus", 8), q2 = ai(n2, "onBlur", 8), P = ai(n2, "onSortModal", 8), T2 = ai(n2, "onTransformModal", 8), N2 = ai(n2, "onJSONEditorModal", 8), I = Kt(), U2 = Kt(), D2 = Kt(), J = ii("jsoneditor:JSONEditorRoot"), B = Kt(Ig({
    onChange: (e3) => Xt(B, e3)
  }).get()), _ = Kt(c());
  function F2(e3) {
    if (Kl(e3)) {
      Xt(_, e3.undo.mode);
      var n3 = Sr(B).items(), t4 = n3.findIndex((n4) => n4 === e3), r3 = -1 !== t4 ? n3[t4 - 1] : void 0;
      J("handleUndo", {
        index: t4,
        item: e3,
        items: n3,
        prevItem: r3
      }), r3 && o2(r3.redo.selection), S()(Sr(_));
    }
  }
  function L(e3) {
    if (Kl(e3)) {
      Xt(_, e3.redo.mode);
      var n3 = Sr(B).items(), t4 = n3.findIndex((n4) => n4 === e3), r3 = -1 !== t4 ? n3[t4 + 1] : void 0;
      J("handleRedo", {
        index: t4,
        item: e3,
        items: n3,
        nextItem: r3
      }), r3 && o2(r3.undo.selection), S()(Sr(_));
    }
  }
  var W2 = Kt(), V2 = {
    type: "separator"
  }, $ = Kt(), Q = Kt();
  function Y2(e3) {
    if (Sr(I)) return Sr(I).patch(e3);
    if (Sr(U2)) return Sr(U2).patch(e3);
    if (Sr(D2)) return Sr(D2).patch(e3);
    throw new Error('Method patch is not available in mode "'.concat(Sr(_), '"'));
  }
  function K(e3, n3) {
    if (Sr(I)) return Sr(I).expand(e3, n3);
    if (Sr(D2)) return Sr(D2).expand(e3, n3);
    throw new Error('Method expand is not available in mode "'.concat(Sr(_), '"'));
  }
  function Z2(e3, n3) {
    if (Sr(I)) return Sr(I).collapse(e3, n3);
    if (Sr(D2)) return Sr(D2).collapse(e3);
    throw new Error('Method collapse is not available in mode "'.concat(Sr(_), '"'));
  }
  function X2(e3) {
    if (Sr(D2)) Sr(D2).openTransformModal(e3);
    else if (Sr(I)) Sr(I).openTransformModal(e3);
    else {
      if (!Sr(U2)) throw new Error('Method transform is not available in mode "'.concat(Sr(_), '"'));
      Sr(U2).openTransformModal(e3);
    }
  }
  function G2() {
    if (Sr(D2)) return Sr(D2).validate();
    if (Sr(I)) return Sr(I).validate();
    if (Sr(U2)) return Sr(U2).validate();
    throw new Error('Method validate is not available in mode "'.concat(Sr(_), '"'));
  }
  function ee() {
    return Sr(I) ? Sr(I).acceptAutoRepair() : t3();
  }
  function ne(e3) {
    if (Sr(I)) return Sr(I).scrollTo(e3);
    if (Sr(U2)) return Sr(U2).scrollTo(e3);
    throw new Error('Method scrollTo is not available in mode "'.concat(Sr(_), '"'));
  }
  function te(e3) {
    if (Sr(I)) return Sr(I).findElement(e3);
    if (Sr(U2)) return Sr(U2).findElement(e3);
    throw new Error('Method findElement is not available in mode "'.concat(Sr(_), '"'));
  }
  function oe() {
    Sr(D2) ? Sr(D2).focus() : Sr(I) ? Sr(I).focus() : Sr(U2) && Sr(U2).focus();
  }
  function re() {
    return ae.apply(this, arguments);
  }
  function ae() {
    return (ae = i(function* () {
      Sr(D2) && (yield Sr(D2).refresh());
    })).apply(this, arguments);
  }
  xo(() => Ar(c()), () => {
    !function(e3) {
      if (e3 !== Sr(_)) {
        var n3 = {
          type: "mode",
          undo: {
            mode: Sr(_),
            selection: void 0
          },
          redo: {
            mode: e3,
            selection: void 0
          }
        };
        "text" === Sr(_) && Sr(D2) && Sr(D2).flush(), J("add history item", n3), Sr(B).add(n3), Xt(_, e3);
      }
    }(c());
  }), xo(() => (Sr(_), Ar(S())), () => {
    Xt(W2, [{
      type: "button",
      text: "text",
      title: "Switch to text mode (current mode: ".concat(Sr(_), ")"),
      className: "jse-group-button jse-first" + (Sr(_) === os.text ? " jse-selected" : ""),
      onClick: () => S()(os.text)
    }, {
      type: "button",
      text: "tree",
      title: "Switch to tree mode (current mode: ".concat(Sr(_), ")"),
      className: "jse-group-button " + (Sr(_) === os.tree ? " jse-selected" : ""),
      onClick: () => S()(os.tree)
    }, {
      type: "button",
      text: "table",
      title: "Switch to table mode (current mode: ".concat(Sr(_), ")"),
      className: "jse-group-button jse-last" + (Sr(_) === os.table ? " jse-selected" : ""),
      onClick: () => S()(os.table)
    }]);
  }), xo(() => (Sr(W2), Ar(M2()), Sr(_), Ar(w()), Ar(r2())), () => {
    Xt($, (e3) => {
      var n3 = Al(e3[0]) ? Sr(W2).concat(e3) : Sr(W2).concat(V2, e3), t4 = cloneDeep_default(n3);
      return M2()(n3, {
        mode: Sr(_),
        modal: w(),
        readOnly: r2()
      }) || t4;
    });
  }), xo(() => (Ar(E()), Sr(_), Ar(w()), Ar(r2()), Ar(o2())), () => {
    Xt(Q, (e3) => {
      var n3, t4 = cloneDeep_default(e3);
      return null !== (n3 = E()(e3, {
        mode: Sr(_),
        modal: w(),
        readOnly: r2(),
        selection: o2()
      })) && void 0 !== n3 ? n3 : !r2() && t4;
    });
  }), yo(), Ka();
  var ie3 = $r(), se = vo(ie3), le = (e3) => {
    Ha(am(e3, {
      get externalContent() {
        return t3();
      },
      get externalSelection() {
        return o2();
      },
      get history() {
        return Sr(B);
      },
      get readOnly() {
        return r2();
      },
      get indentation() {
        return a2();
      },
      get tabSize() {
        return s2();
      },
      get mainMenuBar() {
        return d();
      },
      get statusBar() {
        return v();
      },
      get askToFormat() {
        return f();
      },
      get escapeUnicodeCharacters() {
        return h2();
      },
      get parser() {
        return m();
      },
      get validator() {
        return j();
      },
      get validationParser() {
        return x();
      },
      get onChange() {
        return k();
      },
      get onChangeMode() {
        return S();
      },
      get onSelect() {
        return C3();
      },
      onUndo: F2,
      onRedo: L,
      get onError() {
        return A2();
      },
      get onFocus() {
        return R();
      },
      get onBlur() {
        return q2();
      },
      get onRenderMenu() {
        return Sr($);
      },
      get onSortModal() {
        return P();
      },
      get onTransformModal() {
        return T2();
      },
      $$legacy: true
    }), (e4) => Xt(D2, e4), () => Sr(D2));
  }, ce = (e3, n3) => {
    var i2 = (e4) => {
      Ha(qm(e4, {
        get externalContent() {
          return t3();
        },
        get externalSelection() {
          return o2();
        },
        get history() {
          return Sr(B);
        },
        get readOnly() {
          return r2();
        },
        get truncateTextSize() {
          return l();
        },
        get mainMenuBar() {
          return d();
        },
        get escapeControlCharacters() {
          return p2();
        },
        get escapeUnicodeCharacters() {
          return h2();
        },
        get flattenColumns() {
          return g();
        },
        get parser() {
          return m();
        },
        get parseMemoizeOne() {
          return b();
        },
        get validator() {
          return j();
        },
        get validationParser() {
          return x();
        },
        get indentation() {
          return a2();
        },
        get onChange() {
          return k();
        },
        get onChangeMode() {
          return S();
        },
        get onSelect() {
          return C3();
        },
        onUndo: F2,
        onRedo: L,
        get onRenderValue() {
          return z3();
        },
        get onFocus() {
          return R();
        },
        get onBlur() {
          return q2();
        },
        get onRenderMenu() {
          return Sr($);
        },
        get onRenderContextMenu() {
          return Sr(Q);
        },
        get onSortModal() {
          return P();
        },
        get onTransformModal() {
          return T2();
        },
        get onJSONEditorModal() {
          return N2();
        },
        $$legacy: true
      }), (e5) => Xt(U2, e5), () => Sr(U2));
    }, s3 = (e4) => {
      Ha(Pg(e4, {
        get externalContent() {
          return t3();
        },
        get externalSelection() {
          return o2();
        },
        get history() {
          return Sr(B);
        },
        get readOnly() {
          return r2();
        },
        get indentation() {
          return a2();
        },
        get truncateTextSize() {
          return l();
        },
        get mainMenuBar() {
          return d();
        },
        get navigationBar() {
          return u();
        },
        get escapeControlCharacters() {
          return p2();
        },
        get escapeUnicodeCharacters() {
          return h2();
        },
        get parser() {
          return m();
        },
        get parseMemoizeOne() {
          return b();
        },
        get validator() {
          return j();
        },
        get validationParser() {
          return x();
        },
        get pathParser() {
          return y();
        },
        get onError() {
          return A2();
        },
        get onChange() {
          return k();
        },
        get onChangeMode() {
          return S();
        },
        get onSelect() {
          return C3();
        },
        onUndo: F2,
        onRedo: L,
        get onRenderValue() {
          return z3();
        },
        get onClassName() {
          return O();
        },
        get onFocus() {
          return R();
        },
        get onBlur() {
          return q2();
        },
        get onRenderMenu() {
          return Sr($);
        },
        get onRenderContextMenu() {
          return Sr(Q);
        },
        get onSortModal() {
          return P();
        },
        get onTransformModal() {
          return T2();
        },
        get onJSONEditorModal() {
          return N2();
        },
        $$legacy: true
      }), (e5) => Xt(I, e5), () => Sr(I));
    };
    sa(e3, (e4) => {
      Sr(_), Ar(os), Or(() => Sr(_) === os.table) ? e4(i2) : e4(s3, false);
    }, n3);
  };
  return sa(se, (e3) => {
    Sr(_), Ar(os), Or(() => Sr(_) === os.text || "code" === String(Sr(_))) ? e3(le) : e3(ce, false);
  }), Hr(e2, ie3), Va(n2, "patch", Y2), Va(n2, "expand", K), Va(n2, "collapse", Z2), Va(n2, "transform", X2), Va(n2, "validate", G2), Va(n2, "acceptAutoRepair", ee), Va(n2, "scrollTo", ne), Va(n2, "findElement", te), Va(n2, "focus", oe), Va(n2, "refresh", re), Nt({
    patch: Y2,
    expand: K,
    collapse: Z2,
    transform: X2,
    validate: G2,
    acceptAutoRepair: ee,
    scrollTo: ne,
    findElement: te,
    focus: oe,
    refresh: re
  });
}
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-modal-wrapper.svelte-v0el4e {\n  flex: 1;\n  display: flex;\n  min-width: 0;\n  min-height: 0;\n  flex-direction: column;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  overflow: auto;\n  min-width: 0;\n  min-height: 0;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-actions:where(.svelte-v0el4e) {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  padding-top: var(--jse-padding, 10px);\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-actions:where(.svelte-v0el4e) button.jse-primary:where(.svelte-v0el4e) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-actions:where(.svelte-v0el4e) button.jse-primary:where(.svelte-v0el4e):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-actions:where(.svelte-v0el4e) button.jse-primary:where(.svelte-v0el4e):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-label:where(.svelte-v0el4e) {\n  font-weight: bold;\n  display: block;\n  box-sizing: border-box;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-label:where(.svelte-v0el4e) .jse-label-inner:where(.svelte-v0el4e) {\n  margin-top: calc(2 * var(--jse-padding, 10px));\n  margin-bottom: calc(0.5 * var(--jse-padding, 10px));\n  box-sizing: border-box;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-modal-contents:where(.svelte-v0el4e) .jse-modal-inline-editor:where(.svelte-v0el4e) {\n  flex: 1;\n  min-height: 150px;\n  min-width: 0;\n  max-width: 100%;\n  display: flex;\n  --jse-theme-color: var(--jse-modal-editor-theme-color, #707070);\n  --jse-theme-color-highlight: var(--jse-modal-editor-theme-color-highlight, #646464);\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-actions:where(.svelte-v0el4e) {\n  gap: var(--jse-padding, 10px);\n  align-items: center;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-actions:where(.svelte-v0el4e) .jse-error:where(.svelte-v0el4e) {\n  flex: 1;\n  color: var(--jse-error-color, #ee5341);\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-actions:where(.svelte-v0el4e) button.jse-secondary:where(.svelte-v0el4e) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-secondary-background, #d3d3d3);\n  color: var(--jse-button-secondary-color, var(--jse-text-color, #4d4d4d));\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-actions:where(.svelte-v0el4e) button.jse-secondary:where(.svelte-v0el4e):hover {\n  background: var(--jse-button-secondary-background-highlight, #e1e1e1);\n}\n.jse-modal-wrapper.svelte-v0el4e .jse-actions:where(.svelte-v0el4e) button.jse-secondary:where(.svelte-v0el4e):disabled {\n  background: var(--jse-button-secondary-background-disabled, #9d9d9d);\n}\n.jse-modal-wrapper.svelte-v0el4e input:where(.svelte-v0el4e) {\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  outline: none;\n  box-sizing: border-box;\n  padding: calc(0.5 * var(--jse-padding, 10px));\n  font-family: var(--jse-font-family-mono, consolas, menlo, monaco, "Ubuntu Mono", "source-code-pro", monospace);\n  font-size: var(--jse-font-size-mono, 14px);\n  color: inherit;\n  background: var(--jse-input-background, var(--jse-background-color, #fff));\n}\n.jse-modal-wrapper.svelte-v0el4e input:where(.svelte-v0el4e):focus {\n  border: var(--jse-input-border-focus, 1px solid var(--jse-input-border-focus, var(--jse-theme-color, #3883fa)));\n}\n.jse-modal-wrapper.svelte-v0el4e input:where(.svelte-v0el4e):read-only {\n  background: var(--jse-input-background-readonly, transparent);\n}');
var Tm = Lr('<div class="jse-error svelte-v0el4e"> </div>');
var Nm = Lr('<button type="button" class="jse-secondary svelte-v0el4e"><!> Back</button>');
var Im = Lr('<button type="button" class="jse-primary svelte-v0el4e">Apply</button>');
var Um = Lr('<button type="button" class="jse-primary svelte-v0el4e">Close</button>');
var Dm = Lr('<!> <div class="jse-modal-contents svelte-v0el4e"><div class="jse-label svelte-v0el4e"><div class="jse-label-inner svelte-v0el4e">Path</div></div> <input class="jse-path svelte-v0el4e" type="text" readonly="" title="Selected path"/> <div class="jse-label svelte-v0el4e"><div class="jse-label-inner svelte-v0el4e">Contents</div></div> <div class="jse-modal-inline-editor svelte-v0el4e"><!></div> <div class="jse-actions svelte-v0el4e"><!> <!> <!></div></div>', 1);
var Jm = Lr('<div class="jse-modal-wrapper svelte-v0el4e"><!></div>');
var Bm = {};
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-modal-contents.svelte-1v9c92j {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  overflow: auto;\n  min-width: 0;\n  min-height: 0;\n}\n.jse-modal-contents.svelte-1v9c92j .jse-actions:where(.svelte-1v9c92j) {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  padding-top: var(--jse-padding, 10px);\n}\n.jse-modal-contents.svelte-1v9c92j .jse-actions:where(.svelte-1v9c92j) button.jse-primary:where(.svelte-1v9c92j) {\n  border: none;\n  background: transparent;\n  color: inherit;\n  cursor: pointer;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  padding: 5px;\n  margin: 0;\n  background: var(--jse-button-primary-background, var(--jse-theme-color, #3883fa));\n  color: var(--jse-button-primary-color, #fff);\n  padding: var(--jse-padding, 10px) calc(2 * var(--jse-padding, 10px));\n  border-radius: 3px;\n}\n.jse-modal-contents.svelte-1v9c92j .jse-actions:where(.svelte-1v9c92j) button.jse-primary:where(.svelte-1v9c92j):hover {\n  background: var(--jse-button-primary-background-highlight, var(--jse-theme-color-highlight, #5f9dff));\n}\n.jse-modal-contents.svelte-1v9c92j .jse-actions:where(.svelte-1v9c92j) button.jse-primary:where(.svelte-1v9c92j):disabled {\n  background: var(--jse-button-primary-background-disabled, #9d9d9d);\n}\n.jse-modal-contents.svelte-1v9c92j table:where(.svelte-1v9c92j) {\n  width: 100%;\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n.jse-modal-contents.svelte-1v9c92j table:where(.svelte-1v9c92j) th:where(.svelte-1v9c92j),\n.jse-modal-contents.svelte-1v9c92j table:where(.svelte-1v9c92j) td:where(.svelte-1v9c92j) {\n  text-align: left;\n  vertical-align: middle;\n  font-weight: normal;\n  padding-bottom: var(--jse-padding, 10px);\n}\n.jse-modal-contents.svelte-1v9c92j input.jse-path:where(.svelte-1v9c92j) {\n  width: 100%;\n  box-sizing: border-box;\n  padding: 5px 10px;\n  border: var(--jse-input-border, 1px solid #d8dbdf);\n  border-radius: var(--jse-input-radius, 3px);\n  font-family: inherit;\n  font-size: inherit;\n  background: inherit;\n  background: var(--jse-input-background-readonly, transparent);\n  color: inherit;\n  outline: none;\n}\n.jse-modal-contents.svelte-1v9c92j .svelte-select input {\n  box-sizing: border-box;\n}\n.jse-modal-contents.svelte-1v9c92j .jse-space:where(.svelte-1v9c92j) {\n  height: 200px;\n}\n.jse-modal-contents.svelte-1v9c92j .jse-space:where(.svelte-1v9c92j) .jse-error:where(.svelte-1v9c92j) {\n  color: var(--jse-error-color, #ee5341);\n}');
var _m = Xa(() => Bm);
var Fm = Lr('<tr><th class="svelte-1v9c92j">Property</th><td class="svelte-1v9c92j"><!></td></tr>');
var Lm = Lr('<div class="jse-error svelte-1v9c92j"> </div>');
var Wm = Lr('<!> <div class="jse-modal-contents svelte-1v9c92j"><table class="svelte-1v9c92j"><colgroup><col width="25%"/><col width="75%"/></colgroup><tbody><tr><th class="svelte-1v9c92j">Path</th><td class="svelte-1v9c92j"><input class="jse-path svelte-1v9c92j" type="text" readonly="" title="Selected path"/></td></tr><!><tr><th class="svelte-1v9c92j">Direction</th><td class="svelte-1v9c92j"><!></td></tr></tbody></table> <div class="jse-space svelte-1v9c92j"><!></div> <div class="jse-actions svelte-1v9c92j"><button type="button" class="jse-primary svelte-1v9c92j">Sort</button></div></div>', 1);
Ds('/* over all fonts, sizes, and colors */\n/* "consolas" for Windows, "menlo" for Mac with fallback to "monaco", \'Ubuntu Mono\' for Ubuntu */\n/* (at Mac this font looks too large at 14px, but 13px is too small for the font on Windows) */\n/* main, menu, modal */\n/* jsoneditor modal */\n/* tooltip in text mode */\n/* panels: navigation bar, gutter, search box */\n/* navigation-bar */\n/* context menu */\n/* contents: json key and values */\n/* contents: selected or hovered */\n/* contents: section of collapsed items in an array */\n/* contents: highlighting of search matches */\n/* contents: inline tags inside the JSON document */\n/* contents: table */\n/* controls in modals: inputs, buttons, and `a` */\n/* messages */\n/* svelte-select */\n/* color picker */\n.jse-main.svelte-57bmz4 {\n  width: 100%;\n  height: 100%;\n  min-width: 0;\n  min-height: 150px;\n  font-family: var(--jse-font-family, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif);\n  font-size: var(--jse-font-size, 16px);\n  line-height: normal;\n  position: relative;\n  display: flex;\n  flex-direction: row;\n}\n.jse-main.svelte-57bmz4:not(.jse-focus) {\n  --jse-selection-background-color: var(--jse-selection-background-inactive-color, #e8e8e8);\n  --jse-context-menu-pointer-background: var(--jse-context-menu-pointer-hover-background, #b2b2b2);\n}');
var Vm = Lr('<div role="none"><!></div> <!> <!> <!>', 1);
function $m(e2, n2) {
  Tt(n2, false);
  var t3 = Kt(void 0, true), o2 = ii("jsoneditor:JSONEditor"), a2 = {
    text: ""
  }, s2 = void 0, l = false, u = os.tree, v = true, p2 = true, h2 = true, g = true, m = false, b = false, j = true, y = JSON, w = void 0, k = JSON, S = {
    parse: iu,
    stringify: au
  }, C3 = [Hs], z3 = C3[0].id, O = Vg, M2 = void 0, E = void 0, A2 = ru, R = Vg, T2 = Vg, N2 = Vg, U2 = Vg, D2 = (e3) => {
    console.error(e3), alert(e3.toString());
  }, J = Vg, B = Vg, _ = ai(n2, "content", 13, a2), F2 = ai(n2, "selection", 13, s2), L = ai(n2, "readOnly", 13, l), W2 = ai(n2, "indentation", 13, 2), V2 = ai(n2, "tabSize", 13, 4), $ = ai(n2, "truncateTextSize", 13, 1e3), Q = ai(n2, "mode", 13, u), Y2 = ai(n2, "mainMenuBar", 13, v), K = ai(n2, "navigationBar", 13, p2), Z2 = ai(n2, "statusBar", 13, h2), X2 = ai(n2, "askToFormat", 13, g), G2 = ai(n2, "escapeControlCharacters", 13, m), ee = ai(n2, "escapeUnicodeCharacters", 13, b), ne = ai(n2, "flattenColumns", 13, j), te = ai(n2, "parser", 13, y), oe = ai(n2, "validator", 13, w), re = ai(n2, "validationParser", 13, k), ae = ai(n2, "pathParser", 13, S), ie3 = ai(n2, "queryLanguages", 13, C3), se = ai(n2, "queryLanguageId", 13, z3), le = ai(n2, "onChangeQueryLanguage", 13, O), ce = ai(n2, "onChange", 13, M2), de = ai(n2, "onSelect", 13, E), ue = ai(n2, "onRenderValue", 13, A2), ve = ai(n2, "onClassName", 13, R), fe = ai(n2, "onRenderMenu", 13, T2), pe = ai(n2, "onRenderContextMenu", 13, N2), he = ai(n2, "onChangeMode", 13, U2), ge = ai(n2, "onError", 13, D2), me = ai(n2, "onFocus", 13, J), be = ai(n2, "onBlur", 13, B), je = Kt(di(), true), xe = Kt(false, true), ye = Kt(void 0, true), we = Kt(void 0, true), ke = Kt(void 0, true), Se = Kt(void 0, true), Ce = Kt(te(), true);
  function ze() {
    return _();
  }
  function Oe(e3) {
    o2("set");
    var n3 = Li(e3);
    if (n3) throw new Error(n3);
    Xt(je, di()), _(e3), wr();
  }
  function Me(e3) {
    o2("update");
    var n3 = Li(e3);
    if (n3) throw new Error(n3);
    _(e3), wr();
  }
  function Ee(e3) {
    var n3 = Sr(ye).patch(e3);
    return wr(), n3;
  }
  function Ae(e3) {
    F2(e3), wr();
  }
  function Re(e3, n3) {
    Sr(ye).expand(e3, n3), wr();
  }
  function qe(e3) {
    var n3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    Sr(ye).collapse(e3, n3), wr();
  }
  function Pe() {
    var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    Sr(ye).transform(e3), wr();
  }
  function Te() {
    return Sr(ye).validate();
  }
  function Ne() {
    var e3 = Sr(ye).acceptAutoRepair();
    return wr(), e3;
  }
  function Ie(e3) {
    return Ue.apply(this, arguments);
  }
  function Ue() {
    return (Ue = i(function* (e3) {
      yield Sr(ye).scrollTo(e3);
    })).apply(this, arguments);
  }
  function De(e3) {
    return Sr(ye).findElement(e3);
  }
  function Je() {
    Sr(ye).focus(), wr();
  }
  function Be() {
    return Fe2.apply(this, arguments);
  }
  function Fe2() {
    return (Fe2 = i(function* () {
      yield Sr(ye).refresh();
    })).apply(this, arguments);
  }
  function We2(e3) {
    var n3, t4, r2, i2, c, d, f, x, q2, P, I, H2, je2, xe2, ye2, we2, ke2, Se2, Ce2, ze2, Oe2, Me2, Ee2, Ae2, Re2, qe2, Pe2, Te2, Ne2, Ie2, Ue2, De2 = Object.keys(e3);
    for (var Je2 of De2) switch (Je2) {
      case "content":
        _(null !== (n3 = e3[Je2]) && void 0 !== n3 ? n3 : a2);
        break;
      case "selection":
        F2(null !== (t4 = e3[Je2]) && void 0 !== t4 ? t4 : s2);
        break;
      case "readOnly":
        L(null !== (r2 = e3[Je2]) && void 0 !== r2 ? r2 : l);
        break;
      case "indentation":
        W2(null !== (i2 = e3[Je2]) && void 0 !== i2 ? i2 : 2);
        break;
      case "tabSize":
        V2(null !== (c = e3[Je2]) && void 0 !== c ? c : 4);
        break;
      case "truncateTextSize":
        $(null !== (d = e3[Je2]) && void 0 !== d ? d : 1e3);
        break;
      case "mode":
        Q(null !== (f = e3[Je2]) && void 0 !== f ? f : u);
        break;
      case "mainMenuBar":
        Y2(null !== (x = e3[Je2]) && void 0 !== x ? x : v);
        break;
      case "navigationBar":
        K(null !== (q2 = e3[Je2]) && void 0 !== q2 ? q2 : p2);
        break;
      case "statusBar":
        Z2(null !== (P = e3[Je2]) && void 0 !== P ? P : h2);
        break;
      case "askToFormat":
        X2(null !== (I = e3[Je2]) && void 0 !== I ? I : g);
        break;
      case "escapeControlCharacters":
        G2(null !== (H2 = e3[Je2]) && void 0 !== H2 ? H2 : m);
        break;
      case "escapeUnicodeCharacters":
        ee(null !== (je2 = e3[Je2]) && void 0 !== je2 ? je2 : b);
        break;
      case "flattenColumns":
        ne(null !== (xe2 = e3[Je2]) && void 0 !== xe2 ? xe2 : j);
        break;
      case "parser":
        te(null !== (ye2 = e3[Je2]) && void 0 !== ye2 ? ye2 : y);
        break;
      case "validator":
        oe(null !== (we2 = e3[Je2]) && void 0 !== we2 ? we2 : w);
        break;
      case "validationParser":
        re(null !== (ke2 = e3[Je2]) && void 0 !== ke2 ? ke2 : k);
        break;
      case "pathParser":
        ae(null !== (Se2 = e3[Je2]) && void 0 !== Se2 ? Se2 : S);
        break;
      case "queryLanguages":
        ie3(null !== (Ce2 = e3[Je2]) && void 0 !== Ce2 ? Ce2 : C3);
        break;
      case "queryLanguageId":
        se(null !== (ze2 = e3[Je2]) && void 0 !== ze2 ? ze2 : z3);
        break;
      case "onChangeQueryLanguage":
        le(null !== (Oe2 = e3[Je2]) && void 0 !== Oe2 ? Oe2 : O);
        break;
      case "onChange":
        ce(null !== (Me2 = e3[Je2]) && void 0 !== Me2 ? Me2 : M2);
        break;
      case "onRenderValue":
        ue(null !== (Ee2 = e3[Je2]) && void 0 !== Ee2 ? Ee2 : A2);
        break;
      case "onClassName":
        ve(null !== (Ae2 = e3[Je2]) && void 0 !== Ae2 ? Ae2 : R);
        break;
      case "onRenderMenu":
        fe(null !== (Re2 = e3[Je2]) && void 0 !== Re2 ? Re2 : T2);
        break;
      case "onRenderContextMenu":
        pe(null !== (qe2 = e3[Je2]) && void 0 !== qe2 ? qe2 : N2);
        break;
      case "onChangeMode":
        he(null !== (Pe2 = e3[Je2]) && void 0 !== Pe2 ? Pe2 : U2);
        break;
      case "onSelect":
        de(null !== (Te2 = e3[Je2]) && void 0 !== Te2 ? Te2 : E);
        break;
      case "onError":
        ge(null !== (Ne2 = e3[Je2]) && void 0 !== Ne2 ? Ne2 : D2);
        break;
      case "onFocus":
        me(null !== (Ie2 = e3[Je2]) && void 0 !== Ie2 ? Ie2 : J);
        break;
      case "onBlur":
        be(null !== (Ue2 = e3[Je2]) && void 0 !== Ue2 ? Ue2 : B);
        break;
      default:
        Be2(Je2);
    }
    function Be2(e4) {
      o2('Unknown property "'.concat(e4, '"'));
    }
    ie3().some((e4) => e4.id === se()) || se(ie3()[0].id), wr();
  }
  function Ve2() {
    return $e.apply(this, arguments);
  }
  function $e() {
    return ($e = i(function* () {
      throw new Error("class method destroy() is deprecated. It is replaced with a method destroy() in the vanilla library.");
    })).apply(this, arguments);
  }
  function He(e3, n3, t4) {
    _(e3), ce() && ce()(e3, n3, t4);
  }
  function Qe(e3) {
    F2(e3), de() && de()(cloneDeep_default(e3));
  }
  function Ye() {
    Xt(xe, true), me() && me()();
  }
  function Ke() {
    Xt(xe, false), be() && be()();
  }
  function Ze(e3) {
    return Xe.apply(this, arguments);
  }
  function Xe() {
    return (Xe = i(function* (e3) {
      Q() !== e3 && (Q(e3), wr(), Je(), he()(e3));
    })).apply(this, arguments);
  }
  function Ge(e3) {
    o2("handleChangeQueryLanguage", e3), se(e3), le()(e3);
  }
  function en(e3) {
    var {
      id: n3,
      json: o3,
      rootPath: r2,
      onTransform: a3,
      onClose: i2
    } = e3;
    L() || Xt(Se, {
      id: n3,
      json: o3,
      rootPath: r2,
      indentation: W2(),
      truncateTextSize: $(),
      escapeControlCharacters: G2(),
      escapeUnicodeCharacters: ee(),
      parser: te(),
      parseMemoizeOne: Sr(t3),
      validationParser: re(),
      pathParser: ae(),
      queryLanguages: ie3(),
      queryLanguageId: se(),
      onChangeQueryLanguage: Ge,
      onRenderValue: ue(),
      onRenderMenu: (e4) => fe()(e4, {
        mode: Q(),
        modal: true,
        readOnly: L()
      }),
      onRenderContextMenu: (e4) => pe()(e4, {
        mode: Q(),
        modal: true,
        readOnly: L(),
        selection: F2()
      }),
      onClassName: ve(),
      onTransform: a3,
      onClose: i2
    });
  }
  function nn(e3) {
    L() || Xt(ke, e3);
  }
  function tn(e3) {
    var {
      content: n3,
      path: t4,
      onPatch: r2,
      onClose: a3
    } = e3;
    o2("onJSONEditorModal", {
      content: n3,
      path: t4
    }), Xt(we, {
      content: n3,
      path: t4,
      onPatch: r2,
      readOnly: L(),
      indentation: W2(),
      tabSize: V2(),
      truncateTextSize: $(),
      mainMenuBar: Y2(),
      navigationBar: K(),
      statusBar: Z2(),
      askToFormat: X2(),
      escapeControlCharacters: G2(),
      escapeUnicodeCharacters: ee(),
      flattenColumns: ne(),
      parser: te(),
      validator: void 0,
      validationParser: re(),
      pathParser: ae(),
      onRenderValue: ue(),
      onClassName: ve(),
      onRenderMenu: fe(),
      onRenderContextMenu: pe(),
      onSortModal: nn,
      onTransformModal: en,
      onClose: a3
    });
  }
  function on(e3) {
    e3.stopPropagation();
  }
  return xo(() => (Ar(te()), Sr(Ce), Ar(_()), di), () => {
    if (!ns(te(), Sr(Ce))) {
      if (o2("parser changed, recreate editor"), $i(_())) {
        var e3 = Sr(Ce).stringify(_().json);
        _({
          json: void 0 !== e3 ? te().parse(e3) : void 0
        });
      }
      Xt(Ce, te()), Xt(je, di());
    }
  }), xo(() => Ar(_()), () => {
    var e3 = Li(_());
    e3 && console.error("Error: " + e3);
  }), xo(() => Ar(F2()), () => {
    null === F2() && console.warn("selection is invalid: it is null but should be undefined");
  }), xo(() => Ar(te()), () => {
    Xt(t3, memoizeOne(te().parse));
  }), xo(() => Ar(Q()), () => {
    o2("mode changed to", Q());
  }), yo(), Ka(true), Ls(e2, {
    children: (e3, n3) => {
      var o3, a3 = Vm(), i2 = vo(a3);
      la(uo(i2), () => Sr(je), (e4) => {
        Ha(Pm(e4, {
          get externalMode() {
            return Q();
          },
          get content() {
            return _();
          },
          get selection() {
            return F2();
          },
          get readOnly() {
            return L();
          },
          get indentation() {
            return W2();
          },
          get tabSize() {
            return V2();
          },
          get truncateTextSize() {
            return $();
          },
          get statusBar() {
            return Z2();
          },
          get askToFormat() {
            return X2();
          },
          get mainMenuBar() {
            return Y2();
          },
          get navigationBar() {
            return K();
          },
          get escapeControlCharacters() {
            return G2();
          },
          get escapeUnicodeCharacters() {
            return ee();
          },
          get flattenColumns() {
            return ne();
          },
          get parser() {
            return te();
          },
          get parseMemoizeOne() {
            return Sr(t3);
          },
          get validator() {
            return oe();
          },
          get validationParser() {
            return re();
          },
          get pathParser() {
            return ae();
          },
          insideModal: false,
          get onError() {
            return ge();
          },
          onChange: He,
          onChangeMode: Ze,
          onSelect: Qe,
          get onRenderValue() {
            return ue();
          },
          get onClassName() {
            return ve();
          },
          onFocus: Ye,
          onBlur: Ke,
          get onRenderMenu() {
            return fe();
          },
          get onRenderContextMenu() {
            return pe();
          },
          onSortModal: nn,
          onTransformModal: en,
          onJSONEditorModal: tn,
          $$legacy: true
        }), (e5) => Xt(ye, e5), () => Sr(ye));
      });
      var s3 = fo(i2, 2), l2 = (e4) => {
        !function(e5, n4) {
          var t4, o4;
          Tt(n4, false);
          var r2 = Kt(void 0, true), a4 = Kt(void 0, true), i3 = Kt(void 0, true), s4 = Kt(void 0, true), l3 = ii("jsoneditor:SortModal"), u3 = ai(n4, "id", 9), v3 = ai(n4, "json", 9), f = ai(n4, "rootPath", 9), p4 = ai(n4, "onSort", 9), h4 = ai(n4, "onClose", 9), g2 = {
            value: 1,
            label: "ascending"
          }, m2 = [g2, {
            value: -1,
            label: "descending"
          }], b2 = "".concat(u3(), ":").concat(compileJSONPointer(f())), j2 = Kt(null === (t4 = _m()[b2]) || void 0 === t4 ? void 0 : t4.selectedProperty, true), x = Kt((null === (o4 = _m()[b2]) || void 0 === o4 ? void 0 : o4.selectedDirection) || g2, true), y2 = Kt(void 0, true);
          function w2() {
            try {
              var e6, n5, t5;
              Xt(y2, void 0);
              var o5 = (null === (e6 = Sr(j2)) || void 0 === e6 ? void 0 : e6.value) || (null === (n5 = Sr(s4)) || void 0 === n5 || null === (n5 = n5[0]) || void 0 === n5 ? void 0 : n5.value) || [], r3 = null === (t5 = Sr(x)) || void 0 === t5 ? void 0 : t5.value, a5 = Gp(v3(), f(), o5, r3);
              void 0 !== p4() && void 0 !== f() && p4()({
                operations: a5,
                rootPath: f(),
                itemPath: o5,
                direction: r3
              }), h4()();
            } catch (e7) {
              Xt(y2, String(e7));
            }
          }
          function k2(e6) {
            e6.focus();
          }
          xo(() => (Ar(v3()), Ar(f())), () => {
            Xt(r2, getIn(v3(), f()));
          }), xo(() => Sr(r2), () => {
            Xt(a4, Array.isArray(Sr(r2)));
          }), xo(() => (Sr(a4), Sr(r2)), () => {
            Xt(i3, Sr(a4) ? Ei(Sr(r2)) : void 0);
          }), xo(() => (Sr(i3), su), () => {
            Xt(s4, Sr(i3) ? Sr(i3).map(su) : void 0);
          }), xo(() => (_m(), Sr(j2), Sr(x)), () => {
            _m(_m()[b2] = {
              selectedProperty: Sr(j2),
              selectedDirection: Sr(x)
            }), l3("store state in memory", b2, _m()[b2]);
          }), yo(), Ka(true), _f(e5, {
            get onClose() {
              return h4();
            },
            className: "jse-sort-modal",
            children: (e6, n5) => {
              var t5 = Wm(), o5 = vo(t5), r3 = Lt(() => Sr(a4) ? "Sort array items" : "Sort object keys");
              hf(o5, {
                get title() {
                  return Sr(r3);
                },
                get onClose() {
                  return h4();
                }
              });
              var i4 = uo(fo(o5, 2)), l4 = fo(uo(i4)), c = uo(l4), d = fo(uo(c)), u4 = uo(d), v4 = fo(c), p5 = (e7) => {
                var n6 = Fm(), t6 = fo(uo(n6));
                sf(uo(t6), {
                  showChevron: true,
                  get items() {
                    return Sr(s4);
                  },
                  get value() {
                    return Sr(j2);
                  },
                  set value(e8) {
                    Xt(j2, e8);
                  },
                  $$legacy: true
                }), Hr(e7, n6);
              };
              sa(v4, (e7) => {
                Sr(a4), Sr(s4), Or(() => {
                  var e8;
                  return Sr(a4) && Sr(s4) && (null === (e8 = Sr(s4)) || void 0 === e8 ? void 0 : e8.length) > 1;
                }) && e7(p5);
              });
              var g3 = fo(v4), b3 = fo(uo(g3));
              sf(uo(b3), {
                showChevron: true,
                clearable: false,
                get items() {
                  return m2;
                },
                get value() {
                  return Sr(x);
                },
                set value(e7) {
                  Xt(x, e7);
                },
                $$legacy: true
              });
              var S2 = fo(i4, 2), C4 = uo(S2), z4 = (e7) => {
                var n6 = Lm(), t6 = uo(n6);
                ko(() => Xr(t6, Sr(y2))), Hr(e7, n6);
              };
              sa(C4, (e7) => {
                Sr(y2) && e7(z4);
              });
              var O2 = uo(fo(S2, 2));
              jo(() => Dr("click", O2, w2)), ba(O2, (e7) => null == k2 ? void 0 : k2(e7)), ko((e7) => {
                Na(u4, e7), O2.disabled = (Sr(a4), Sr(s4), Sr(j2), Or(() => {
                  var e8;
                  return !!(Sr(a4) && Sr(s4) && (null === (e8 = Sr(s4)) || void 0 === e8 ? void 0 : e8.length) > 1) && !Sr(j2);
                }));
              }, [() => (Ar(f()), Ar(isEmpty_default), Ar(au), Or(() => f() && !isEmpty_default(f()) ? au(f()) : "(document root)"))], Lt), Hr(e6, t5);
            },
            $$slots: {
              default: true
            }
          }), Nt();
        }(e4, ri(() => Sr(ke), {
          onClose: () => {
            var e5;
            null === (e5 = Sr(ke)) || void 0 === e5 || e5.onClose(), Xt(ke, void 0);
          }
        }));
      };
      sa(s3, (e4) => {
        Sr(ke) && e4(l2);
      });
      var u2 = fo(s3, 2), v2 = (e4) => {
        Wg(e4, ri(() => Sr(Se), {
          onClose: () => {
            var e5;
            null === (e5 = Sr(Se)) || void 0 === e5 || e5.onClose(), Xt(Se, void 0);
          }
        }));
      };
      sa(u2, (e4) => {
        Sr(Se) && e4(v2);
      });
      var p3 = fo(u2, 2), h3 = (e4) => {
        !function(e5, n4) {
          Tt(n4, false);
          var t4 = Kt(void 0, true), o4 = Kt(void 0, true), a4 = Kt(void 0, true), i3 = Kt(void 0, true), s4 = ii("jsoneditor:JSONEditorModal"), l3 = ai(n4, "content", 9), d = ai(n4, "path", 9), u3 = ai(n4, "onPatch", 9), v3 = ai(n4, "readOnly", 9), p4 = ai(n4, "indentation", 9), h4 = ai(n4, "tabSize", 9), g2 = ai(n4, "truncateTextSize", 9), m2 = ai(n4, "mainMenuBar", 9), b2 = ai(n4, "navigationBar", 9), j2 = ai(n4, "statusBar", 9), y2 = ai(n4, "askToFormat", 9), w2 = ai(n4, "escapeControlCharacters", 9), k2 = ai(n4, "escapeUnicodeCharacters", 9), S2 = ai(n4, "flattenColumns", 9), C4 = ai(n4, "parser", 9), z4 = ai(n4, "validator", 9), O2 = ai(n4, "validationParser", 9), M3 = ai(n4, "pathParser", 9), E2 = ai(n4, "onRenderValue", 9), A3 = ai(n4, "onClassName", 9), R2 = ai(n4, "onRenderMenu", 9), T3 = ai(n4, "onRenderContextMenu", 9), N3 = ai(n4, "onSortModal", 9), U3 = ai(n4, "onTransformModal", 9), D3 = ai(n4, "onClose", 9), J2 = Kt(void 0, true), B2 = Kt(void 0, true), _2 = {
            mode: W3(l3()),
            content: l3(),
            selection: void 0,
            relativePath: d()
          }, F3 = Kt([_2], true), L2 = Kt(void 0, true);
          function W3(e6) {
            return $i(e6) && isJSONArray(e6.json) ? os.table : os.tree;
          }
          function V3() {
            var e6, n5 = null === (e6 = last_default(Sr(F3))) || void 0 === e6 ? void 0 : e6.selection;
            Nc(n5) && Sr(J2).scrollTo(vd(n5));
          }
          function $2() {
            if (s4("handleApply"), !v3()) try {
              Xt(L2, void 0);
              var e6 = Sr(t4).relativePath, n5 = Sr(t4).content, o5 = [{
                op: "replace",
                path: compileJSONPointer(e6),
                value: Qi(n5, C4()).json
              }];
              if (Sr(F3).length > 1) {
                var a5 = Qi(Sr(F3)[Sr(F3).length - 2].content, C4()).json, i4 = {
                  json: immutableJSONPatch(a5, o5)
                }, l4 = r(r({}, Sr(F3)[Sr(F3).length - 2] || _2), {}, {
                  content: i4
                });
                Xt(F3, [...Sr(F3).slice(0, Sr(F3).length - 2), l4]), wr(), V3();
              } else u3()(o5), D3()();
            } catch (e7) {
              Xt(L2, String(e7));
            }
          }
          function H2() {
            if (s4("handleClose"), Sr(B2)) Xt(B2, false);
            else if (Sr(F3).length > 1) {
              var e6;
              Xt(F3, initial_default(Sr(F3))), wr(), null === (e6 = Sr(J2)) || void 0 === e6 || e6.focus(), V3(), Xt(L2, void 0);
            } else D3()();
          }
          function Q2(e6) {
            s4("handleChange", e6), Z3((n5) => r(r({}, n5), {}, {
              content: e6
            }));
          }
          function Y3(e6) {
            s4("handleChangeSelection", e6), Z3((n5) => r(r({}, n5), {}, {
              selection: e6
            }));
          }
          function K2(e6) {
            s4("handleChangeMode", e6), Z3((n5) => r(r({}, n5), {}, {
              mode: e6
            }));
          }
          function Z3(e6) {
            var n5 = e6(last_default(Sr(F3)));
            Xt(F3, [...initial_default(Sr(F3)), n5]);
          }
          function X3(e6) {
            Xt(L2, e6.toString()), console.error(e6);
          }
          function G3(e6) {
            var n5, {
              content: t5,
              path: o5
            } = e6;
            s4("handleJSONEditorModal", {
              content: t5,
              path: o5
            });
            var r2 = {
              mode: W3(t5),
              content: t5,
              selection: void 0,
              relativePath: o5
            };
            Xt(F3, [...Sr(F3), r2]), wr(), null === (n5 = Sr(J2)) || void 0 === n5 || n5.focus();
          }
          function ee2(e6) {
            e6.focus();
          }
          ta(() => {
            var e6;
            null === (e6 = Sr(J2)) || void 0 === e6 || e6.focus();
          }), xo(() => Sr(F3), () => {
            Xt(t4, last_default(Sr(F3)) || _2);
          }), xo(() => Sr(F3), () => {
            Xt(o4, Sr(F3).flatMap((e6) => e6.relativePath));
          }), xo(() => (Sr(o4), au), () => {
            Xt(a4, isEmpty_default(Sr(o4)) ? "(document root)" : au(Sr(o4)));
          }), xo(() => Ar(C4()), () => {
            Xt(i3, memoizeOne(C4().parse));
          }), yo(), Ka(true), _f(e5, {
            onClose: H2,
            className: "jse-jsoneditor-modal",
            get fullscreen() {
              return Sr(B2);
            },
            children: (e6, n5) => {
              var o5 = Jm();
              Ls(uo(o5), {
                children: (e7, n6) => {
                  var o6 = Dm(), r2 = vo(o6), s5 = Lt(() => (Sr(F3), Or(() => Sr(F3).length > 1 ? " (".concat(Sr(F3).length, ")") : "")));
                  hf(r2, {
                    get title() {
                      var e8;
                      return "Edit nested content ".concat(null !== (e8 = Sr(s5)) && void 0 !== e8 ? e8 : "");
                    },
                    fullScreenButton: true,
                    onClose: H2,
                    get fullscreen() {
                      return Sr(B2);
                    },
                    set fullscreen(e8) {
                      Xt(B2, e8);
                    },
                    $$legacy: true
                  });
                  var l4 = fo(r2, 2), c = fo(uo(l4), 2), d2 = fo(c, 4);
                  Ha(Pm(uo(d2), {
                    get externalMode() {
                      return Sr(t4), Or(() => Sr(t4).mode);
                    },
                    get content() {
                      return Sr(t4), Or(() => Sr(t4).content);
                    },
                    get selection() {
                      return Sr(t4), Or(() => Sr(t4).selection);
                    },
                    get readOnly() {
                      return v3();
                    },
                    get indentation() {
                      return p4();
                    },
                    get tabSize() {
                      return h4();
                    },
                    get truncateTextSize() {
                      return g2();
                    },
                    get statusBar() {
                      return j2();
                    },
                    get askToFormat() {
                      return y2();
                    },
                    get mainMenuBar() {
                      return m2();
                    },
                    get navigationBar() {
                      return b2();
                    },
                    get escapeControlCharacters() {
                      return w2();
                    },
                    get escapeUnicodeCharacters() {
                      return k2();
                    },
                    get flattenColumns() {
                      return S2();
                    },
                    get parser() {
                      return C4();
                    },
                    get parseMemoizeOne() {
                      return Sr(i3);
                    },
                    get validator() {
                      return z4();
                    },
                    get validationParser() {
                      return O2();
                    },
                    get pathParser() {
                      return M3();
                    },
                    insideModal: true,
                    onError: X3,
                    onChange: Q2,
                    onChangeMode: K2,
                    onSelect: Y3,
                    get onRenderValue() {
                      return E2();
                    },
                    get onClassName() {
                      return A3();
                    },
                    get onFocus() {
                      return Vg;
                    },
                    get onBlur() {
                      return Vg;
                    },
                    get onRenderMenu() {
                      return R2();
                    },
                    get onRenderContextMenu() {
                      return T3();
                    },
                    get onSortModal() {
                      return N3();
                    },
                    get onTransformModal() {
                      return U3();
                    },
                    onJSONEditorModal: G3,
                    $$legacy: true
                  }), (e8) => Xt(J2, e8), () => Sr(J2));
                  var u4 = uo(fo(d2, 2)), f = (e8) => {
                    var n7 = Tm(), t5 = uo(n7);
                    ko(() => Xr(t5, Sr(L2))), Hr(e8, n7);
                  };
                  sa(u4, (e8) => {
                    Sr(L2) && e8(f);
                  });
                  var x = fo(u4, 2), q2 = (e8) => {
                    var n7 = Nm();
                    nl(uo(n7), {
                      get data() {
                        return faCaretLeft;
                      }
                    }), Dr("click", n7, H2), Hr(e8, n7);
                  };
                  sa(x, (e8) => {
                    Sr(F3), Or(() => Sr(F3).length > 1) && e8(q2);
                  });
                  var P = fo(x, 2), I = (e8) => {
                    var n7 = Im();
                    jo(() => Dr("click", n7, $2)), ba(n7, (e9) => null == ee2 ? void 0 : ee2(e9)), Hr(e8, n7);
                  }, D4 = (e8) => {
                    var n7 = Um();
                    Dr("click", n7, H2), Hr(e8, n7);
                  };
                  sa(P, (e8) => {
                    v3() ? e8(D4, false) : e8(I);
                  }), ko(() => Na(c, Sr(a4))), Hr(e7, o6);
                },
                $$slots: {
                  default: true
                }
              }), Hr(e6, o5);
            },
            $$slots: {
              default: true
            }
          }), Nt();
        }(e4, ri(() => Sr(we), {
          onClose: () => {
            var e5;
            null === (e5 = Sr(we)) || void 0 === e5 || e5.onClose(), Xt(we, void 0);
          }
        }));
      };
      sa(p3, (e4) => {
        Sr(we) && e4(h3);
      }), ko((e4) => o3 = Ca(i2, 1, "jse-main svelte-57bmz4", null, o3, e4), [() => ({
        "jse-focus": Sr(xe)
      })], Lt), Dr("keydown", i2, on), Hr(e3, a3);
    },
    $$slots: {
      default: true
    }
  }), Va(n2, "get", ze), Va(n2, "set", Oe), Va(n2, "update", Me), Va(n2, "patch", Ee), Va(n2, "select", Ae), Va(n2, "expand", Re), Va(n2, "collapse", qe), Va(n2, "transform", Pe), Va(n2, "validate", Te), Va(n2, "acceptAutoRepair", Ne), Va(n2, "scrollTo", Ie), Va(n2, "findElement", De), Va(n2, "focus", Je), Va(n2, "refresh", Be), Va(n2, "updateProps", We2), Va(n2, "destroy", Ve2), Nt({
    get: ze,
    set: Oe,
    update: Me,
    patch: Ee,
    select: Ae,
    expand: Re,
    collapse: qe,
    transform: Pe,
    validate: Te,
    acceptAutoRepair: Ne,
    scrollTo: Ie,
    findElement: De,
    focus: Je,
    refresh: Be,
    updateProps: We2,
    destroy: Ve2
  });
}
function Hm(e2) {
  var {
    target: n2,
    props: t3
  } = e2, o2 = Gr($m, {
    target: n2,
    props: t3
  });
  return o2.destroy = i(function* () {
    return function(e3, n3) {
      var t4 = na.get(e3);
      return t4 ? (na.delete(e3), t4(n3)) : Promise.resolve();
    }(o2);
  }), wr(), o2;
}
function Qm(e2) {
  var {
    target: n2,
    props: t3
  } = e2;
  return console.warn('WARNING: the constructor "new JSONEditor(...)" is deprecated since v1. Please use "createJSONEditor(...)" instead.'), Hm({
    target: n2,
    props: t3
  });
}
export {
  ol as BooleanToggle,
  as as CaretType,
  sl as ColorPicker,
  bd as EditableValue,
  sg as EnumValue,
  Qm as JSONEditor,
  $m as JsonEditor,
  os as Mode,
  Xd as ReadonlyValue,
  ss as SearchField,
  rs as SelectionType,
  ls as SortDirection,
  ou as TimestampTag,
  cs as UpdateSelectionAfterChange,
  is as ValidationSeverity,
  nd as createAfterSelection,
  ug as createAjvValidator,
  vg as createAjvValidatorAsync,
  Zc as createEditKeySelection,
  Gc as createEditValueSelection,
  ed as createInsideSelection,
  Hm as createJSONEditor,
  Kc as createKeySelection,
  td as createMultiSelection,
  Xc as createValueSelection,
  Zi as estimateSerializedSize,
  Oc as expandAll,
  Cc as expandMinimal,
  Mc as expandNone,
  zc as expandSelf,
  fd as getAnchorPath,
  Bc as getEndPath,
  vd as getFocusPath,
  Uc as getSelectionPaths,
  Jc as getStartPath,
  hd as getValueClass,
  Hl as hasSearchResults,
  Ec as isAfterSelection,
  Wl as isArrayRecursiveState,
  gi as isBoolean,
  xi as isColor,
  Wi as isContent,
  Ul as isContentParseError,
  Dl as isContentValidationErrors,
  Il as isContextMenuColumn,
  Nl as isContextMenuRow,
  rd as isEditingSelection,
  ns as isEqualParser,
  $l as isExpandableState,
  Ac as isInsideSelection,
  $i as isJSONContent,
  Rc as isKeySelection,
  Ki as isLargeContent,
  Pl as isMenuButton,
  Tl as isMenuDropDownButton,
  ql as isMenuLabel,
  Rl as isMenuSeparator,
  Al as isMenuSpace,
  Kl as isModeHistoryItem,
  Pc as isMultiSelection,
  Bl as isNestedValidationError,
  pi as isObject,
  hi as isObjectOrArray,
  Ll as isObjectRecursiveState,
  Fl as isSvelteActionRenderer,
  _l as isSvelteComponentRenderer,
  Vi as isTextContent,
  Yl as isTextHistoryItem,
  mi as isTimestamp,
  Ql as isTreeHistoryItem,
  ki as isUrl,
  Jl as isValidationError,
  Vl as isValueRecursiveState,
  qc as isValueSelection,
  Cg as javascriptQueryLanguage,
  mg as jmespathQueryLanguage,
  Hs as jsonQueryLanguage,
  xg as jsonpathQueryLanguage,
  Ns as keyComboFromEvent,
  wg as lodashQueryLanguage,
  Jf as onEscape,
  iu as parseJSONPath,
  dg as renderJSONSchemaEnum,
  ru as renderValue,
  zg as resizeObserver,
  Si as stringConvert,
  au as stringifyJSONPath,
  Qi as toJSONContent,
  Hi as toTextContent,
  yi as valueType
};
/*! Bundled license information:

natural-compare-lite/index.js:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)

lodash-es/lodash.default.js:
lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@fortawesome/free-regular-svg-icons/index.mjs:
@fortawesome/free-solid-svg-icons/index.mjs:
  (*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)
*/
//# sourceMappingURL=vanilla-jsoneditor.js.map
